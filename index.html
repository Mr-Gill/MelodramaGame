<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Melodrama Werewolf Narrator</title>
  <meta name="description" content="Digital narrator tool for the Melodrama Werewolf classroom drama game." />
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#0f172a" />
  <style>
    :root {
      color-scheme: dark;
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --text-primary: #f8fafc;
      --text-secondary: #cbd5e1;
      --accent-good: #38bdf8;
      --accent-evil: #f472b6;
      --accent-neutral: #facc15;
      --accent-ui: #22d3ee;
      --border-color: #475569;
      --panel-radius: 16px;
      --shadow: 0 12px 30px rgba(15, 23, 42, 0.4);
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body.light {
      color-scheme: light;
      --bg-primary: #f1f5f9;
      --bg-secondary: #ffffff;
      --bg-tertiary: #e2e8f0;
      --text-primary: #0f172a;
      --text-secondary: #334155;
      --border-color: #cbd5e1;
      --shadow: 0 8px 22px rgba(15, 23, 42, 0.12);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.08), transparent 55%), var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1rem clamp(1rem, 4vw, 3rem);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.8rem, 4vw, 2.6rem);
      letter-spacing: 0.04em;
    }

    header h1 span {
      color: var(--accent-evil);
    }

    header .actions {
      display: flex;
      gap: 0.75rem;
      align-items: center;
    }

    button,
    select,
    input,
    textarea {
      font: inherit;
      color: inherit;
    }

    button {
      border: none;
      padding: 0.65rem 1.1rem;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.7), rgba(244, 114, 182, 0.9));
      color: #0f172a;
      font-weight: 600;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
      box-shadow: 0 8px 18px rgba(56, 189, 248, 0.25);
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(244, 114, 182, 0.28);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    main {
      flex: 1;
      padding: 0 clamp(1rem, 4vw, 3rem) 4rem;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 1.5rem;
    }

    section {
      background: rgba(15, 23, 42, 0.55);
      border: 1px solid rgba(148, 163, 184, 0.12);
      border-radius: var(--panel-radius);
      padding: clamp(1.25rem, 3vw, 2rem);
      box-shadow: var(--shadow);
      backdrop-filter: blur(18px);
    }

    body.light section {
      background: rgba(255, 255, 255, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.25);
    }

    h2 {
      margin-top: 0;
      font-size: clamp(1.4rem, 3vw, 1.8rem);
      letter-spacing: 0.02em;
    }

    .setup-grid {
      display: grid;
      gap: 1.25rem;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .stat {
      background: rgba(15, 23, 42, 0.35);
      padding: 0.75rem 1rem;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.16);
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .stat strong {
      font-size: 1.8rem;
      letter-spacing: 0.05em;
    }

    .range-input {
      display: grid;
      gap: 0.5rem;
    }

    input[type="range"] {
      accent-color: var(--accent-evil);
    }

    .role-groups {
      display: grid;
      gap: 1rem;
    }

    .role-group {
      border: 1px solid rgba(148, 163, 184, 0.16);
      border-radius: 14px;
      padding: 1rem;
      background: rgba(15, 23, 42, 0.35);
      display: grid;
      gap: 0.75rem;
    }

    body.light .role-group {
      background: rgba(255, 255, 255, 0.9);
    }

    .role-group-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 1rem;
    }

    .role-cards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 0.75rem;
    }

    .role-card {
      border-radius: 18px;
      padding: 1rem;
      border: 2px solid transparent;
      background: rgba(15, 23, 42, 0.45);
      cursor: pointer;
      transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
      display: grid;
      gap: 0.5rem;
      position: relative;
    }

    body.light .role-card {
      background: rgba(248, 250, 252, 0.88);
    }

    .role-card[data-selected="true"] {
      transform: translateY(-3px);
      border-color: var(--accent-ui);
      box-shadow: 0 12px 22px rgba(34, 211, 238, 0.3);
    }

    .role-card .type {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0.75;
    }

    .role-card .team-label {
      font-size: 0.8rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .badge {
      display: inline-flex;
      padding: 0.25rem 0.55rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .badge.good {
      background: rgba(56, 189, 248, 0.2);
      color: #bae6fd;
    }

    .badge.evil {
      background: rgba(244, 114, 182, 0.2);
      color: #fbcfe8;
    }

    .badge.neutral {
      background: rgba(250, 204, 21, 0.2);
      color: #fef08a;
    }

    body.light .badge.good {
      color: #075985;
    }

    body.light .badge.evil {
      color: #9d174d;
    }

    body.light .badge.neutral {
      color: #b45309;
    }

    .role-card p {
      font-size: 0.9rem;
      margin: 0;
      line-height: 1.4;
      color: var(--text-secondary);
    }

    .role-card h3 {
      margin: 0;
      font-size: 1.05rem;
      line-height: 1.3;
    }

    .card-ghost {
      display: none;
    }

    .start-footer {
      margin-top: 1.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: space-between;
      align-items: center;
    }

    .name-list {
      width: 100%;
      min-height: 120px;
      padding: 0.75rem;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.4);
      resize: vertical;
    }

    body.light .name-list {
      background: rgba(255, 255, 255, 0.95);
    }

    .hidden {
      display: none !important;
    }

    .game-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1rem;
    }

    .script-panel {
      display: grid;
      gap: 1rem;
    }

    .script-step {
      display: grid;
      gap: 0.75rem;
    }

    .script-block {
      padding: 0.85rem 1rem;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.35);
      line-height: 1.5;
    }

    .block-say {
      border-left: 4px solid var(--accent-evil);
      font-size: 1.15rem;
      font-style: italic;
    }

    .block-narrator {
      border-left: 4px solid var(--accent-ui);
    }

    .block-info {
      border-left: 4px solid var(--accent-good);
      color: var(--text-secondary);
    }

    .block-reminder {
      border-left: 4px solid var(--accent-neutral);
    }

    .block-action {
      border-left: 4px solid #f97316;
    }

    .script-nav {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .script-nav button {
      flex: 1;
      min-width: 140px;
    }

    .status-panel,
    .players-panel {
      display: grid;
      gap: 1rem;
    }

    .timer-card {
      display: grid;
      gap: 0.75rem;
      padding: 1.5rem;
      border-radius: 18px;
      background: radial-gradient(circle at 25% 25%, rgba(56, 189, 248, 0.22), transparent), rgba(15, 23, 42, 0.45);
      text-align: center;
      border: 1px solid rgba(148, 163, 184, 0.22);
    }

    .timer-display {
      font-size: clamp(2.4rem, 6vw, 3.4rem);
      letter-spacing: 0.1em;
    }

    .timer-controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .timer-controls button {
      flex: 1 1 100px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.5);
      border: 1px solid rgba(148, 163, 184, 0.22);
      font-size: 0.85rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 0.75rem;
    }

    .player-card {
      border-radius: 16px;
      padding: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.18);
      background: rgba(15, 23, 42, 0.4);
      display: grid;
      gap: 0.5rem;
    }

    .player-card header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      padding: 0;
    }

    .player-name {
      font-weight: 600;
      letter-spacing: 0.04em;
    }

    .player-meta {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .player-actions {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    .player-actions button {
      background: rgba(148, 163, 184, 0.18);
      color: var(--text-primary);
      padding: 0.35rem 0.75rem;
      border-radius: 8px;
      flex: 1;
      min-width: 90px;
    }

    .player-card[data-status="eliminated"] {
      opacity: 0.55;
      text-decoration: line-through;
    }

    .player-card[data-status="protected"] {
      border-color: var(--accent-good);
    }

    .player-card textarea {
      width: 100%;
      min-height: 70px;
      border-radius: 10px;
      padding: 0.5rem;
      background: rgba(15, 23, 42, 0.45);
      border: 1px solid rgba(148, 163, 184, 0.25);
      color: inherit;
      resize: vertical;
    }

    @media (max-width: 768px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }

      header .actions {
        width: 100%;
        justify-content: flex-start;
      }

      .role-cards {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }

      .player-actions button {
        flex: 1 1 45%;
      }
    }

    .resolution-summary {
      background: rgba(15, 23, 42, 0.6);
      border: 2px solid var(--accent-ui);
      border-radius: 16px;
      padding: 1.5rem;
      margin: 1rem 0;
      box-shadow: 0 8px 24px rgba(34, 211, 238, 0.25);
    }

    .resolution-summary h3 {
      margin: 0 0 1rem 0;
      color: var(--accent-ui);
      font-size: 1.4rem;
    }

    .resolution-summary h4 {
      margin: 1rem 0 0.5rem 0;
      font-size: 1.1rem;
      color: var(--text-primary);
    }

    .resolution-section {
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 8px;
      border-left: 3px solid var(--accent-good);
    }

    .resolution-section p {
      margin: 0.25rem 0;
      font-size: 0.95rem;
    }

    .special-event {
      color: var(--accent-neutral);
      font-weight: 600;
    }

    .elimination {
      color: var(--accent-evil);
      font-weight: 600;
    }

    .action-tracker {
      background: rgba(15, 23, 42, 0.45);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0;
    }

    .action-tracker label {
      display: block;
      margin: 0.5rem 0 0.25rem 0;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .action-tracker select {
      width: 100%;
      padding: 0.5rem;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.6);
      color: inherit;
      font-size: 0.95rem;
    }

    .action-tracker button {
      margin-top: 0.75rem;
      width: 100%;
    }

    .action-buttons {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .action-buttons button {
      flex: 1;
      padding: 0.75rem;
    }

    /* Theme-specific animations */
    @keyframes flicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.85; }
    }

    @keyframes shimmer {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.15); }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    @keyframes spotlight {
      0%, 100% { box-shadow: 0 0 30px rgba(245, 158, 11, 0.3); }
      50% { box-shadow: 0 0 50px rgba(245, 158, 11, 0.6); }
    }

    @keyframes tech-glow {
      0%, 100% { box-shadow: 0 0 20px rgba(34, 211, 238, 0.4); }
      50% { box-shadow: 0 0 40px rgba(34, 211, 238, 0.8); }
    }

    @keyframes dust {
      0%, 100% { opacity: 0.95; }
      50% { opacity: 0.85; }
    }

    @keyframes wave {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }

    @keyframes heartbeat {
      0%, 100% { transform: scale(1); }
      25% { transform: scale(1.05); }
      50% { transform: scale(1); }
    }

    /* Audio controls styling */
    .audio-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      background: rgba(15, 23, 42, 0.35);
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.16);
    }

    body.light .audio-controls {
      background: rgba(255, 255, 255, 0.9);
    }

    .audio-controls button {
      padding: 0.4rem 0.8rem;
      font-size: 0.85rem;
      min-width: auto;
    }

    .audio-controls .volume-slider {
      width: 100px;
      accent-color: var(--accent-ui);
    }

    .audio-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .audio-indicator.playing {
      color: var(--accent-ui);
    }

    /* Phase indicator for audio */
    .phase-audio-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.25rem 0.5rem;
      border-radius: 999px;
      background: rgba(34, 211, 238, 0.15);
      font-size: 0.75rem;
      margin-left: 0.5rem;
    }
  </style>
</head>
<body>
  <header>
    <h1>ðŸŽ­ <span>Melodrama</span> Werewolf Narrator</h1>
    <div class="actions">
      <div class="audio-controls hidden" id="audio-controls">
        <button id="toggle-audio" type="button" title="Toggle ambient audio">ðŸ”‡</button>
        <input id="volume-slider" type="range" class="volume-slider" min="0" max="100" value="50" title="Volume" />
        <span class="audio-indicator" id="audio-indicator">
          <span id="audio-phase">Night</span>
        </span>
      </div>
      <button id="toggle-mode" type="button" aria-pressed="false">Toggle Dark/Light</button>
      <button id="reset-game" type="button">New Game</button>
      <a id="download-notes" class="pill" href="#" download="melodrama-notes.txt">Export Notes</a>
    </div>
  </header>

  <main>
    <section id="setup-section">
      <h2>Game Setup</h2>
      <p>Build tonight's cast, assign names, and choose a theme. The tool will auto-balance good and evil roles and guide you through every beat of the drama.</p>

      <div class="setup-grid">
        <div class="stat">
          <span>Total Players</span>
          <strong id="player-count-display">18</strong>
          <div class="range-input">
            <input id="player-count" type="range" min="12" max="25" value="18" />
            <div class="stat-grid" style="margin-top:0.5rem;">
              <div>
                <small>Suggested Good</small>
                <div class="pill" id="suggested-good">12</div>
              </div>
              <div>
                <small>Suggested Evil</small>
                <div class="pill" id="suggested-evil">6</div>
              </div>
            </div>
          </div>
        </div>

        <div class="stat">
          <span>Theme</span>
          <select id="theme-select" aria-label="Select narration theme"></select>
          <small id="theme-description" style="color:var(--text-secondary);"></small>
        </div>

        <div class="stat">
          <span>Player Names (optional)</span>
          <textarea id="player-names" class="name-list" placeholder="Enter one name per line to assign specific students."></textarea>
          <small style="color:var(--text-secondary);">Names are matched to roles when you start the game.</small>
        </div>
      </div>

      <div class="role-groups" id="role-groups"></div>

      <div class="start-footer">
        <div>
          <div class="pill" id="role-balance">Good: 0 â€¢ Evil: 0 â€¢ Selected: 0</div>
          <small id="balance-warning" style="display:block; margin-top:0.4rem; color:#fef08a;">Select roles to match the player count.</small>
        </div>
        <button id="start-game" type="button" disabled>Enter Narrator View</button>
      </div>
    </section>

    <section id="game-section" class="hidden">
      <div class="game-grid">
        <div class="script-panel" aria-live="polite">
          <div>
            <div class="pill" id="phase-label">Setup</div>
            <h2 id="script-title">Narrator Script</h2>
          </div>
          <div id="script-steps" class="script-step"></div>
          <div class="script-nav">
            <button id="prev-step" type="button">Back</button>
            <button id="next-step" type="button">Next</button>
          </div>
        </div>

        <div class="status-panel">
          <div class="timer-card" aria-live="polite">
            <span class="pill" id="timer-phase">Timer</span>
            <div class="timer-display" id="timer-display">03:00</div>
            <div class="timer-controls">
              <button data-timer="180" type="button">3 min</button>
              <button data-timer="60" type="button">1 min</button>
              <button id="start-timer" type="button">Start</button>
              <button id="pause-timer" type="button">Pause</button>
              <button id="reset-timer" type="button">Reset</button>
            </div>
          </div>
          <div class="stat-grid">
            <div class="stat">
              <span>Night</span>
              <strong id="night-number">1</strong>
            </div>
            <div class="stat">
              <span>Alive</span>
              <strong id="alive-count">0</strong>
            </div>
            <div class="stat">
              <span>Team Split</span>
              <div>Good: <strong id="good-count">0</strong></div>
              <div>Evil: <strong id="evil-count">0</strong></div>
            </div>
          </div>
          <div class="stat">
            <span>Notes</span>
            <textarea id="narrator-notes" class="name-list" placeholder="Quick reminders, dramatic twists, or classroom cues."></textarea>
          </div>
        </div>

        <div class="players-panel">
          <div class="pill">Players &amp; Roles</div>
          <div id="player-list" class="player-list"></div>
        </div>
      </div>
    </section>
  </main>

  <template id="player-card-template">
    <article class="player-card" data-status="alive">
      <header>
        <div>
          <div class="player-name"></div>
          <div class="player-meta"></div>
        </div>
        <span class="badge"></span>
      </header>
      <p class="player-ability"></p>
      <div class="player-actions">
        <button data-action="toggle-eliminated" type="button">Toggle Eliminated</button>
        <button data-action="toggle-protected" type="button">Toggle Protected</button>
      </div>
      <textarea class="player-notes" placeholder="Add notes for this player"></textarea>
    </article>
  </template>

  <script>
    const CHARACTERS = [
      { id: 1, name: "The Evil Mastermind", team: "evil", type: "villain", short: "Leads the villains, breaks ties.", nightOrder: 1, hasNightAction: true, oneTimeOnly: false },
      { id: 2, name: "The Assassin", team: "evil", type: "villain", short: "Once per game, add a second victim.", nightOrder: 1, hasNightAction: true, oneTimeOnly: false, limited: 1 },
      { id: 3, name: "The Pretender", team: "evil", type: "villain", short: "Appears good to Elder checks.", nightOrder: 1, hasNightAction: true, oneTimeOnly: false },
      { id: 4, name: "Corrupted Authority", team: "evil", type: "villain", short: "Day vote counts as two.", nightOrder: 1, hasNightAction: true, oneTimeOnly: false },
      { id: 5, name: "The Stalker", team: "evil", type: "villain", short: "Backup elimination if target survives.", nightOrder: 1, hasNightAction: true, oneTimeOnly: false },
      { id: 6, name: "The Right Hand", team: "evil", type: "accomplice", short: "Block one player's night ability.", nightOrder: 2, hasNightAction: true, oneTimeOnly: false, limited: 1 },
      { id: 7, name: "The Spy", team: "evil", type: "accomplice", short: "Learn if a player has a night action.", nightOrder: 2, hasNightAction: true, oneTimeOnly: false },
      { id: 8, name: "The Manipulator", team: "evil", type: "accomplice", short: "Silence one player's vote next day.", nightOrder: 2, hasNightAction: true, oneTimeOnly: false },
      { id: 9, name: "The Traitor", team: "evil", type: "accomplice", short: "Force revote if marked player is eliminated.", nightOrder: 2, hasNightAction: true, oneTimeOnly: false },
      { id: 10, name: "The Informant", team: "evil", type: "accomplice", short: "Reveal exact role of a player to evil team.", nightOrder: 2, hasNightAction: true, oneTimeOnly: false },
      { id: 11, name: "The Sage", team: "good", type: "elder", short: "Check two players; learn if at least one is evil.", nightOrder: 3, hasNightAction: true, oneTimeOnly: false },
      { id: 12, name: "The Oracle", team: "good", type: "elder", short: "Check one player; good or evil.", nightOrder: 3, hasNightAction: true, oneTimeOnly: false },
      { id: 13, name: "The Sensitive", team: "good", type: "elder", short: "Learn if a player has a night action.", nightOrder: 3, hasNightAction: true, oneTimeOnly: false },
      { id: 14, name: "The Dreamer", team: "good", type: "elder", short: "Learn how many evil sit beside them.", nightOrder: 3, hasNightAction: true, oneTimeOnly: false },
      { id: 15, name: "The Witness", team: "good", type: "elder", short: "Narrator gives a clue about the night.", nightOrder: 3, hasNightAction: true, oneTimeOnly: false },
      { id: 16, name: "The Champion", team: "good", type: "hero", short: "Protects nightly. First success reveals a villain but ends power.", nightOrder: 4, hasNightAction: true, oneTimeOnly: false, firstNightSetup: true },
      { id: 17, name: "The Healer", team: "good", type: "hero", short: "Save one player, can't repeat.", nightOrder: 4, hasNightAction: true, oneTimeOnly: false },
      { id: 18, name: "The Guardian", team: "good", type: "hero", short: "Sacrifice self to save another.", nightOrder: 4, hasNightAction: true, oneTimeOnly: false },
      { id: 19, name: "The Survivor", team: "good", type: "hero", short: "Survives first night attack until after next vote.", nightOrder: 4, hasNightAction: false, oneTimeOnly: false, passive: true },
      { id: 20, name: "The Defender", team: "good", type: "hero", short: "Traps a player; if they die, a villain dies too.", nightOrder: 4, hasNightAction: true, oneTimeOnly: false },
      { id: 21, name: "The Loyal Companion", team: "good", type: "sidekick", short: "Knows Champion; can boost their vote (dice).", nightOrder: 5, hasNightAction: false, oneTimeOnly: false, firstNightSetup: true },
      { id: 22, name: "The Voice", team: "good", type: "sidekick", short: "Double elimination after vote (dice).", nightOrder: 5, hasNightAction: false, oneTimeOnly: false },
      { id: 23, name: "The Fool", team: "good", type: "sidekick", short: "Wild accusation with dramatic blowback (dice).", nightOrder: 5, hasNightAction: false, oneTimeOnly: false },
      { id: 24, name: "The Trickster", team: "good", type: "sidekick", short: "Creates a false claim (dice).", nightOrder: 5, hasNightAction: false, oneTimeOnly: false },
      { id: 25, name: "The Imitator", team: "good", type: "sidekick", short: "Copies another day power (dice).", nightOrder: 5, hasNightAction: false, oneTimeOnly: false },
      { id: 26, name: "The Marked", team: "good", type: "damsel", short: "If voted out, demand a dramatic revote.", nightOrder: 0, hasNightAction: false, oneTimeOnly: false },
      { id: 27, name: "The Innocent", team: "good", type: "damsel", short: "Can reveal once to confirm they are good.", nightOrder: 0, hasNightAction: false, oneTimeOnly: false },
      { id: 28, name: "Twin A", team: "good", type: "damsel", short: "Linked to Twin B. If one dies, both do.", nightOrder: 0, hasNightAction: false, oneTimeOnly: false, firstNightSetup: true, linkedTo: 29 },
      { id: 29, name: "Twin B", team: "good", type: "damsel", short: "Linked to Twin A. If one dies, both do.", nightOrder: 0, hasNightAction: false, oneTimeOnly: false, firstNightSetup: true, linkedTo: 28 },
      { id: 30, name: "The Cursed", team: "good", type: "damsel", short: "If eliminated, neighbors on both sides also fall.", nightOrder: 0, hasNightAction: false, oneTimeOnly: false, firstNightSetup: true }
    ];

    const TYPE_DETAILS = {
      villain: { label: "Villain-Type", min: 2, max: 5, description: "All wake together in Step 1 to pick the night's target.", accent: "var(--accent-evil)" },
      accomplice: { label: "Accomplice-Type", min: 1, max: 5, description: "Thumbs-up helpers with one-off tricks to boost the villains.", accent: "#fb7185" },
      elder: { label: "Elder-Type", min: 1, max: 5, description: "Information gatherers who never directly save or kill.", accent: "var(--accent-good)" },
      hero: { label: "Hero-Type", min: 1, max: 5, description: "Defensive powers keeping the village alive.", accent: "#34d399" },
      sidekick: { label: "Sidekick-Type", min: 1, max: 5, description: "Daytime drama with risky dice rolls.", accent: "#bef264" },
      damsel: { label: "Damsel-Type", min: 1, max: 5, description: "Melodramatic twists when the crowd turns on them.", accent: "#a855f7" }
    };

    const THEMES = {
      village: {
        name: "Classic Village",
        description: "Foggy streets, flickering lanterns, and suspicious glances.",
        visual: {
          background: "radial-gradient(circle at top, rgba(139, 92, 46, 0.15), transparent 60%), linear-gradient(180deg, #1a1410 0%, #2d1b0e 100%)",
          accentColor: "#d97706",
          textGlow: "0 0 10px rgba(217, 119, 6, 0.3)",
          cardBackground: "rgba(41, 37, 36, 0.6)",
          animation: "flicker 3s ease-in-out infinite"
        },
        audio: {
          night: null, // Placeholder for future audio URL
          day: null
        },
        script: {
          nightIntro: "Night descends over the village. Actors, close your eyes and fall into character...",
          dayIntro: "The sun rises on the village square. Open your eyes and gasp dramatically!",
          noDeaths: "Against all odds, everyone survived the night. Whisper relief... for now.",
          deaths: victim => `Tragedy strikes! Last night we lost ${victim}. Prepare a spectacular exit.`,
          vote: "The village must choose. On three, point boldly to your suspect!",
          deathScene: "Give us your most melodramatic village collapse!",
          evilCall: "Ask for evil smirks and villainous grins."
        }
      },
      mansion: {
        name: "Millionaire's Mansion",
        description: "Champagne towers, hidden wills, and backstabbing at the gala.",
        visual: {
          background: "radial-gradient(circle at center, rgba(234, 179, 8, 0.12), transparent 70%), linear-gradient(180deg, #1c1917 0%, #292524 100%)",
          accentColor: "#eab308",
          textGlow: "0 0 12px rgba(234, 179, 8, 0.4)",
          cardBackground: "rgba(68, 64, 60, 0.5)",
          animation: "shimmer 4s ease-in-out infinite"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "The lights dim in the grand estate. Guests, close your eyes as the mystery deepens...",
          dayIntro: "Morning breaks over the mansion. Who's missing from breakfast?",
          noDeaths: "Everyone made it through the night... but the tension remains.",
          deaths: victim => `${victim} won't be inheriting anything now. Exit with grace!`,
          vote: "The family gathers. At three, point to the one you suspect!",
          deathScene: "A dramatic fall worthy of a soap opera!",
          evilCall: "Ask for scheming whispers and calculating glances."
        }
      },
      haunted: {
        name: "Haunted House",
        description: "Thunder cracks, portraits watch, and secrets lurk in every corridor.",
        visual: {
          background: "radial-gradient(ellipse at bottom, rgba(124, 58, 237, 0.2), transparent 60%), linear-gradient(180deg, #0a0118 0%, #1e0b37 100%)",
          accentColor: "#a855f7",
          textGlow: "0 0 15px rgba(168, 85, 247, 0.5)",
          cardBackground: "rgba(30, 11, 55, 0.7)",
          animation: "pulse 2s ease-in-out infinite"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "Storm clouds swallow the manor. Spirits, close your eyes...",
          dayIntro: "Dawn forces its way in. Awake! Whose scream echoes today?",
          noDeaths: "The mansion groaned but spared you. Celebrate in whispers.",
          deaths: victim => `${victim} vanished into the walls overnight. Only echoes remain...`,
          vote: "Gather in the ballroom. At three, accuse with operatic flair!",
          deathScene: "Vanish with a ghostly wail!",
          evilCall: "Ask for haunting stares and spectral grins."
        }
      },
      castle: {
        name: "Castle Tower",
        description: "Medieval intrigue, throne room conspiracies, and royal betrayals.",
        visual: {
          background: "radial-gradient(circle at top, rgba(71, 85, 105, 0.2), transparent 65%), linear-gradient(180deg, #1e293b 0%, #334155 100%)",
          accentColor: "#64748b",
          textGlow: "0 0 8px rgba(100, 116, 139, 0.3)",
          cardBackground: "rgba(51, 65, 85, 0.6)",
          animation: "none"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "The castle sleeps under moonlight. Knights and nobles, close your eyes...",
          dayIntro: "The court assembles at dawn. Who has fallen?",
          noDeaths: "The kingdom stands... for now.",
          deaths: victim => `${victim} has been vanquished! Exit with medieval flair.`,
          vote: "The court must decide. On three, point to the traitor!",
          deathScene: "A noble collapse, worthy of a knight!",
          evilCall: "Ask for treacherous sneers and courtly plots."
        }
      },
      theatre: {
        name: "Magic Show / Theatre",
        description: "Spotlights, trapdoors, and illusions gone deadly.",
        visual: {
          background: "radial-gradient(circle at center, rgba(239, 68, 68, 0.15), rgba(234, 179, 8, 0.1), transparent 70%), linear-gradient(180deg, #18181b 0%, #27272a 100%)",
          accentColor: "#f59e0b",
          textGlow: "0 0 20px rgba(245, 158, 11, 0.6)",
          cardBackground: "rgba(39, 39, 42, 0.7)",
          animation: "spotlight 5s ease-in-out infinite"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "The curtain falls on another act. Performers, close your eyes...",
          dayIntro: "The spotlight rises! Who missed their cue?",
          noDeaths: "All performers survived the night. The show must go on!",
          deaths: victim => `${victim} vanished in the final trick. Take your final bow!`,
          vote: "Center stage, everyone. At three, point to your suspect!",
          deathScene: "Exit through the trapdoor with dramatic flair!",
          evilCall: "Ask for villainous stage presence and dramatic glares."
        }
      },
      space: {
        name: "Space Station",
        description: "Red alerts, mysterious airlocks, and dramatic zero-g reveals.",
        visual: {
          background: "radial-gradient(circle at center, rgba(6, 182, 212, 0.2), rgba(34, 211, 238, 0.1), transparent 75%), linear-gradient(180deg, #020617 0%, #0c4a6e 100%)",
          accentColor: "#22d3ee",
          textGlow: "0 0 18px rgba(34, 211, 238, 0.7)",
          cardBackground: "rgba(12, 74, 110, 0.5)",
          animation: "tech-glow 3s ease-in-out infinite"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "Artificial night engages. Crew, helmets down and eyes closed...",
          dayIntro: "Lights to full! Bridge crew, report your status with gusto!",
          noDeaths: "Sensors show no casualties. Someone rerouted the danger...",
          deaths: victim => `${victim} was jettisoned into the void. Cue the space dirge...`,
          vote: "Assemble in the hangar. At three, point to the saboteur!",
          deathScene: "Float away into the cosmic void!",
          evilCall: "Ask for calculating computer-like stares."
        }
      },
      western: {
        name: "Wild West Town",
        description: "Dusty saloons, high noon showdowns, and outlaws in the shadows.",
        visual: {
          background: "radial-gradient(circle at top, rgba(161, 98, 7, 0.2), transparent 60%), linear-gradient(180deg, #292524 0%, #44403c 100%)",
          accentColor: "#d97706",
          textGlow: "0 0 10px rgba(217, 119, 6, 0.4)",
          cardBackground: "rgba(68, 64, 60, 0.6)",
          animation: "dust 6s ease-in-out infinite"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "Night falls on the frontier. Cowboys and outlaws, close your eyes...",
          dayIntro: "The sun rises over the dusty town. Who didn't make it to dawn?",
          noDeaths: "Everyone's still standing at the saloon.",
          deaths: victim => `${victim} bit the dust last night. Give us a dusty collapse!`,
          vote: "High noon has arrived. At three, point to the outlaw!",
          deathScene: "A dusty Wild West collapse!",
          evilCall: "Ask for outlaw sneers and bandit grins."
        }
      },
      pirate: {
        name: "Pirate Harbour",
        description: "Treasure maps, plank-walking, and mutiny on the high seas.",
        visual: {
          background: "radial-gradient(circle at bottom, rgba(14, 116, 144, 0.25), transparent 65%), linear-gradient(180deg, #0c4a6e 0%, #164e63 100%)",
          accentColor: "#06b6d4",
          textGlow: "0 0 12px rgba(6, 182, 212, 0.5)",
          cardBackground: "rgba(22, 78, 99, 0.6)",
          animation: "wave 4s ease-in-out infinite"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "The ship rocks in darkness. Pirates, close your eyes and plot...",
          dayIntro: "Dawn breaks over the harbor. Who walked the plank?",
          noDeaths: "All hands on deck! Everyone survived the night.",
          deaths: victim => `${victim} sleeps with the fishes. Man overboard!`,
          vote: "All crew to the deck. At three, point to the mutineer!",
          deathScene: "A dramatic pirate's 'man overboard!'",
          evilCall: "Ask for pirate snarls and mutinous grins."
        }
      },
      hospital: {
        name: "Soap Opera Hospital",
        description: "Medical drama, secret diagnoses, and relationship scandals.",
        visual: {
          background: "radial-gradient(circle at top, rgba(56, 189, 248, 0.15), rgba(255, 255, 255, 0.05), transparent 70%), linear-gradient(180deg, #f8fafc 0%, #e2e8f0 100%)",
          accentColor: "#0ea5e9",
          textGlow: "0 0 10px rgba(14, 165, 233, 0.3)",
          cardBackground: "rgba(226, 232, 240, 0.8)",
          animation: "heartbeat 2s ease-in-out infinite"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "The hospital quiets for the night shift. Medical staff, close your eyes...",
          dayIntro: "Morning rounds begin! Who's been discharged... permanently?",
          noDeaths: "All patients stable. For now.",
          deaths: victim => `${victim} coded last night. Give us soap opera dramatics!`,
          vote: "Emergency meeting in the conference room. At three, accuse!",
          deathScene: "A melodramatic hospital flatline moment!",
          evilCall: "Ask for scheming glances and hospital intrigue."
        }
      }
    };

    const PHASES = {
      night: "Night Phase",
      day: "Day Phase",
      setup: "Setup"
    };

    const INITIAL_STATE = {
      phase: "setup",
      night: 1,
      stepIndex: 0,
      selectedRoles: [],
      players: [],
      theme: "village",
      nameList: "",
      notes: "",
      mode: "dark",
      audio: {
        enabled: false,
        volume: 0.5,
        currentTrack: null,
        phase: "night"
      },
      timer: {
        remaining: 180,
        running: false,
        handle: null
      },
      nightActions: {
        villainTarget: null,
        assassinTarget: null,
        stalkerActive: false,
        championProtect: null,
        healerProtect: null,
        guardianProtect: null,
        defenderTrap: null,
        rightHandBlock: null,
        healerLastProtected: null
      },
      resolutionResult: null,
      specialTrackers: {
        championPowerActive: true,
        championIdentifiedVillain: null,
        assassinUsed: false,
        rightHandUsed: false
      }
    };

    let state = loadState();

    const setupSection = document.getElementById("setup-section");
    const gameSection = document.getElementById("game-section");
    const playerCountInput = document.getElementById("player-count");
    const playerCountDisplay = document.getElementById("player-count-display");
    const suggestedGoodDisplay = document.getElementById("suggested-good");
    const suggestedEvilDisplay = document.getElementById("suggested-evil");
    const roleGroupsContainer = document.getElementById("role-groups");
    const balanceBadge = document.getElementById("role-balance");
    const balanceWarning = document.getElementById("balance-warning");
    const startButton = document.getElementById("start-game");
    const themeSelect = document.getElementById("theme-select");
    const themeDescription = document.getElementById("theme-description");
    const namesInput = document.getElementById("player-names");

    const scriptStepsContainer = document.getElementById("script-steps");
    const scriptTitle = document.getElementById("script-title");
    const phaseLabel = document.getElementById("phase-label");
    const prevStepButton = document.getElementById("prev-step");
    const nextStepButton = document.getElementById("next-step");

    const timerDisplay = document.getElementById("timer-display");
    const timerButtons = document.querySelectorAll(".timer-controls button[data-timer]");
    const startTimerBtn = document.getElementById("start-timer");
    const pauseTimerBtn = document.getElementById("pause-timer");
    const resetTimerBtn = document.getElementById("reset-timer");
    const timerPhase = document.getElementById("timer-phase");

    const nightNumber = document.getElementById("night-number");
    const aliveCount = document.getElementById("alive-count");
    const goodCount = document.getElementById("good-count");
    const evilCount = document.getElementById("evil-count");

    const playerList = document.getElementById("player-list");
    const playerCardTemplate = document.getElementById("player-card-template");
    const notesArea = document.getElementById("narrator-notes");

    const toggleModeButton = document.getElementById("toggle-mode");
    const resetGameButton = document.getElementById("reset-game");
    const downloadNotesLink = document.getElementById("download-notes");

    const audioControls = document.getElementById("audio-controls");
    const toggleAudioButton = document.getElementById("toggle-audio");
    const volumeSlider = document.getElementById("volume-slider");
    const audioIndicator = document.getElementById("audio-indicator");
    const audioPhase = document.getElementById("audio-phase");

    // Audio system
    let audioContext = null;
    let currentAudio = null;

    function initAudioSystem() {
      // Audio context will be created on first user interaction due to browser policies
      toggleAudioButton.addEventListener("click", toggleAudio);
      volumeSlider.addEventListener("input", (e) => {
        state.audio.volume = e.target.value / 100;
        if (currentAudio) {
          currentAudio.volume = state.audio.volume;
        }
        persistState();
      });
    }

    function toggleAudio() {
      state.audio.enabled = !state.audio.enabled;
      toggleAudioButton.textContent = state.audio.enabled ? "ðŸ”Š" : "ðŸ”‡";
      audioIndicator.classList.toggle("playing", state.audio.enabled);
      
      if (state.audio.enabled) {
        playThemeAudio();
      } else {
        stopAudio();
      }
      persistState();
    }

    function playThemeAudio() {
      // Stop any currently playing audio
      stopAudio();

      const theme = THEMES[state.theme];
      const audioUrl = state.phase === "night" ? theme.audio.night : theme.audio.day;

      // If no audio URL is set, just update indicator
      if (!audioUrl) {
        return;
      }

      try {
        currentAudio = new Audio(audioUrl);
        currentAudio.loop = true;
        currentAudio.volume = state.audio.volume;
        currentAudio.play().catch(err => {
          console.warn("Audio playback failed:", err);
          state.audio.enabled = false;
          toggleAudioButton.textContent = "ðŸ”‡";
        });
      } catch (err) {
        console.warn("Audio initialization failed:", err);
      }
    }

    function stopAudio() {
      if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio = null;
      }
    }

    function updateAudioPhase(phase) {
      state.audio.phase = phase;
      audioPhase.textContent = phase === "night" ? "Night" : "Day";
      
      if (state.audio.enabled) {
        playThemeAudio();
      }
    }

    function applyThemeVisuals() {
      const theme = THEMES[state.theme];
      const visual = theme.visual;
      
      // Apply theme-specific background
      document.body.style.background = visual.background;
      
      // Apply accent color to CSS variable
      document.documentElement.style.setProperty("--theme-accent", visual.accentColor);
      
      // Apply text glow to headers and important elements
      const headers = document.querySelectorAll("h1, h2");
      headers.forEach(header => {
        header.style.textShadow = visual.textGlow;
      });

      // Apply card backgrounds
      const sections = document.querySelectorAll("section");
      sections.forEach(section => {
        section.style.background = visual.cardBackground;
        section.style.backdropFilter = "blur(18px)";
      });

      // Apply animation to body if specified
      if (visual.animation && visual.animation !== "none") {
        document.body.style.animation = visual.animation;
      } else {
        document.body.style.animation = "none";
      }
    }

    function applyMode(mode) {
      document.body.classList.toggle("light", mode === "light");
      toggleModeButton.setAttribute("aria-pressed", String(mode === "light"));
      
      // Reapply theme visuals after mode change
      applyThemeVisuals();
    }

    function loadState() {
      const stored = localStorage.getItem("melodrama-state-v1");
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          return { ...INITIAL_STATE, ...parsed, timer: { ...INITIAL_STATE.timer, ...parsed.timer, handle: null } };
        } catch (error) {
          console.warn("Failed to parse stored state", error);
        }
      }
      return structuredClone(INITIAL_STATE);
    }

    function persistState() {
      const toStore = { ...state, timer: { ...state.timer, handle: null } };
      localStorage.setItem("melodrama-state-v1", JSON.stringify(toStore));
    }

    function resetState() {
      state = structuredClone(INITIAL_STATE);
      persistState();
      if (downloadNotesLink.dataset.url) {
        URL.revokeObjectURL(downloadNotesLink.dataset.url);
        delete downloadNotesLink.dataset.url;
      }
      applyMode(state.mode);
      renderAll();
      setupSection.classList.remove("hidden");
      gameSection.classList.add("hidden");
    }

    function renderThemeSelect() {
      themeSelect.innerHTML = "";
      Object.entries(THEMES).forEach(([key, info]) => {
        const option = document.createElement("option");
        option.value = key;
        option.textContent = info.name;
        themeSelect.append(option);
      });
      themeSelect.value = state.theme;
      themeDescription.textContent = THEMES[state.theme].description;
    }

    function updatePlayerCountDisplays() {
      const count = Number(playerCountInput.value);
      playerCountDisplay.textContent = count;
      const evil = Math.max(3, Math.round(count * 0.33));
      const good = count - evil;
      suggestedGoodDisplay.textContent = good;
      suggestedEvilDisplay.textContent = evil;
    }

    function renderRoleGroups() {
      const grouped = CHARACTERS.reduce((acc, char) => {
        acc[char.type] ??= [];
        acc[char.type].push(char);
        return acc;
      }, {});

      roleGroupsContainer.innerHTML = "";
      Object.entries(TYPE_DETAILS).forEach(([type, meta]) => {
        const wrapper = document.createElement("div");
        wrapper.className = "role-group";
        wrapper.style.setProperty("--accent", meta.accent);

        const header = document.createElement("div");
        header.className = "role-group-header";
        const title = document.createElement("div");
        title.innerHTML = `<strong style="color:${meta.accent}">${meta.label}</strong><br><small>${meta.description}</small>`;
        const rangeInfo = document.createElement("small");
        rangeInfo.textContent = `Select ${meta.min} â€“ ${meta.max}`;
        header.append(title, rangeInfo);

        const cards = document.createElement("div");
        cards.className = "role-cards";
        (grouped[type] || []).forEach(char => {
          const card = document.createElement("article");
          card.className = "role-card";
          card.dataset.id = String(char.id);
          card.dataset.team = char.team;
          card.dataset.type = char.type;
          card.innerHTML = `
            <span class="type">${meta.label}</span>
            <h3>${char.name}</h3>
            <span class="team-label">
              <span class="badge ${char.team}">${char.team.toUpperCase()}</span>
              ${char.limited ? `â€¢ ${char.limited} use` : ""}
            </span>
            <p>${char.short}</p>
          `;
          card.addEventListener("click", () => toggleRoleSelection(char.id));
          cards.append(card);
        });

        wrapper.append(header, cards);
        roleGroupsContainer.append(wrapper);
      });
    }

    function toggleRoleSelection(id) {
      const selected = new Set(state.selectedRoles);
      if (selected.has(id)) {
        selected.delete(id);
      } else {
        selected.add(id);
      }
      state.selectedRoles = Array.from(selected);
      updateRoleSelectionUI();
      persistState();
    }

    function updateRoleSelectionUI() {
      const cards = roleGroupsContainer.querySelectorAll(".role-card");
      cards.forEach(card => {
        card.dataset.selected = state.selectedRoles.includes(Number(card.dataset.id)) ? "true" : "false";
      });
      const totals = state.selectedRoles.reduce((acc, id) => {
        const character = CHARACTERS.find(c => c.id === id);
        if (!character) return acc;
        acc.total += 1;
        acc[character.team] += 1;
        acc.byType[character.type] ??= 0;
        acc.byType[character.type] += 1;
        return acc;
      }, { total: 0, good: 0, evil: 0, byType: {} });

      balanceBadge.textContent = `Good: ${totals.good} â€¢ Evil: ${totals.evil} â€¢ Selected: ${totals.total}`;

      const target = Number(playerCountInput.value);
      const typeIssues = Object.entries(TYPE_DETAILS).filter(([type, info]) => {
        const count = totals.byType[type] || 0;
        return count < info.min || count > info.max;
      });
      const ready = totals.total === target && typeIssues.length === 0;
      startButton.disabled = !ready;
      balanceWarning.textContent = ready ? "Ready! Dramatic chaos awaits." : "Adjust counts to match the player total and type ranges.";
    }

    function preparePlayers() {
      const selected = state.selectedRoles.map(id => CHARACTERS.find(c => c.id === id));
      const names = state.nameList.split(/\n+/).map(n => n.trim()).filter(Boolean);
      return selected.map((char, index) => ({
        id: index,
        charId: char.id,
        name: names[index] || `Player ${index + 1}`,
        roleName: char.name,
        team: char.team,
        type: char.type,
        ability: char.short,
        eliminated: false,
        protected: false,
        notes: "",
        abilityUsesRemaining: char.limited || -1, // -1 means unlimited
        blocked: false,
        linkedTo: null, // for Twins, Champion-Companion
        hasNightAction: char.hasNightAction || false,
        firstNightSetup: char.firstNightSetup || false,
        passive: char.passive || false
      }));
    }

    function buildScriptSteps() {
      const theme = THEMES[state.theme];
      const hasType = type => state.players.some(player => player.type === type && !player.eliminated);
      const hasRole = id => state.players.some(player => player.charId === id && !player.eliminated);
      const hasActiveRole = id => {
        const player = state.players.find(p => p.charId === id && !p.eliminated);
        return player && (player.abilityUsesRemaining !== 0);
      };

      const nightSteps = [];
      
      // Night 1 Opening
      if (state.night === 1) {
        nightSteps.push({
          title: "Night 1 Opening",
          phase: "night",
          blocks: [
            { type: "say", text: theme.script.nightIntro },
            { type: "narrator", text: "Remind students: silent acting only. Encourage over-the-top reactions when woken. " + theme.script.evilCall }
          ]
        });
        
        // First Night Setup Actions - only on Night 1
        if (hasType("accomplice")) {
          nightSteps.push({
            title: "Night 1: Accomplices Meet Villains",
            phase: "night",
            blocks: [
              { type: "say", text: "Accomplices, lift your heads and find your villain allies." },
              { type: "narrator", text: "Have villains give a subtle nod so accomplices know them. " + theme.script.evilCall }
            ]
          });
        }
        
        // Champion sees Cursed (only if both are in game)
        if (hasRole(16) && hasRole(30)) {
          const cursedPlayer = state.players.find(p => p.charId === 30);
          nightSteps.push({
            title: "Night 1: Champion Sees the Cursed",
            phase: "night",
            blocks: [
              { type: "say", text: "Champion, open your eyes and look for the Cursed." },
              { type: "narrator", text: `Point silently to ${cursedPlayer ? cursedPlayer.name : "the Cursed player"}'s seat.` }
            ]
          });
        }
        
        // Twins Meet (only if both twins are in game)
        if (hasRole(28) && hasRole(29)) {
          nightSteps.push({
            title: "Night 1: Twins Meet",
            phase: "night",
            blocks: [
              { type: "say", text: "Twin A and Twin B, open your eyes and find each other." },
              { type: "narrator", text: "Remind them: if one is eliminated, the other falls immediately. Note their identities for later." }
            ]
          });
        }
        
        // Loyal Companion meets Champion (only if both are in game)
        if (hasRole(21) && hasRole(16)) {
          nightSteps.push({
            title: "Night 1: Loyal Companion",
            phase: "night",
            blocks: [
              { type: "say", text: "Loyal Companion, open your eyes. Champion, give them a nod." },
              { type: "narrator", text: "Confirm they've spotted each other before sending them back to sleep." }
            ]
          });
        }
      } else {
        // Subsequent nights opening
        nightSteps.push({
          title: `Night ${state.night} Begins`,
          phase: "night",
          blocks: [
            { type: "say", text: theme.script.nightIntro },
            { type: "reminder", text: "Encourage players to hunch, clutch pearls, or otherwise act the part." }
          ]
        });
      }

      // Step 1: Villain-Type (all wake together) - Skip if no villains alive
      if (hasType("villain")) {
        const villains = state.players.filter(p => p.type === "villain" && !p.eliminated).map(p => `${p.name} (${p.roleName})`).join(", ");
        nightSteps.push({
          title: "Step 1: Villain-Type",
          phase: "night",
          blocks: [
            { type: "say", text: "Villain team, open your eyes and choose your victim." },
            { type: "narrator", text: "Watch their silent debate. Confirm their choice before moving on. " + theme.script.evilCall },
            { type: "info", text: `Villains alive: ${villains || "None"}` }
          ]
        });
      }

      // Step 2: Accomplice-Type (check for ability uses) - Skip if none have abilities remaining
      const accomplicesWithAbilities = state.players.filter(p => 
        p.type === "accomplice" && !p.eliminated && p.abilityUsesRemaining !== 0
      );
      if (accomplicesWithAbilities.length > 0) {
        const accompliceList = accomplicesWithAbilities.map(p => `${p.name} (${p.roleName})`).join(", ");
        nightSteps.push({
          title: "Step 2: Accomplice-Type",
          phase: "night",
          blocks: [
            { type: "say", text: "Accomplices with abilities remaining, give a subtle thumbs-up." },
            { type: "narrator", text: "If a thumb is raised, quietly confirm which ability they're using tonight." },
            { type: "info", text: `Accomplices with abilities: ${accompliceList}` }
          ]
        });
      }

      // Step 3: Elder-Type (each wakes individually) - Skip if none alive
      const elders = state.players.filter(p => p.type === "elder" && !p.eliminated && !p.blocked);
      if (elders.length > 0) {
        const elderList = elders.map(p => `${p.name} (${p.roleName})`).join(", ");
        nightSteps.push({
          title: "Step 3: Elder-Type",
          phase: "night",
          blocks: [
            { type: "say", text: "Elders, one at a time, open your eyes when your title is called." },
            { type: "narrator", text: "Whisper their options and hold up fingers for results. Check each elder individually." },
            { type: "info", text: `Elders alive: ${elderList}` }
          ]
        });
      }

      // Step 4: Hero-Type (each wakes individually) - Skip if none alive  
      const heroes = state.players.filter(p => p.type === "hero" && !p.eliminated && !p.blocked && p.hasNightAction);
      if (heroes.length > 0) {
        const heroList = heroes.map(p => `${p.name} (${p.roleName})`).join(", ");
        nightSteps.push({
          title: "Step 4: Hero-Type",
          phase: "night",
          blocks: [
            { type: "say", text: "Heroes, when called, lift your head and select your target." },
            { type: "reminder", text: "Track who was protected last night so they don't repeat illegal saves." },
            { type: "info", text: `Heroes alive: ${heroList}` }
          ]
        });
      }

      // Step 5: Sidekick-Type night check (for those that signal at night) - Skip if none alive
      if (hasType("sidekick")) {
        nightSteps.push({
          title: "Step 5: Sidekick-Type",
          phase: "night",
          blocks: [
            { type: "say", text: "Sidekicks ready for drama, give a single silent thumbs-up." },
            { type: "narrator", text: "Note who will trigger a dice roll during the day phase." }
          ]
        });
      }

      // Night Resolution - Private calculation step
      nightSteps.push({
        title: "Night Resolution (Private)",
        phase: "night",
        blocks: [
          { type: "narrator", text: "PRIVATE STEP: Work through protections, blocks, and eliminations in order." },
          { type: "narrator", text: "1. Apply blocks (Right Hand blocks a player's ability)" },
          { type: "narrator", text: "2. Process protections (Champion, Healer, Guardian, Defender)" },
          { type: "narrator", text: "3. Determine eliminations (Villain target, Assassin second target, Stalker backup)" },
          { type: "narrator", text: "4. Check for Survivor passive ability" },
          { type: "narrator", text: "5. Review your notes before announcing publicly" },
          { type: "action", text: "Use the Action Tracker panel below to record night actions, then click 'Calculate Resolution' to see the automated summary." }
        ],
        showActionTracker: true,
        showResolutionButton: true
      });

      // Day Phase Steps
      const daySteps = [
        {
          title: `Day ${state.night} Dawn`,
          phase: "day",
          blocks: [
            { type: "say", text: theme.script.dayIntro },
            { type: "reminder", text: theme.script.deathScene }
          ]
        },
        {
          title: "Announcements & Death Scenes",
          phase: "day",
          blocks: [
            { type: "say", text: "Narrate last night's events with flair. Announce who (if anyone) was eliminated." },
            { type: "narrator", text: "Let each eliminated player perform their melodramatic death scene (3-5 seconds). " + theme.script.deathScene },
            { type: "reminder", text: "Check for linked deaths: Twins eliminate each other, Cursed eliminates 2 neighbors each side." }
          ]
        },
        {
          title: "Check Win Condition",
          phase: "day",
          blocks: [
            { type: "narrator", text: "COUNT REMAINING: If evil â‰¥ good, evil wins. If no evil remain, good wins. Otherwise, continue." }
          ]
        },
        {
          title: "Discussion",
          phase: "day",
          blocks: [
            { type: "say", text: "The floor is yours! Accuse with melodrama. You have three minutes." },
            { type: "action", text: "Start the timer below when the debate begins." },
            { type: "reminder", text: "The Innocent can reveal to confirm goodness. The Marked can force a revote if eliminated." }
          ]
        },
        {
          title: "Voting",
          phase: "day",
          blocks: [
            { type: "say", text: theme.script.vote }
          ]
        }
      ];
      
      // Add voting reminders dynamically based on active roles
      const votingReminders = [];
      if (hasRole(4)) { // Corrupted Authority
        const corruptedPlayer = state.players.find(p => p.charId === 4 && !p.eliminated);
        if (corruptedPlayer) {
          votingReminders.push(`Repeat ${corruptedPlayer.name}'s (Corrupted Authority) vote twice.`);
        }
      }
      if (hasRole(8)) { // Manipulator
        votingReminders.push("Check if any player is silenced (Manipulator ability).");
      }
      if (votingReminders.length > 0) {
        daySteps[4].blocks.push({ type: "reminder", text: votingReminders.join(" ") });
      }
      
      daySteps.push({
        title: "Vote Resolution",
        phase: "day",
        blocks: [
          { type: "narrator", text: "Count votes. Record who is eliminated." },
          { type: "reminder", text: "The Marked can demand a revote if eliminated. Check for this before proceeding." },
          { type: "reminder", text: theme.script.deathScene }
        ]
      });
      
      daySteps.push({
        title: "Apply Vote Aftermath",
        phase: "day",
        blocks: [
          { type: "narrator", text: "Check for linked eliminations: Twins, Cursed neighbors." },
          { type: "narrator", text: "Process any on-elimination triggers." }
        ]
      });
      
      daySteps.push({
        title: "Final Win Check",
        phase: "day",
        blocks: [
          { type: "narrator", text: "COUNT AGAIN: If evil â‰¥ good, evil wins. If no evil remain, good wins. Otherwise, proceed to next night." }
        ]
      });

      return [...nightSteps, ...daySteps];
    }

    // Resolution Calculator Functions
    function calculateNightResolution() {
      const actions = state.nightActions;
      const result = {
        actions: [],
        protections: [],
        preDoctorEliminations: [],
        finalEliminations: [],
        specialEvents: [],
        stateChanges: {}
      };

      // Step 1: Record all actions
      if (actions.villainTarget !== null) {
        result.actions.push({
          type: 'target',
          actor: 'Villain Team',
          target: actions.villainTarget
        });
      }

      if (actions.assassinTarget !== null) {
        result.actions.push({
          type: 'target',
          actor: 'Assassin',
          target: actions.assassinTarget
        });
      }

      if (actions.rightHandBlock !== null) {
        result.actions.push({
          type: 'block',
          actor: 'Right Hand',
          target: actions.rightHandBlock
        });
      }

      // Step 2: Apply blocks (prevent blocked players' actions)
      const blockedPlayer = actions.rightHandBlock;
      let championBlocked = false;
      let healerBlocked = false;
      let guardianBlocked = false;
      let defenderBlocked = false;

      if (blockedPlayer !== null) {
        const blocked = state.players.find(p => p.id === blockedPlayer);
        if (blocked) {
          if (blocked.charId === 16) championBlocked = true; // Champion
          if (blocked.charId === 17) healerBlocked = true; // Healer
          if (blocked.charId === 18) guardianBlocked = true; // Guardian
          if (blocked.charId === 20) defenderBlocked = true; // Defender
        }
      }

      // Step 3: Collect targets
      const targets = [];
      if (actions.villainTarget !== null) {
        targets.push({ playerId: actions.villainTarget, source: 'villain' });
      }
      if (actions.assassinTarget !== null) {
        targets.push({ playerId: actions.assassinTarget, source: 'assassin' });
      }

      // Step 4: Apply protections
      const protectedPlayers = new Set();

      // Champion protection
      if (!championBlocked && actions.championProtect !== null && state.specialTrackers.championPowerActive) {
        protectedPlayers.add(actions.championProtect);
        result.protections.push({
          player: actions.championProtect,
          protectedBy: 'Champion',
          triggered: false
        });
      }

      // Healer protection (can't repeat last target)
      if (!healerBlocked && actions.healerProtect !== null && actions.healerProtect !== actions.healerLastProtected) {
        protectedPlayers.add(actions.healerProtect);
        result.protections.push({
          player: actions.healerProtect,
          protectedBy: 'Healer',
          triggered: false
        });
      }

      // Guardian protection
      if (!guardianBlocked && actions.guardianProtect !== null) {
        protectedPlayers.add(actions.guardianProtect);
        result.protections.push({
          player: actions.guardianProtect,
          protectedBy: 'Guardian',
          triggered: false
        });
      }

      // Step 5: Check which protections were triggered
      targets.forEach(target => {
        if (protectedPlayers.has(target.playerId)) {
          const protection = result.protections.find(p => p.player === target.playerId);
          if (protection) {
            protection.triggered = true;

            // Special Champion logic
            if (protection.protectedBy === 'Champion' && state.specialTrackers.championPowerActive) {
              // Both survive, Champion identifies a villain
              const villains = state.players.filter(p => 
                (p.type === 'villain' || p.type === 'accomplice') && 
                p.team === 'evil' && 
                !p.eliminated
              );
              if (villains.length > 0) {
                const randomVillain = villains[Math.floor(Math.random() * villains.length)];
                result.specialEvents.push({
                  type: 'championIdentified',
                  villain: randomVillain.id,
                  villainName: `${randomVillain.name} (${randomVillain.roleName})`
                });
                result.stateChanges['specialTrackers.championIdentifiedVillain'] = randomVillain.id;
              }
              result.specialEvents.push({
                type: 'championPowerLost',
                champion: actions.championProtect
              });
              result.stateChanges['specialTrackers.championPowerActive'] = false;
            }

            // Guardian sacrifice
            if (protection.protectedBy === 'Guardian') {
              const guardian = state.players.find(p => p.charId === 18 && !p.eliminated);
              if (guardian) {
                result.preDoctorEliminations.push({
                  player: guardian.id,
                  playerName: `${guardian.name} (${guardian.roleName})`,
                  cause: 'Guardian Sacrifice'
                });
              }
            }
          }
        } else {
          // Target not protected - add to eliminations
          const targetPlayer = state.players.find(p => p.id === target.playerId);
          if (targetPlayer && !targetPlayer.eliminated) {
            // Check for Survivor passive (char ID 19)
            if (targetPlayer.charId === 19 && !targetPlayer.survivorUsed) {
              result.specialEvents.push({
                type: 'survivorTriggered',
                player: target.playerId,
                playerName: `${targetPlayer.name} (${targetPlayer.roleName})`
              });
              result.stateChanges[`players.${target.playerId}.survivorUsed`] = true;
            } else {
              result.preDoctorEliminations.push({
                player: target.playerId,
                playerName: `${targetPlayer.name} (${targetPlayer.roleName})`,
                cause: target.source === 'assassin' ? 'Assassin' : 'Villain Team'
              });
            }
          }
        }
      });

      // Step 6: Check Defender trap
      if (!defenderBlocked && actions.defenderTrap !== null) {
        const trapped = result.preDoctorEliminations.find(e => e.player === actions.defenderTrap);
        if (trapped) {
          // Defender trap triggered - random villain dies
          const villains = state.players.filter(p => 
            p.type === 'villain' && !p.eliminated
          );
          if (villains.length > 0) {
            const randomVillain = villains[Math.floor(Math.random() * villains.length)];
            result.preDoctorEliminations.push({
              player: randomVillain.id,
              playerName: `${randomVillain.name} (${randomVillain.roleName})`,
              cause: 'Defender Trap'
            });
            result.specialEvents.push({
              type: 'defenderTrapTriggered',
              victim: actions.defenderTrap,
              villain: randomVillain.id
            });
          }
        }
      }

      // Step 7: Check Stalker backup (if primary target was protected and Stalker is in game)
      if (actions.stalkerActive && actions.villainTarget !== null && protectedPlayers.has(actions.villainTarget)) {
        const stalker = state.players.find(p => p.charId === 5 && !p.eliminated);
        if (stalker) {
          result.specialEvents.push({
            type: 'stalkerBackupAttempt',
            message: 'Stalker can attempt backup kill (only works on Damsel/Elder types)'
          });
        }
      }

      // Copy pre-doctor to final eliminations (will be modified if doctor acts)
      result.finalEliminations = [...result.preDoctorEliminations];

      return result;
    }

    function processLinkedDeaths(eliminations) {
      const linkedDeaths = [];
      const processedIds = new Set(eliminations.map(e => e.player));

      eliminations.forEach(elim => {
        const player = state.players.find(p => p.id === elim.player);
        if (!player) return;

        // Check for Twins (char IDs 28, 29)
        if (player.charId === 28 || player.charId === 29) {
          const twinCharId = player.charId === 28 ? 29 : 28;
          const twin = state.players.find(p => p.charId === twinCharId && !p.eliminated && !processedIds.has(p.id));
          if (twin) {
            linkedDeaths.push({
              player: twin.id,
              playerName: `${twin.name} (${twin.roleName})`,
              cause: 'Twin Link'
            });
            processedIds.add(twin.id);
          }
        }

        // Check for Cursed (char ID 30) - kills 2 neighbors each side
        if (player.charId === 30) {
          const alivePlayers = state.players.filter(p => !p.eliminated && p.id !== player.id);
          // In a circle, find neighbors (simplified - in real game would need seating order)
          const playerIndex = state.players.findIndex(p => p.id === player.id);
          const cursedNeighbors = [];
          
          // Get 2 neighbors each side (4 total)
          for (let offset of [-2, -1, 1, 2]) {
            const neighborIndex = (playerIndex + offset + state.players.length) % state.players.length;
            const neighbor = state.players[neighborIndex];
            if (neighbor && !neighbor.eliminated && !processedIds.has(neighbor.id)) {
              cursedNeighbors.push(neighbor);
            }
          }

          cursedNeighbors.forEach(neighbor => {
            linkedDeaths.push({
              player: neighbor.id,
              playerName: `${neighbor.name} (${neighbor.roleName})`,
              cause: 'Cursed Explosion'
            });
            processedIds.add(neighbor.id);
          });
        }
      });

      return linkedDeaths;
    }

    function showResolutionSummary(result) {
      const summaryDiv = document.createElement('div');
      summaryDiv.className = 'resolution-summary';
      summaryDiv.innerHTML = `
        <h3>ðŸ“Š Night Resolution Summary</h3>
        <div class="resolution-section">
          <h4>ðŸŽ¯ Actions Taken:</h4>
          ${result.actions.map(a => `<p>â€¢ ${a.actor} â†’ Player ${a.target + 1}</p>`).join('')}
        </div>
        <div class="resolution-section">
          <h4>ðŸ›¡ï¸ Protections:</h4>
          ${result.protections.map(p => {
            const player = state.players.find(pl => pl.id === p.player);
            return `<p>â€¢ Player ${p.player + 1} (${player ? player.roleName : 'Unknown'}) protected by ${p.protectedBy}${p.triggered ? ' âœ“ TRIGGERED' : ''}</p>`;
          }).join('') || '<p>None</p>'}
        </div>
        <div class="resolution-section">
          <h4>âš ï¸ Special Events:</h4>
          ${result.specialEvents.map(e => {
            if (e.type === 'championIdentified') {
              return `<p class="special-event">â€¢ Champion identified villain: ${e.villainName}</p>`;
            }
            if (e.type === 'championPowerLost') {
              return `<p class="special-event">â€¢ Champion loses power permanently</p>`;
            }
            if (e.type === 'survivorTriggered') {
              return `<p class="special-event">â€¢ ${e.playerName} survived attack (Survivor passive)</p>`;
            }
            if (e.type === 'defenderTrapTriggered') {
              return `<p class="special-event">â€¢ Defender trap killed a villain!</p>`;
            }
            return `<p class="special-event">â€¢ ${e.message || JSON.stringify(e)}</p>`;
          }).join('') || '<p>None</p>'}
        </div>
        <div class="resolution-section">
          <h4>ðŸ’€ Pending Eliminations:</h4>
          ${result.preDoctorEliminations.map(e => `<p class="elimination">â€¢ ${e.playerName} (${e.cause})</p>`).join('') || '<p>No eliminations</p>'}
        </div>
      `;
      return summaryDiv;
    }

    function applyResolution(result) {
      // Apply state changes
      Object.entries(result.stateChanges).forEach(([key, value]) => {
        if (key.startsWith('specialTrackers.')) {
          const trackerKey = key.replace('specialTrackers.', '');
          state.specialTrackers[trackerKey] = value;
        } else if (key.startsWith('players.')) {
          const match = key.match(/players\.(\d+)\.(.+)/);
          if (match) {
            const playerId = parseInt(match[1]);
            const prop = match[2];
            const player = state.players.find(p => p.id === playerId);
            if (player) {
              player[prop] = value;
            }
          }
        }
      });

      // Apply eliminations
      result.finalEliminations.forEach(elim => {
        const player = state.players.find(p => p.id === elim.player);
        if (player) {
          player.eliminated = true;
        }
      });

      // Process linked deaths
      const linkedDeaths = processLinkedDeaths(result.finalEliminations);
      linkedDeaths.forEach(death => {
        const player = state.players.find(p => p.id === death.player);
        if (player) {
          player.eliminated = true;
        }
        result.finalEliminations.push(death);
      });

      // Store result
      state.resolutionResult = result;

      // Clear night actions for next night
      if (result.finalEliminations.length > 0 || result.specialEvents.length > 0) {
        // Update healer's last protected
        if (state.nightActions.healerProtect !== null) {
          state.nightActions.healerLastProtected = state.nightActions.healerProtect;
        }
      }

      persistState();
    }

    function renderScript() {
      const steps = buildScriptSteps();
      const step = steps[state.stepIndex];
      scriptStepsContainer.innerHTML = "";
      if (!step) {
        scriptTitle.textContent = "End of Phase";
        phaseLabel.textContent = "Summary";
        scriptStepsContainer.innerHTML = "<p>All steps complete. Advance when ready for the next night.";
      } else {
        scriptTitle.textContent = step.title;
        phaseLabel.textContent = PHASES[step.phase] || "Script";
        
        // Update audio phase if it changed
        if (step.phase && step.phase !== state.audio.phase) {
          updateAudioPhase(step.phase);
        }
        
        step.blocks.forEach(block => {
          const div = document.createElement("div");
          div.className = `script-block block-${block.type}`;
          div.textContent = block.text;
          scriptStepsContainer.append(div);
        });

        // Add action tracker if this step needs it
        if (step.showActionTracker) {
          const actionTracker = createActionTracker();
          scriptStepsContainer.append(actionTracker);
        }

        // Add resolution button if this step needs it
        if (step.showResolutionButton) {
          const resolutionButton = document.createElement('button');
          resolutionButton.textContent = 'ðŸ“Š Calculate Night Resolution';
          resolutionButton.className = 'resolution-calc-btn';
          resolutionButton.style.marginTop = '1rem';
          resolutionButton.style.width = '100%';
          resolutionButton.onclick = () => {
            const result = calculateNightResolution();
            applyResolution(result);
            const summary = showResolutionSummary(result);
            
            // Insert summary before the button
            const existingSummary = scriptStepsContainer.querySelector('.resolution-summary');
            if (existingSummary) {
              existingSummary.remove();
            }
            scriptStepsContainer.insertBefore(summary, resolutionButton);
            renderPlayers();
            updateCounts();
          };
          scriptStepsContainer.append(resolutionButton);
        }

        // Show existing resolution if available
        if (state.resolutionResult && step.title === "Night Resolution (Private)") {
          const summary = showResolutionSummary(state.resolutionResult);
          scriptStepsContainer.append(summary);
        }
      }

      prevStepButton.disabled = state.stepIndex === 0;
      nextStepButton.textContent = state.stepIndex >= steps.length - 1 ? "Next Night" : "Next";

      const discussionIndex = steps.findIndex(step => step.title === "Discussion");
      if (discussionIndex >= 0 && state.stepIndex >= discussionIndex) {
        timerPhase.textContent = "Discussion Timer";
      } else {
        timerPhase.textContent = "Timer";
      }
    }

    function createActionTracker() {
      const tracker = document.createElement('div');
      tracker.className = 'action-tracker';
      
      const alivePlayers = state.players.filter(p => !p.eliminated);
      const playerOptions = alivePlayers.map(p => 
        `<option value="${p.id}">${p.name} (${p.roleName})</option>`
      ).join('');

      tracker.innerHTML = `
        <h4>Action Tracker</h4>
        <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1rem;">
          Record the actions taken during this night phase. The resolution calculator will process them automatically.
        </p>
        
        <label>Villain Target:</label>
        <select id="action-villain-target">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Assassin Target (if used):</label>
        <select id="action-assassin-target">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Champion Protected:</label>
        <select id="action-champion-protect">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Healer Protected:</label>
        <select id="action-healer-protect">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Guardian Protected:</label>
        <select id="action-guardian-protect">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Defender Trapped:</label>
        <select id="action-defender-trap">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Right Hand Blocked:</label>
        <select id="action-right-hand-block">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <div class="action-buttons">
          <button onclick="saveNightActions()" style="background: linear-gradient(135deg, rgba(34, 211, 238, 0.7), rgba(56, 189, 248, 0.9));">
            ðŸ’¾ Save Actions
          </button>
          <button onclick="clearNightActions()" style="background: linear-gradient(135deg, rgba(148, 163, 184, 0.5), rgba(100, 116, 139, 0.7));">
            ðŸ—‘ï¸ Clear All
          </button>
        </div>
      `;

      // Load existing actions if any
      setTimeout(() => {
        if (state.nightActions.villainTarget !== null) {
          document.getElementById('action-villain-target').value = state.nightActions.villainTarget;
        }
        if (state.nightActions.assassinTarget !== null) {
          document.getElementById('action-assassin-target').value = state.nightActions.assassinTarget;
        }
        if (state.nightActions.championProtect !== null) {
          document.getElementById('action-champion-protect').value = state.nightActions.championProtect;
        }
        if (state.nightActions.healerProtect !== null) {
          document.getElementById('action-healer-protect').value = state.nightActions.healerProtect;
        }
        if (state.nightActions.guardianProtect !== null) {
          document.getElementById('action-guardian-protect').value = state.nightActions.guardianProtect;
        }
        if (state.nightActions.defenderTrap !== null) {
          document.getElementById('action-defender-trap').value = state.nightActions.defenderTrap;
        }
        if (state.nightActions.rightHandBlock !== null) {
          document.getElementById('action-right-hand-block').value = state.nightActions.rightHandBlock;
        }
      }, 0);

      return tracker;
    }

    function saveNightActions() {
      const villainTarget = document.getElementById('action-villain-target').value;
      const assassinTarget = document.getElementById('action-assassin-target').value;
      const championProtect = document.getElementById('action-champion-protect').value;
      const healerProtect = document.getElementById('action-healer-protect').value;
      const guardianProtect = document.getElementById('action-guardian-protect').value;
      const defenderTrap = document.getElementById('action-defender-trap').value;
      const rightHandBlock = document.getElementById('action-right-hand-block').value;

      state.nightActions.villainTarget = villainTarget ? parseInt(villainTarget) : null;
      state.nightActions.assassinTarget = assassinTarget ? parseInt(assassinTarget) : null;
      state.nightActions.championProtect = championProtect ? parseInt(championProtect) : null;
      state.nightActions.healerProtect = healerProtect ? parseInt(healerProtect) : null;
      state.nightActions.guardianProtect = guardianProtect ? parseInt(guardianProtect) : null;
      state.nightActions.defenderTrap = defenderTrap ? parseInt(defenderTrap) : null;
      state.nightActions.rightHandBlock = rightHandBlock ? parseInt(rightHandBlock) : null;

      persistState();
      alert('âœ“ Night actions saved! Now click "Calculate Night Resolution" to see the results.');
    }

    function clearNightActions() {
      if (confirm('Clear all recorded actions for this night?')) {
        state.nightActions = {
          villainTarget: null,
          assassinTarget: null,
          stalkerActive: false,
          championProtect: null,
          healerProtect: null,
          guardianProtect: null,
          defenderTrap: null,
          rightHandBlock: null,
          healerLastProtected: state.nightActions.healerLastProtected
        };
        state.resolutionResult = null;
        persistState();
        renderScript();
      }
    }

    function renderPlayers() {
      playerList.innerHTML = "";
      state.players.forEach(player => {
        const clone = playerCardTemplate.content.cloneNode(true);
        const card = clone.querySelector(".player-card");
        card.dataset.status = player.eliminated ? "eliminated" : player.protected ? "protected" : "alive";
        card.dataset.id = player.id;
        clone.querySelector(".player-name").textContent = player.name;
        clone.querySelector(".player-meta").textContent = `${player.roleName} â€¢ ${TYPE_DETAILS[player.type].label}`;
        const badge = clone.querySelector(".badge");
        badge.classList.add(player.team);
        badge.textContent = player.team.toUpperCase();
        clone.querySelector(".player-ability").textContent = player.ability;
        const notes = clone.querySelector(".player-notes");
        notes.value = player.notes;
        notes.addEventListener("input", (event) => {
          player.notes = event.target.value;
          persistState();
        });
        clone.querySelectorAll("button").forEach(btn => {
          btn.addEventListener("click", () => handlePlayerAction(player.id, btn.dataset.action));
        });
        playerList.append(clone);
      });
    }

    function handlePlayerAction(id, action) {
      const player = state.players.find(p => p.id === id);
      if (!player) return;
      if (action === "toggle-eliminated") {
        player.eliminated = !player.eliminated;
        if (player.eliminated) player.protected = false;
      }
      if (action === "toggle-protected") {
        player.protected = !player.protected;
        if (player.protected) player.eliminated = false;
      }
      updateCounts();
      renderPlayers();
      persistState();
    }

    function updateCounts() {
      const alivePlayers = state.players.filter(p => !p.eliminated);
      aliveCount.textContent = alivePlayers.length;
      goodCount.textContent = alivePlayers.filter(p => p.team === "good").length;
      evilCount.textContent = alivePlayers.filter(p => p.team === "evil").length;
      nightNumber.textContent = state.night;
    }

    function goToNextStep() {
      const steps = buildScriptSteps();
      state.stepIndex = Math.min(state.stepIndex + 1, steps.length);
      if (state.stepIndex >= steps.length) {
        state.night += 1;
        state.stepIndex = 0;
      }
      persistState();
      renderScript();
    }

    function goToPrevStep() {
      state.stepIndex = Math.max(0, state.stepIndex - 1);
      persistState();
      renderScript();
    }

    function renderTimer() {
      const minutes = String(Math.floor(state.timer.remaining / 60)).padStart(2, "0");
      const seconds = String(state.timer.remaining % 60).padStart(2, "0");
      timerDisplay.textContent = `${minutes}:${seconds}`;
    }

    function startTimer(duration) {
      if (typeof duration === "number") {
        state.timer.remaining = duration;
      }
      if (state.timer.handle) {
        clearInterval(state.timer.handle);
      }
      state.timer.running = true;
      state.timer.handle = setInterval(() => {
        if (state.timer.remaining > 0) {
          state.timer.remaining -= 1;
          renderTimer();
          if (state.timer.remaining === 0) {
            alert("Timer complete! Time for a dramatic decision.");
          }
        }
      }, 1000);
      persistState();
    }

    function pauseTimer() {
      state.timer.running = false;
      if (state.timer.handle) clearInterval(state.timer.handle);
      state.timer.handle = null;
      persistState();
    }

    function resetTimer() {
      pauseTimer();
      state.timer.remaining = 180;
      renderTimer();
      persistState();
    }

    function handleStartGame() {
      state.players = preparePlayers();
      state.phase = "night";
      state.night = 1;
      state.stepIndex = 0;
      state.notes = notesArea.value;
      state.audio.phase = "night";
      persistState();
      setupSection.classList.add("hidden");
      gameSection.classList.remove("hidden");
      audioControls.classList.remove("hidden");
      applyThemeVisuals();
      renderAll();
    }

    function renderDownloadLink() {
      const notes = [`Narrator Notes - Night ${state.night}`, "==============================", "", notesArea.value || "(none)", "", "Player Notes:"]; 
      state.players.forEach(player => {
        const status = player.eliminated ? "Eliminated" : "Alive";
        notes.push(`${player.name} - ${player.roleName} (${status})`);
        if (player.notes) notes.push(`  Notes: ${player.notes}`);
      });
      const blob = new Blob([notes.join("\n")], { type: "text/plain" });
      if (downloadNotesLink.dataset.url) {
        URL.revokeObjectURL(downloadNotesLink.dataset.url);
      }
      const objectUrl = URL.createObjectURL(blob);
      downloadNotesLink.href = objectUrl;
      downloadNotesLink.dataset.url = objectUrl;
    }

    function renderAll() {
      applyMode(state.mode);
      applyThemeVisuals();
      updatePlayerCountDisplays();
      updateRoleSelectionUI();
      renderThemeSelect();
      renderTimer();
      namesInput.value = state.nameList;
      
      // Update audio controls
      toggleAudioButton.textContent = state.audio.enabled ? "ðŸ”Š" : "ðŸ”‡";
      volumeSlider.value = state.audio.volume * 100;
      audioPhase.textContent = state.audio.phase === "night" ? "Night" : "Day";
      audioIndicator.classList.toggle("playing", state.audio.enabled);
      
      if (state.phase === "setup") {
        setupSection.classList.remove("hidden");
        gameSection.classList.add("hidden");
        audioControls.classList.add("hidden");
      } else {
        setupSection.classList.add("hidden");
        gameSection.classList.remove("hidden");
        audioControls.classList.remove("hidden");
        renderScript();
        renderPlayers();
        updateCounts();
        notesArea.value = state.notes;
        renderDownloadLink();
      }
    }

    playerCountInput.addEventListener("input", () => {
      updatePlayerCountDisplays();
      updateRoleSelectionUI();
      persistState();
    });

    themeSelect.addEventListener("change", event => {
      state.theme = event.target.value;
      themeDescription.textContent = THEMES[state.theme].description;
      applyThemeVisuals();
      persistState();
      if (state.phase !== "setup") {
        renderScript();
        if (state.audio.enabled) {
          playThemeAudio();
        }
      }
    });

    namesInput.addEventListener("input", () => {
      state.nameList = namesInput.value;
      persistState();
    });

    notesArea.addEventListener("input", event => {
      state.notes = event.target.value;
      persistState();
      renderDownloadLink();
    });

    startButton.addEventListener("click", handleStartGame);
    prevStepButton.addEventListener("click", goToPrevStep);
    nextStepButton.addEventListener("click", goToNextStep);

    timerButtons.forEach(btn => btn.addEventListener("click", () => startTimer(Number(btn.dataset.timer))));
    startTimerBtn.addEventListener("click", () => startTimer());
    pauseTimerBtn.addEventListener("click", pauseTimer);
    resetTimerBtn.addEventListener("click", resetTimer);

    toggleModeButton.addEventListener("click", () => {
      state.mode = state.mode === "light" ? "dark" : "light";
      applyMode(state.mode);
      persistState();
    });

    resetGameButton.addEventListener("click", () => {
      if (confirm("Start a new game? Current progress will be cleared.")) {
        resetState();
      }
    });

    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("sw.js").catch(console.error);
      });
    }

    // Initialize audio system
    initAudioSystem();

    renderThemeSelect();
    renderRoleGroups();
    updatePlayerCountDisplays();
    updateRoleSelectionUI();
    renderAll();
  </script>
</body>
</html>
