<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Melodrama Werewolf Narrator</title>
  <meta name="description" content="Digital narrator tool for the Melodrama Werewolf classroom drama game." />
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#0f172a" />
  <!-- Google Fonts for theme-specific typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Cinzel:wght@400;700&family=Orbitron:wght@400;700&family=Rye&family=Pirata+One&family=Lobster&family=Creepster&family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: dark;
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --text-primary: #f8fafc;
      --text-secondary: #e2e8f0;
      --accent-good: #38bdf8;
      --accent-evil: #f472b6;
      --accent-neutral: #facc15;
      --accent-ui: #22d3ee;
      --border-color: #475569;
      --panel-radius: 16px;
      --shadow: 0 12px 30px rgba(15, 23, 42, 0.4);
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 16px;
    }

    body.light {
      color-scheme: light;
      --bg-primary: #f1f5f9;
      --bg-secondary: #ffffff;
      --bg-tertiary: #e2e8f0;
      --text-primary: #0f172a;
      --text-secondary: #475569;
      --border-color: #cbd5e1;
      --shadow: 0 8px 22px rgba(15, 23, 42, 0.12);
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.06), transparent 55%), #f1f5f9;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100vh;
      max-height: 100vh;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.08), transparent 55%), var(--bg-primary);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      padding: 0.5rem clamp(1rem, 4vw, 3rem);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-shrink: 0;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.4rem, 3vw, 1.8rem);
      letter-spacing: 0.03em;
    }

    header h1 span {
      color: var(--accent-evil);
    }

    header .actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    button,
    select,
    input,
    textarea {
      font: inherit;
      color: inherit;
    }

    button {
      border: none;
      padding: 0.45rem 0.85rem;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.7), rgba(244, 114, 182, 0.9));
      color: #0f172a;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
      box-shadow: 0 6px 14px rgba(56, 189, 248, 0.2);
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(244, 114, 182, 0.28);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .preset-button {
      border-radius: 12px !important;
      background: linear-gradient(135deg, rgba(34, 211, 238, 0.8), rgba(56, 189, 248, 0.9)) !important;
      padding: 0.75rem 1rem !important;
      box-shadow: 0 6px 16px rgba(34, 211, 238, 0.3) !important;
      text-align: left;
    }

    .preset-button:hover:not(:disabled) {
      transform: translateY(-2px) !important;
      box-shadow: 0 10px 24px rgba(34, 211, 238, 0.4) !important;
    }

    .preset-button strong {
      display: block;
      font-size: 1.05rem;
    }

    .preset-button small {
      font-size: 0.85rem;
      opacity: 0.9;
      font-weight: 400;
    }

    main {
      flex: 1;
      padding: 0 clamp(1rem, 4vw, 3rem) 1rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }

    section {
      background: rgba(15, 23, 42, 0.65);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: var(--panel-radius);
      padding: clamp(0.75rem, 2vw, 1rem);
      box-shadow: var(--shadow);
      backdrop-filter: blur(18px);
      flex: 1;
      min-height: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* Setup section should allow scrolling for role selection */
    #setup-section {
      overflow-y: auto;
    }

    /* Game section should fill viewport without page scroll */
    #game-section {
      overflow: hidden;
    }

    body.light section {
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    
    small {
      font-size: 0.85rem;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    h2 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      font-size: clamp(1.1rem, 2.5vw, 1.4rem);
      letter-spacing: 0.02em;
      font-weight: 700;
      flex-shrink: 0;
    }
    
    p {
      font-size: 0.9rem;
      line-height: 1.5;
    }
    
    section > p {
      font-size: 0.9rem;
      line-height: 1.5;
      color: var(--text-secondary);
      flex-shrink: 0;
    }

    .setup-grid {
      display: grid;
      gap: 1.25rem;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .stat {
      background: rgba(15, 23, 42, 0.5);
      padding: 1rem 1.25rem;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .stat > span {
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .stat strong {
      font-size: 2rem;
      letter-spacing: 0.05em;
    }
    
    body.light .stat {
      background: rgba(255, 255, 255, 0.95);
    }

    .range-input {
      display: grid;
      gap: 0.5rem;
    }

    input[type="range"] {
      accent-color: var(--accent-evil);
    }

    .role-groups {
      display: grid;
      gap: 1rem;
    }

    .role-group {
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 14px;
      padding: 1.25rem;
      background: rgba(15, 23, 42, 0.5);
      display: grid;
      gap: 1rem;
    }

    body.light .role-group {
      background: rgba(255, 255, 255, 0.95);
    }

    .role-group-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 1rem;
    }
    
    .role-group-header small {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .role-cards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 0.75rem;
    }

    .role-card {
      border-radius: 18px;
      padding: 1.25rem;
      border: 2px solid transparent;
      background: rgba(15, 23, 42, 0.6);
      cursor: pointer;
      transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
      display: grid;
      gap: 0.65rem;
      position: relative;
    }

    body.light .role-card {
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .role-card[data-selected="true"] {
      transform: translateY(-3px);
      border-color: var(--accent-ui);
      box-shadow: 0 12px 22px rgba(34, 211, 238, 0.3);
    }

    .role-card .type {
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .role-card .team-label {
      font-size: 0.85rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .badge {
      display: inline-flex;
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .badge.good {
      background: rgba(56, 189, 248, 0.25);
      color: #e0f2fe;
      border: 1px solid rgba(56, 189, 248, 0.4);
    }

    .badge.evil {
      background: rgba(244, 114, 182, 0.25);
      color: #fce7f3;
      border: 1px solid rgba(244, 114, 182, 0.4);
    }

    .badge.neutral {
      background: rgba(250, 204, 21, 0.25);
      color: #fef9c3;
      border: 1px solid rgba(250, 204, 21, 0.4);
    }

    body.light .badge.good {
      background: rgba(56, 189, 248, 0.15);
      color: #0369a1;
      border: 1px solid rgba(56, 189, 248, 0.3);
    }

    body.light .badge.evil {
      background: rgba(244, 114, 182, 0.15);
      color: #831843;
      border: 1px solid rgba(244, 114, 182, 0.3);
    }

    body.light .badge.neutral {
      background: rgba(250, 204, 21, 0.15);
      color: #854d0e;
      border: 1px solid rgba(250, 204, 21, 0.3);
    }

    .role-card p {
      font-size: 0.95rem;
      margin: 0;
      line-height: 1.5;
      color: var(--text-secondary);
    }
    
    .role-card h3 {
      margin: 0;
      font-size: 1.1rem;
      line-height: 1.3;
      font-weight: 600;
    }

    .card-ghost {
      display: none;
    }

    .start-footer {
      margin-top: 1.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: space-between;
      align-items: center;
    }
    
    .start-footer small {
      font-size: 0.95rem;
      color: var(--text-secondary);
    }

    .name-list {
      width: 100%;
      min-height: 120px;
      padding: 1rem;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.5);
      resize: vertical;
      font-size: 1rem;
      line-height: 1.6;
    }

    body.light .name-list {
      background: rgba(255, 255, 255, 0.95);
    }

    .hidden {
      display: none !important;
    }

    .game-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.75rem;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    @media (max-width: 1200px) {
      .game-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 768px) {
      .game-grid {
        grid-template-columns: 1fr;
        overflow-y: auto;
      }
    }

    .script-panel {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      min-height: 0;
      overflow: hidden;
    }

    .script-step {
      display: grid;
      gap: 0.5rem;
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    .script-block {
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.5);
      line-height: 1.4;
      font-size: 0.9rem;
    }
    
    body.light .script-block {
      background: rgba(255, 255, 255, 0.95);
    }

    .block-say {
      border-left: 3px solid var(--accent-evil);
      font-size: 1rem;
      font-style: italic;
      font-weight: 500;
    }

    .block-narrator {
      border-left: 3px solid var(--accent-ui);
    }

    .block-info {
      border-left: 3px solid var(--accent-good);
      color: var(--text-secondary);
    }

    .block-reminder {
      border-left: 3px solid var(--accent-neutral);
      font-weight: 500;
    }

    .block-action {
      border-left: 3px solid #f97316;
      font-weight: 500;
    }

    /* Script formatting classes */
    .script-block .character-names {
      color: var(--accent-evil);
      font-weight: 600;
    }
    
    .script-block .guidance {
      font-weight: 700;
    }

    .script-nav {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      flex-shrink: 0;
    }

    .script-nav button {
      flex: 1;
      min-width: 100px;
    }

    .status-panel,
    .players-panel {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      min-height: 0;
      overflow: hidden;
    }

    .status-panel {
      overflow-y: auto;
    }

    .player-list {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    .timer-card {
      display: grid;
      gap: 0.35rem;
      padding: 0.75rem;
      border-radius: 12px;
      background: radial-gradient(circle at 25% 25%, rgba(56, 189, 248, 0.22), transparent), rgba(15, 23, 42, 0.45);
      text-align: center;
      border: 1px solid rgba(148, 163, 184, 0.22);
      flex-shrink: 0;
    }

    .timer-display {
      font-size: clamp(2rem, 5vw, 2.8rem);
      letter-spacing: 0.08em;
    }

    .timer-controls {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .timer-controls button {
      flex: 1 1 80px;
      padding: 0.5rem 0.6rem;
      font-size: 0.85rem;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.3rem 0.75rem;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.3);
      font-size: 0.75rem;
      font-weight: 500;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--text-primary);
      flex-shrink: 0;
    }
    
    body.light .pill {
      background: rgba(255, 255, 255, 0.95);
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.5rem;
      flex-shrink: 0;
    }

    /* Compact stats in game view */
    .status-panel .stat {
      padding: 0.5rem 0.75rem;
      gap: 0.25rem;
    }

    .status-panel .stat > span {
      font-size: 0.75rem;
    }

    .status-panel .stat strong {
      font-size: 1.25rem;
    }

    .status-panel .stat div {
      font-size: 0.85rem;
    }

    /* Make notes area compact but scrollable */
    .status-panel .name-list {
      min-height: 50px;
      max-height: 100px;
      font-size: 0.85rem;
      flex-shrink: 1;
    }

    .player-card {
      border-radius: 10px;
      padding: 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.5);
      display: grid;
      gap: 0.35rem;
    }
    
    body.light .player-card {
      background: rgba(255, 255, 255, 0.95);
    }

    .player-card header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      padding: 0;
    }

    .player-name {
      font-weight: 600;
      letter-spacing: 0.03em;
      font-size: 0.85rem;
    }

    .player-meta {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-top: 0.1rem;
    }

    .player-actions {
      display: flex;
      gap: 0.3rem;
      flex-wrap: wrap;
    }

    .player-actions button {
      background: rgba(148, 163, 184, 0.25);
      color: var(--text-primary);
      padding: 0.25rem 0.5rem;
      border-radius: 5px;
      flex: 1;
      min-width: 60px;
      font-size: 0.75rem;
      font-weight: 500;
    }
    
    body.light .player-actions button {
      background: rgba(148, 163, 184, 0.15);
    }

    .player-card[data-status="eliminated"] {
      opacity: 0.55;
      text-decoration: line-through;
    }

    .player-card[data-status="protected"] {
      border-color: var(--accent-good);
    }

    .player-card p {
      font-size: 0.75rem;
      line-height: 1.3;
      margin: 0;
    }

    .player-card textarea {
      width: 100%;
      min-height: 30px;
      border-radius: 6px;
      padding: 0.35rem;
      background: rgba(15, 23, 42, 0.5);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: inherit;
      resize: vertical;
      font-size: 0.75rem;
      line-height: 1.3;
    }
    
    body.light .player-card textarea {
      background: rgba(255, 255, 255, 0.95);
    }

    /* Phase-aware layout adjustments */
    .game-grid[data-phase="night"] .timer-card {
      order: 2;
    }

    .game-grid[data-phase="night"] .status-panel > .stat-grid,
    .game-grid[data-phase="night"] .status-panel > .stat {
      order: 1;
    }

    .game-grid[data-phase="day"] .timer-card {
      order: -1;
      padding: 1rem;
    }

    .game-grid[data-phase="day"] .timer-display {
      font-size: clamp(2.4rem, 6vw, 3.2rem);
    }

    @media (max-width: 768px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }

      header .actions {
        width: 100%;
        justify-content: flex-start;
      }

      .role-cards {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }

      .player-actions button {
        flex: 1 1 45%;
      }
    }

    .resolution-summary {
      background: rgba(15, 23, 42, 0.6);
      border: 2px solid var(--accent-ui);
      border-radius: 16px;
      padding: 1.5rem;
      margin: 1rem 0;
      box-shadow: 0 8px 24px rgba(34, 211, 238, 0.25);
    }

    .resolution-summary h3 {
      margin: 0 0 1rem 0;
      color: var(--accent-ui);
      font-size: 1.4rem;
    }

    .resolution-summary h4 {
      margin: 1rem 0 0.5rem 0;
      font-size: 1.1rem;
      color: var(--text-primary);
    }

    .resolution-section {
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 8px;
      border-left: 3px solid var(--accent-good);
    }

    .resolution-section p {
      margin: 0.25rem 0;
      font-size: 0.95rem;
    }

    .special-event {
      color: var(--accent-neutral);
      font-weight: 600;
    }

    .elimination {
      color: var(--accent-evil);
      font-weight: 600;
    }

    .action-tracker {
      background: rgba(15, 23, 42, 0.45);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0;
    }

    .action-tracker label {
      display: block;
      margin: 0.5rem 0 0.25rem 0;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .action-tracker select {
      width: 100%;
      padding: 0.5rem;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.6);
      color: inherit;
      font-size: 0.95rem;
    }

    .action-tracker button {
      margin-top: 0.75rem;
      width: 100%;
    }

    .action-buttons {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .action-buttons button {
      flex: 1;
      padding: 0.75rem;
    }

    /* Voting tracker styles */
    .nomination-item,
    .defense-item,
    .vote-item {
      transition: all 0.2s ease;
    }

    .nomination-item:hover,
    .defense-item:hover,
    .vote-item:hover {
      background: rgba(56, 189, 248, 0.1) !important;
    }

    .silenced-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      background: rgba(244, 114, 182, 0.2);
      color: var(--accent-evil);
      font-size: 0.75rem;
      font-weight: 600;
      border: 1px solid var(--accent-evil);
    }

    .corrupted-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      background: rgba(250, 204, 21, 0.2);
      color: var(--accent-neutral);
      font-size: 0.75rem;
      font-weight: 600;
      border: 1px solid var(--accent-neutral);
    }

    /* Theme-specific animations */
    @keyframes flicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.85; }
    }

    @keyframes shimmer {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.15); }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    @keyframes spotlight {
      0%, 100% { box-shadow: 0 0 30px rgba(245, 158, 11, 0.3); }
      50% { box-shadow: 0 0 50px rgba(245, 158, 11, 0.6); }
    }

    @keyframes tech-glow {
      0%, 100% { box-shadow: 0 0 20px rgba(34, 211, 238, 0.4); }
      50% { box-shadow: 0 0 40px rgba(34, 211, 238, 0.8); }
    }

    @keyframes dust {
      0%, 100% { opacity: 0.95; }
      50% { opacity: 0.85; }
    }

    @keyframes wave {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }

    @keyframes heartbeat {
      0%, 100% { transform: scale(1); }
      25% { transform: scale(1.05); }
      50% { transform: scale(1); }
    }

    /* Audio controls styling */
    .audio-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      background: rgba(15, 23, 42, 0.35);
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.16);
    }

    body.light .audio-controls {
      background: rgba(255, 255, 255, 0.9);
    }

    .audio-controls button {
      padding: 0.4rem 0.8rem;
      font-size: 0.85rem;
      min-width: auto;
    }

    .audio-controls .volume-slider {
      width: 100px;
      accent-color: var(--accent-ui);
    }

    .audio-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .audio-indicator.playing {
      color: var(--accent-ui);
    }

    /* Phase indicator for audio */
    .phase-audio-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.25rem 0.5rem;
      border-radius: 999px;
      background: rgba(34, 211, 238, 0.15);
      font-size: 0.75rem;
      margin-left: 0.5rem;
    }

    /* Game Code Card for Player Access */
    .game-code-card {
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.1), rgba(244, 114, 182, 0.1));
      border: 2px solid rgba(56, 189, 248, 0.4);
      border-radius: var(--panel-radius);
      padding: 1rem;
      margin-bottom: 1rem;
      text-align: center;
    }

    .game-code-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.75rem;
    }

    .game-code-header .pill {
      font-size: 0.75rem;
    }

    .open-player-link {
      font-size: 0.75rem;
      color: var(--accent-ui);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .open-player-link:hover {
      color: var(--accent-good);
      text-decoration: underline;
    }

    .game-code-display {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .game-code-label {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .game-code-value {
      font-size: 2rem;
      font-weight: 700;
      letter-spacing: 0.3em;
      font-family: 'Courier New', Courier, monospace;
      background: linear-gradient(135deg, var(--accent-good), var(--accent-evil));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 30px rgba(56, 189, 248, 0.3);
    }

    .game-code-hint {
      display: block;
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .game-code-hint strong {
      color: var(--accent-ui);
    }
    
    /* Player Connection Status Summary */
    .player-connection-summary {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 8px;
      margin-top: 0.75rem;
      font-size: 0.85rem;
    }
    
    .player-connection-summary .connection-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      animation: pulse-dot 2s ease-in-out infinite;
    }
    
    .player-connection-summary .connection-dot.connected {
      background: #22c55e;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.5);
    }
    
    .player-connection-summary .connection-dot.partial {
      background: #eab308;
      box-shadow: 0 0 8px rgba(234, 179, 8, 0.5);
    }
    
    .player-connection-summary .connection-dot.none {
      background: #6b7280;
    }
    
    @keyframes pulse-dot {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .player-connection-summary .connection-count {
      font-weight: 600;
    }
    
    .player-connection-summary .connection-count.all-connected {
      color: #22c55e;
    }
    
    .player-connection-summary .connection-count.partial {
      color: #eab308;
    }
    
    /* Player Card Connection Indicator */
    .player-connection-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.15rem 0.4rem;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
      margin-left: 0.5rem;
    }
    
    .player-connection-indicator.connected {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
      border: 1px solid rgba(34, 197, 94, 0.4);
    }
    
    .player-connection-indicator.disconnected {
      background: rgba(107, 114, 128, 0.2);
      color: #9ca3af;
      border: 1px solid rgba(107, 114, 128, 0.4);
    }
    
    .player-connection-indicator .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }
    
    .player-connection-indicator.connected .status-dot {
      background: #22c55e;
      animation: pulse-dot 2s ease-in-out infinite;
    }
    
    .player-connection-indicator.disconnected .status-dot {
      background: #6b7280;
    }

    body.light .game-code-card {
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.08), rgba(244, 114, 182, 0.08));
    }

    body.light .game-code-value {
      text-shadow: none;
    }

    /* Win Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(15, 23, 42, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(8px);
    }

    .modal-overlay.active {
      display: flex;
    }

    .win-modal {
      background: var(--bg-secondary);
      border-radius: var(--panel-radius);
      padding: 2rem;
      max-width: 600px;
      width: 90%;
      box-shadow: var(--shadow);
      border: 2px solid;
      animation: modalSlideIn 0.3s ease-out;
    }

    .win-modal.good-wins {
      border-color: var(--accent-good);
    }

    .win-modal.evil-wins {
      border-color: var(--accent-evil);
    }

    .win-modal h2 {
      margin: 0 0 1rem;
      font-size: clamp(2rem, 5vw, 3rem);
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .win-modal.good-wins h2 {
      color: var(--accent-good);
    }

    .win-modal.evil-wins h2 {
      color: var(--accent-evil);
    }

    .win-modal-narration {
      font-size: 1.1rem;
      line-height: 1.6;
      text-align: center;
      font-style: italic;
      padding: 1rem 1.5rem;
      background: var(--bg-tertiary);
      border-radius: 12px;
      margin-bottom: 1rem;
      border-left: 4px solid var(--accent-ui);
    }

    .win-modal.good-wins .win-modal-narration {
      border-left-color: var(--accent-good);
    }

    .win-modal.evil-wins .win-modal-narration {
      border-left-color: var(--accent-evil);
    }

    .win-modal-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0;
    }

    .win-modal-stat {
      text-align: center;
      padding: 1rem;
      background: var(--bg-tertiary);
      border-radius: 8px;
    }

    .win-modal-stat strong {
      display: block;
      font-size: 2rem;
      margin-bottom: 0.25rem;
    }

    .win-modal-stat span {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .win-modal-roles {
      margin: 1.5rem 0;
      max-height: 300px;
      overflow-y: auto;
      background: var(--bg-tertiary);
      padding: 1rem;
      border-radius: 8px;
    }

    .win-modal-role {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      margin: 0.25rem 0;
      background: var(--bg-secondary);
      border-radius: 6px;
    }

    .win-modal-role.eliminated {
      opacity: 0.6;
      text-decoration: line-through;
    }

    .win-modal-role-team {
      font-weight: 600;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.85rem;
    }

    .win-modal-role-team.good {
      background: rgba(56, 189, 248, 0.2);
      color: var(--accent-good);
    }

    .win-modal-role-team.evil {
      background: rgba(244, 114, 182, 0.2);
      color: var(--accent-evil);
    }

    .win-modal-actions {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .win-modal-actions button {
      flex: 1;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Dice Roll Modal */
    .dice-modal {
      background: var(--bg-secondary);
      border-radius: var(--panel-radius);
      padding: 2rem;
      max-width: 500px;
      width: 90%;
      box-shadow: var(--shadow);
      border: 2px solid var(--accent-good);
      animation: modalSlideIn 0.3s ease-out;
      text-align: center;
    }

    .dice-modal h2 {
      margin: 0 0 1rem;
      font-size: 2rem;
      color: var(--accent-good);
    }

    .dice-modal-character {
      font-size: 1.2rem;
      margin-bottom: 1.5rem;
      color: var(--text-secondary);
    }

    .dice-modal-roll {
      margin: 2rem 0;
    }

    .dice-modal-result {
      font-size: 4rem;
      margin: 1rem 0;
      animation: diceRoll 0.5s ease-out;
    }

    .dice-modal-outcome {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 1rem 0;
      padding: 1rem;
      border-radius: 8px;
    }

    .dice-modal-outcome.success {
      background: rgba(56, 189, 248, 0.2);
      color: var(--accent-good);
    }

    .dice-modal-outcome.failure {
      background: rgba(244, 114, 182, 0.2);
      color: var(--accent-evil);
    }

    .dice-modal-description {
      margin: 1rem 0;
      padding: 1rem;
      background: var(--bg-tertiary);
      border-radius: 8px;
      line-height: 1.6;
    }

    .dice-modal-actions {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .dice-modal-actions button {
      flex: 1;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
    }

    @keyframes diceRoll {
      0%, 20%, 40%, 60%, 80% {
        transform: rotate(0deg) scale(1);
      }
      10%, 30%, 50%, 70%, 90% {
        transform: rotate(180deg) scale(1.2);
      }
      100% {
        transform: rotate(360deg) scale(1);
      }
    }

    /* Help Modal */
    .help-modal {
      background: var(--bg-secondary);
      border-radius: var(--panel-radius);
      padding: 2rem;
      max-width: 800px;
      width: 90%;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: var(--shadow);
      border: 2px solid var(--accent-good);
      animation: modalSlideIn 0.3s ease-out;
    }

    .help-modal h2 {
      margin: 0 0 1rem;
      font-size: 2rem;
      color: var(--accent-good);
    }

    .help-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      border-bottom: 2px solid var(--bg-tertiary);
    }

    .help-tab {
      padding: 0.75rem 1.5rem;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
      border-bottom: 3px solid transparent;
    }

    .help-tab.active {
      color: var(--accent-good);
      border-bottom-color: var(--accent-good);
    }

    .help-tab:hover {
      color: var(--text-primary);
    }

    .help-content {
      display: none;
    }

    .help-content.active {
      display: block;
    }

    .help-search {
      margin-bottom: 1rem;
      width: 100%;
      padding: 0.75rem;
      font-size: 1rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--bg-primary);
      border-radius: 8px;
      color: var(--text-primary);
    }

    .character-list {
      display: grid;
      gap: 1rem;
    }

    .character-help-item {
      background: var(--bg-tertiary);
      padding: 1rem;
      border-radius: 8px;
      border-left: 4px solid var(--accent-good);
    }

    .character-help-item.evil {
      border-left-color: var(--accent-evil);
    }

    .character-help-item h4 {
      margin: 0 0 0.5rem;
      color: var(--accent-good);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .character-help-item.evil h4 {
      color: var(--accent-evil);
    }

    .character-help-item .type-badge {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
      background: var(--bg-secondary);
      border-radius: 4px;
      text-transform: uppercase;
    }

    .character-help-item p {
      margin: 0.5rem 0;
      line-height: 1.6;
    }

    .help-guide {
      line-height: 1.8;
    }

    .help-guide h3 {
      color: var(--accent-good);
      margin: 1.5rem 0 1rem;
    }

    .help-guide ol, .help-guide ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }

    .help-guide li {
      margin: 0.5rem 0;
    }

    .keyboard-shortcuts {
      display: grid;
      gap: 0.75rem;
    }

    .shortcut-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem;
      background: var(--bg-tertiary);
      border-radius: 8px;
    }

    .shortcut-key {
      font-family: monospace;
      background: var(--bg-primary);
      padding: 0.25rem 0.75rem;
      border-radius: 6px;
      font-weight: 600;
      color: var(--accent-good);
    }

    .help-modal-actions {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .help-modal-actions button {
      flex: 1;
    }

    /* Quick Reference Panel */
    .quick-ref-toggle {
      position: fixed;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      z-index: 100;
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.9), rgba(244, 114, 182, 0.9));
      border: none;
      padding: 0.75rem 0.5rem;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-weight: 600;
      font-size: 0.85rem;
      color: #0f172a;
      box-shadow: -4px 0 12px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s ease;
    }

    .quick-ref-toggle:hover {
      transform: translateY(-50%) translateX(-4px);
    }

    .quick-ref-toggle.panel-open {
      right: 320px;
    }

    .quick-ref-panel {
      position: fixed;
      right: -320px;
      top: 0;
      width: 320px;
      height: 100vh;
      background: var(--bg-secondary);
      border-left: 2px solid var(--accent-good);
      z-index: 99;
      transition: right 0.3s ease;
      display: flex;
      flex-direction: column;
      box-shadow: -8px 0 24px rgba(0, 0, 0, 0.3);
    }

    .quick-ref-panel.open {
      right: 0;
    }

    .quick-ref-header {
      padding: 1rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    .quick-ref-header h3 {
      margin: 0;
      font-size: 1.1rem;
      color: var(--accent-good);
    }

    .quick-ref-close {
      background: transparent;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-secondary);
      padding: 0.25rem;
      line-height: 1;
    }

    .quick-ref-content {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }

    .quick-ref-section {
      margin-bottom: 1.5rem;
    }

    .quick-ref-section h4 {
      margin: 0 0 0.75rem 0;
      font-size: 0.95rem;
      color: var(--text-primary);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5rem;
    }

    .quick-ref-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .quick-ref-list li {
      padding: 0.5rem 0.75rem;
      margin: 0.25rem 0;
      background: var(--bg-tertiary);
      border-radius: 6px;
      font-size: 0.85rem;
      line-height: 1.4;
    }

    .quick-ref-list li strong {
      color: var(--accent-good);
    }

    .quick-ref-list li.evil strong {
      color: var(--accent-evil);
    }

    .quick-ref-order {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      margin: 0.25rem 0;
      background: var(--bg-tertiary);
      border-radius: 6px;
      font-size: 0.85rem;
    }

    .quick-ref-order .step-num {
      background: var(--accent-ui);
      color: var(--bg-primary);
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.75rem;
      flex-shrink: 0;
    }

    .quick-ref-cheat {
      background: var(--bg-tertiary);
      padding: 0.75rem;
      border-radius: 8px;
      margin: 0.5rem 0;
      border-left: 3px solid var(--accent-neutral);
    }

    .quick-ref-cheat h5 {
      margin: 0 0 0.5rem 0;
      font-size: 0.9rem;
      color: var(--accent-neutral);
    }

    .quick-ref-cheat p {
      margin: 0;
      font-size: 0.8rem;
      line-height: 1.5;
      color: var(--text-secondary);
    }

    /* Sound Effects Toggle in Audio Controls */
    .sfx-toggle {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .sfx-toggle input[type="checkbox"] {
      accent-color: var(--accent-ui);
    }

    /* Dice Roll Button Enhancement */
    .sidekick-dice-section {
      background: var(--bg-tertiary);
      border: 2px solid var(--accent-good);
      border-radius: 12px;
      padding: 1rem;
      margin-top: 1rem;
    }

    .sidekick-dice-section h4 {
      margin: 0 0 0.75rem 0;
      font-size: 1rem;
      color: var(--accent-good);
    }

    .sidekick-dice-list {
      display: grid;
      gap: 0.5rem;
    }

    .sidekick-dice-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0.75rem;
      background: var(--bg-secondary);
      border-radius: 8px;
    }

    .sidekick-dice-item span {
      font-size: 0.9rem;
    }

    .sidekick-dice-item button {
      padding: 0.35rem 0.75rem;
      font-size: 0.8rem;
      min-width: auto;
    }

    /* Animated dice face */
    .dice-face {
      font-size: 4rem;
      display: inline-block;
      animation: diceRoll 0.5s ease-out;
    }

    @keyframes diceRoll {
      0%, 20%, 40%, 60%, 80% {
        transform: rotate(0deg) scale(1);
      }
      10%, 30%, 50%, 70%, 90% {
        transform: rotate(180deg) scale(1.2);
      }
      100% {
        transform: rotate(360deg) scale(1);
      }
    }
  </style>
  <!-- Firebase SDK for cross-device player communication -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js';
    import { getDatabase, ref, set, onValue, remove, update, push, onDisconnect, serverTimestamp } from 'https://www.gstatic.com/firebasejs/12.6.0/firebase-database.js';

    // Firebase configuration - these credentials are safe to expose in client-side code.
    // Security is managed through Firebase Realtime Database security rules.
    // See: https://firebase.google.com/docs/projects/api-keys
    const firebaseConfig = {
      apiKey: "AIzaSyCfZEDGBi99t3u9GlS78ifRmDM4-eJSdYg",
      authDomain: "melodrama-game.firebaseapp.com",
      projectId: "melodrama-game",
      storageBucket: "melodrama-game.firebasestorage.app",
      messagingSenderId: "656912364218",
      appId: "1:656912364218:web:7a9b44d4f3e9e89c550883",
      measurementId: "G-0S4D9SFEFH",
      databaseURL: "https://melodrama-game-default-rtdb.asia-southeast1.firebasedatabase.app"
    };

    // Initialize Firebase
    let firebaseApp = null;
    let database = null;
    let firebaseInitialized = false;

    try {
      firebaseApp = initializeApp(firebaseConfig);
      database = getDatabase(firebaseApp);
      firebaseInitialized = true;
      console.log('Firebase initialized successfully');
    } catch (error) {
      console.error('Failed to initialize Firebase:', error);
    }

    // Expose Firebase functions to global scope for use in main script
    window.firebaseDB = {
      initialized: firebaseInitialized,
      database: database,
      ref: ref,
      set: set,
      onValue: onValue,
      remove: remove,
      update: update,
      push: push,
      onDisconnect: onDisconnect,
      serverTimestamp: serverTimestamp
    };
  </script>
</head>
<body>
  <header>
    <h1>üé≠ <span>Melodrama</span> Werewolf Narrator</h1>
    <div class="actions">
      <div class="audio-controls hidden" id="audio-controls">
        <button id="toggle-audio" type="button" title="Toggle ambient audio">üîá</button>
        <input id="volume-slider" type="range" class="volume-slider" min="0" max="100" value="50" title="Volume" />
        <span class="audio-indicator" id="audio-indicator">
          <span id="audio-phase">Night</span>
        </span>
        <label class="sfx-toggle" title="Sound effects for game events">
          <input type="checkbox" id="sfx-toggle" checked />
          SFX
        </label>
      </div>
      <button id="toggle-mode" type="button" aria-pressed="false">Toggle Dark/Light</button>
      <button id="help-button" type="button">‚ùì Help</button>
      <button id="reset-game" type="button">New Game</button>
      <button id="open-projector" type="button">üìΩÔ∏è Open Projector View</button>
      <a id="download-notes" class="pill" href="#" download="melodrama-notes.txt">Export Notes</a>
    </div>
  </header>

  <main>
    <section id="setup-section">
      <h2>Game Setup</h2>
      <p>Build tonight's cast, assign names, and choose a theme. The tool will auto-balance good and evil roles and guide you through every beat of the drama.</p>

      <!-- Quick Start Presets -->
      <div style="background: var(--bg-secondary); padding: 1.25rem; border-radius: var(--panel-radius); margin-bottom: 1.5rem; border: 2px solid var(--accent-good);">
        <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
          <span style="font-size: 1.5rem;">‚ö°</span>
          <div>
            <strong style="font-size: 1.1rem; color: var(--accent-good);">Quick Start Presets</strong>
            <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">Choose a balanced setup for common class sizes</div>
          </div>
        </div>
        <div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
          <button id="preset-15" type="button" class="preset-button" style="flex: 1; min-width: 150px; padding: 0.75rem 1rem; font-size: 0.95rem;">
            <strong>15 Players</strong>
            <small style="display: block; opacity: 0.8; margin-top: 0.25rem;">~25 min ‚Ä¢ Beginner Friendly</small>
          </button>
          <button id="preset-18" type="button" class="preset-button" style="flex: 1; min-width: 150px; padding: 0.75rem 1rem; font-size: 0.95rem;">
            <strong>18 Players</strong>
            <small style="display: block; opacity: 0.8; margin-top: 0.25rem;">~30 min ‚Ä¢ Most Popular</small>
          </button>
          <button id="preset-21" type="button" class="preset-button" style="flex: 1; min-width: 150px; padding: 0.75rem 1rem; font-size: 0.95rem;">
            <strong>21 Players</strong>
            <small style="display: block; opacity: 0.8; margin-top: 0.25rem;">~35 min ‚Ä¢ Full Class</small>
          </button>
        </div>
        <div id="preset-info" style="margin-top: 1rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px; font-size: 0.9rem; display: none;">
          <span style="color: var(--accent-good);">‚úì</span> <strong>Preset Loaded!</strong> 
          <span id="preset-details"></span>
        </div>
      </div>

      <div class="setup-grid">
        <div class="stat">
          <span>Total Players</span>
          <strong id="player-count-display">18</strong>
          <div class="range-input">
            <input id="player-count" type="range" min="12" max="25" value="18" />
            <div class="stat-grid" style="margin-top:0.5rem;">
              <div>
                <small>Suggested Good</small>
                <div class="pill" id="suggested-good">12</div>
              </div>
              <div>
                <small>Suggested Evil</small>
                <div class="pill" id="suggested-evil">6</div>
              </div>
              <div>
                <small>Est. Time</small>
                <div class="pill" id="estimated-time">~30 min</div>
              </div>
            </div>
          </div>
        </div>

        <div class="stat">
          <span>Theme</span>
          <select id="theme-select" aria-label="Select narration theme"></select>
          <small id="theme-description" style="color:var(--text-secondary);"></small>
        </div>

        <div class="stat">
          <span>Player Names (optional)</span>
          <textarea id="player-names" class="name-list" placeholder="Enter one name per line to assign specific students."></textarea>
          <small style="color:var(--text-secondary);">Names are randomly assigned to roles when you start the game or shuffle.</small>
        </div>
      </div>

      <div class="role-groups" id="role-groups"></div>

      <!-- Shuffle Preview Section -->
      <div id="shuffle-preview" class="hidden" style="margin-top: 1.5rem; padding: 1.25rem; background: rgba(15, 23, 42, 0.5); border-radius: 14px; border: 1px solid rgba(148, 163, 184, 0.25);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <h3 style="margin: 0; font-size: 1.1rem;">üé≤ Player Assignments Preview</h3>
          <button id="shuffle-assignments" type="button" style="padding: 0.5rem 1rem;">üîÄ Shuffle Again</button>
        </div>
        <div id="assignment-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 0.5rem; max-height: 300px; overflow-y: auto;"></div>
      </div>

      <div class="start-footer">
        <div>
          <div class="pill" id="role-balance">Good: 0 ‚Ä¢ Evil: 0 ‚Ä¢ Selected: 0</div>
          <small id="balance-warning" style="display:block; margin-top:0.4rem; color:#fef08a;">Select roles to match the player count.</small>
        </div>
        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
          <button id="preview-shuffle" type="button" disabled style="background: linear-gradient(135deg, rgba(34, 211, 238, 0.7), rgba(56, 189, 248, 0.9));">üé≤ Preview Assignments</button>
          <button id="start-game" type="button" disabled>Enter Narrator View</button>
        </div>
      </div>
    </section>

    <section id="game-section" class="hidden">
      <div class="game-grid">
        <div class="script-panel" aria-live="polite">
          <div>
            <div class="pill" id="phase-label">Setup</div>
            <h2 id="script-title">Narrator Script</h2>
          </div>
          <div id="script-steps" class="script-step"></div>
          <div class="script-nav">
            <button id="prev-step" type="button">Back</button>
            <button id="next-step" type="button">Next</button>
          </div>
        </div>

        <div class="status-panel">
          <div class="timer-card" aria-live="polite">
            <span class="pill" id="timer-phase">Timer</span>
            <div class="timer-display" id="timer-display">03:00</div>
            <div class="timer-controls">
              <button data-timer="180" type="button">3 min</button>
              <button data-timer="60" type="button">1 min</button>
              <button id="start-timer" type="button">Start</button>
              <button id="pause-timer" type="button">Pause</button>
              <button id="reset-timer" type="button">Reset</button>
            </div>
          </div>
          <div class="stat-grid">
            <div class="stat">
              <span>Night</span>
              <strong id="night-number">1</strong>
            </div>
            <div class="stat">
              <span>Alive</span>
              <strong id="alive-count">0</strong>
            </div>
            <div class="stat">
              <span>Team Split</span>
              <div>Good: <strong id="good-count">0</strong></div>
              <div>Evil: <strong id="evil-count">0</strong></div>
            </div>
          </div>
          
          <!-- Game Code for Players -->
          <div class="game-code-card" id="game-code-card">
            <div class="game-code-header">
              <span class="pill">üì± Player Access</span>
              <a href="player.html" target="_blank" class="open-player-link" title="Open player view">Open Player Page ‚Üí</a>
            </div>
            <div class="game-code-display">
              <span class="game-code-label">Game Code:</span>
              <span class="game-code-value" id="game-code-value">----</span>
            </div>
            <small class="game-code-hint">Students can join at <strong>player.html</strong> with this code</small>
            <div class="player-connection-summary" id="player-connection-summary">
              <span class="connection-dot none" id="connection-dot"></span>
              <span class="connection-count" id="connection-count">0/0 players connected</span>
            </div>
          </div>
          
          <div class="stat">
            <span>Notes</span>
            <textarea id="narrator-notes" class="name-list" placeholder="Quick reminders, dramatic twists, or classroom cues."></textarea>
          </div>
        </div>

        <div class="players-panel">
          <div class="pill">Players &amp; Roles</div>
          <div id="player-list" class="player-list"></div>
        </div>
      </div>
    </section>
  </main>

  <!-- Win Modal -->
  <div id="win-modal-overlay" class="modal-overlay">
    <div id="win-modal" class="win-modal">
      <h2 id="win-title">Game Over</h2>
      <div id="win-narration" class="win-modal-narration"></div>
      <div class="win-modal-stats">
        <div class="win-modal-stat">
          <strong id="win-nights">0</strong>
          <span>Nights Played</span>
        </div>
        <div class="win-modal-stat">
          <strong id="win-survivors">0</strong>
          <span>Survivors</span>
        </div>
        <div class="win-modal-stat">
          <strong id="win-eliminated">0</strong>
          <span>Eliminated</span>
        </div>
      </div>
      <div class="win-modal-roles" id="win-roles-list"></div>
      <div class="win-modal-actions">
        <button id="win-new-game" type="button">Play Again</button>
        <button id="win-close" type="button">Continue Viewing</button>
      </div>
    </div>
  </div>

  <!-- Dice Roll Modal -->
  <div id="dice-modal-overlay" class="modal-overlay">
    <div id="dice-modal" class="dice-modal">
      <h2>üé≤ DICE ROLL</h2>
      <div class="dice-modal-character" id="dice-character-name"></div>
      <div class="dice-modal-roll">
        <button id="dice-roll-button" type="button" class="pill">Roll d6</button>
      </div>
      <div id="dice-result-container" style="display: none;">
        <div class="dice-modal-result" id="dice-result">?</div>
        <div class="dice-modal-outcome" id="dice-outcome"></div>
        <div class="dice-modal-description" id="dice-description"></div>
      </div>
      <div class="dice-modal-actions">
        <button id="dice-confirm" type="button" style="display: none;">Confirm</button>
        <button id="dice-cancel" type="button">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="help-modal-overlay" class="modal-overlay">
    <div id="help-modal" class="help-modal">
      <h2>‚ùì Help & Reference</h2>
      
      <div class="help-tabs">
        <button class="help-tab active" data-tab="current">Current Game</button>
        <button class="help-tab" data-tab="all">All Characters</button>
        <button class="help-tab" data-tab="guide">Quick Guide</button>
        <button class="help-tab" data-tab="beginners">Year 7 Tips</button>
        <button class="help-tab" data-tab="shortcuts">Shortcuts</button>
      </div>

      <div id="help-current" class="help-content active">
        <input type="text" class="help-search" id="help-search-current" placeholder="Search current characters..." />
        <div id="current-characters-list" class="character-list"></div>
      </div>

      <div id="help-all" class="help-content">
        <input type="text" class="help-search" id="help-search-all" placeholder="Search all 30 characters..." />
        <div id="all-characters-list" class="character-list"></div>
      </div>

      <div id="help-guide" class="help-content help-guide">
        <h3>Getting Started</h3>
        <ol>
          <li><strong>Setup Phase:</strong> Select characters from each type group (Villain, Accomplice, Elder, Hero, Sidekick, Damsel)</li>
          <li><strong>Balance Check:</strong> Ensure good/evil ratio is appropriate (typically 2:1 good to evil)</li>
          <li><strong>Optional Names:</strong> Enter student names (one per line) to personalize the game</li>
          <li><strong>Choose Theme:</strong> Select narrative flavor for dramatic flair</li>
          <li><strong>Enter Narrator View:</strong> Begin the game!</li>
        </ol>

        <h3>Night Phase</h3>
        <ol>
          <li>Follow script prompts step by step</li>
          <li>Call each character type in order (Villains ‚Üí Accomplices ‚Üí Elders ‚Üí Heroes ‚Üí Sidekicks)</li>
          <li>Use Action Tracker to record night actions</li>
          <li>Click "Calculate Night Resolution" to see results</li>
          <li>Update player status (eliminate, protect) as needed</li>
        </ol>

        <h3>Day Phase</h3>
        <ol>
          <li>Announce night eliminations dramatically</li>
          <li>Sidekicks may use day powers (dice roll required: 4-6 = success)</li>
          <li>Start discussion timer (3 minutes recommended)</li>
          <li>Facilitate voting (use Vote Tracker for counting)</li>
          <li>Handle special mechanics (Corrupted Authority √ó2, Manipulator silence, revotes)</li>
          <li>Check for win conditions</li>
        </ol>

        <h3>Win Conditions</h3>
        <ul>
          <li><strong>Good Wins:</strong> All evil players eliminated</li>
          <li><strong>Evil Wins:</strong> Evil ‚â• Good (e.g., 6 evil + 6 good = evil wins)</li>
          <li>Check after every elimination (night and day)</li>
        </ul>

        <h3>Character Types</h3>
        <ul>
          <li><strong>Villain-Type (EVIL):</strong> Wake together in Step 1 to choose target</li>
          <li><strong>Accomplice-Type (EVIL):</strong> One-off tricks to help villains</li>
          <li><strong>Elder-Type (GOOD):</strong> Information gathering (never kill/save)</li>
          <li><strong>Hero-Type (GOOD):</strong> Defensive powers to protect players</li>
          <li><strong>Sidekick-Type (GOOD):</strong> Risky day powers with dice rolls</li>
          <li><strong>Damsel-Type (GOOD):</strong> Day phase twists and dramatic reveals</li>
        </ul>
      </div>

      <div id="help-beginners" class="help-content help-guide">
        <h3>üé≠ Tips for Year 7 Students</h3>
        
        <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 12px; margin-bottom: 1.5rem; border-left: 4px solid var(--accent-good);">
          <strong>‚ú® Quick Start:</strong> Use the Quick Start Presets on the setup screen! Choose "15 Players - Beginner Friendly" for your first game. It takes ~25 minutes and uses simpler characters.
        </div>

        <h3>üé¨ Making It Fun & Engaging</h3>
        <ul>
          <li><strong>Encourage Big Acting:</strong> Remind students to be dramatic! Over-the-top reactions make the game memorable</li>
          <li><strong>Use Themes:</strong> Try different themes (Haunted House, Space Station) to keep it fresh</li>
          <li><strong>Practice Rounds:</strong> Run a quick 12-player game first so students learn the flow</li>
          <li><strong>Death Scenes:</strong> Let eliminated players do a 10-second dramatic exit</li>
        </ul>

        <h3>‚è±Ô∏è Keeping It Quick</h3>
        <ul>
          <li><strong>Set Time Limits:</strong> Use the 3-minute timer for discussion - it keeps momentum</li>
          <li><strong>Skip Complex Characters:</strong> First game? Avoid: Stalker, Guardian, Defender, Cursed, Twins</li>
          <li><strong>Simplified Script:</strong> You don't need to read everything - paraphrase the SAY blocks</li>
          <li><strong>Pre-assign Seats:</strong> Have students sit in a circle before starting</li>
        </ul>

        <h3>üéØ Common Challenges & Solutions</h3>
        <ul>
          <li><strong>"Students are confused":</strong> Remind them their character card tells them everything - they just follow instructions</li>
          <li><strong>"Too chaotic during voting":</strong> Use "Point on 3!" and count quickly - don't let debates drag on</li>
          <li><strong>"Evil is winning too much":</strong> Add one more Hero-type (like Healer or Champion)</li>
          <li><strong>"Game is too long":</strong> Start with 15 players maximum, use simpler characters</li>
          <li><strong>"Students peeking":</strong> Emphasize the drama depends on everyone playing fair</li>
        </ul>

        <h3>‚úÖ Best Practices</h3>
        <ul>
          <li><strong>First 5 Minutes:</strong> Explain win conditions clearly (Good = eliminate all evil, Evil = equal numbers)</li>
          <li><strong>Visual Reminders:</strong> Use the projector view so students can see the phase and timer</li>
          <li><strong>Celebrate Wins:</strong> Make a big deal of the winning team - applause and dramatic bows!</li>
          <li><strong>Debrief:</strong> Spend 3 minutes at the end discussing best moments and performances</li>
        </ul>

        <h3>üåü Recommended Character Sets</h3>
        <p><strong>15 Players - Safest Bet:</strong></p>
        <ul style="list-style-type: none; padding-left: 0;">
          <li>üëø Evil: Evil Mastermind, Assassin, Pretender, Right Hand, Spy</li>
          <li>üòá Good: Sage, Oracle, Champion, Healer, Loyal Companion, Voice, Marked, Innocent, Twin A, Twin B</li>
        </ul>

        <p><strong>18 Players - More Variety:</strong></p>
        <ul style="list-style-type: none; padding-left: 0;">
          <li>üëø Evil: Evil Mastermind, Assassin, Pretender, Corrupted Authority, Right Hand, Manipulator</li>
          <li>üòá Good: Sage, Oracle, Sensitive, Champion, Healer, Loyal Companion, Voice, Marked, Innocent, Twin A, Twin B, Cursed</li>
        </ul>
      </div>

      <div id="help-shortcuts" class="help-content">
        <div class="keyboard-shortcuts">
          <div class="shortcut-item">
            <span>Show this help</span>
            <span class="shortcut-key">?</span>
          </div>
          <div class="shortcut-item">
            <span>Start 3-minute timer</span>
            <span class="shortcut-key">T</span>
          </div>
          <div class="shortcut-item">
            <span>Reset timer</span>
            <span class="shortcut-key">R</span>
          </div>
          <div class="shortcut-item">
            <span>Next script step</span>
            <span class="shortcut-key">Space</span>
          </div>
          <div class="shortcut-item">
            <span>Close modal</span>
            <span class="shortcut-key">Esc</span>
          </div>
        </div>
        <p style="margin-top: 1.5rem; color: var(--text-secondary); font-size: 0.9rem;">
          Note: Some keyboard shortcuts are planned but not yet fully implemented.
        </p>
      </div>

      <div class="help-modal-actions">
        <button id="help-close" type="button">Close</button>
      </div>
    </div>
  </div>

  <!-- Quick Reference Panel -->
  <button id="quick-ref-toggle" class="quick-ref-toggle hidden">üìã Quick Ref</button>
  <div id="quick-ref-panel" class="quick-ref-panel">
    <div class="quick-ref-header">
      <h3>üìã Quick Reference</h3>
      <button class="quick-ref-close" id="quick-ref-close" type="button">&times;</button>
    </div>
    <div class="quick-ref-content">
      <div class="quick-ref-section">
        <h4>üåô Night Order</h4>
        <div id="quick-ref-night-order">
          <div class="quick-ref-order"><span class="step-num">1</span> Villains - Choose target</div>
          <div class="quick-ref-order"><span class="step-num">2</span> Accomplices - Special actions</div>
          <div class="quick-ref-order"><span class="step-num">3</span> Elders - Information gathering</div>
          <div class="quick-ref-order"><span class="step-num">4</span> Heroes - Protections</div>
          <div class="quick-ref-order"><span class="step-num">5</span> Sidekicks - Prepare day powers</div>
        </div>
      </div>
      
      <div class="quick-ref-section">
        <h4>‚ö° Active Abilities This Game</h4>
        <ul class="quick-ref-list" id="quick-ref-abilities">
          <li><em>Start a game to see active abilities</em></li>
        </ul>
      </div>
      
      <div class="quick-ref-section">
        <h4>üìñ Cheat Sheet</h4>
        <div class="quick-ref-cheat">
          <h5>üéØ Stalker Backup Kill</h5>
          <p>If the primary villain target survives (was protected), Stalker can attempt a backup kill. Only works on Damsel or Elder types.</p>
        </div>
        <div class="quick-ref-cheat">
          <h5>üëØ Twin Death Link</h5>
          <p>When one Twin dies (A or B), the other immediately dies too. Both must perform death scenes!</p>
        </div>
        <div class="quick-ref-cheat">
          <h5>üíÄ Cursed Explosion</h5>
          <p>When The Cursed dies, random players also die based on game size:
          <br>‚Ä¢ &lt;12 players: 1 victim
          <br>‚Ä¢ 12-17 players: 2 victims
          <br>‚Ä¢ 18-23 players: 3 victims
          <br>‚Ä¢ 24+ players: 4 victims
          <br>Each victim has 1-in-3 chance to be Evil!</p>
        </div>
        <div class="quick-ref-cheat">
          <h5>üõ°Ô∏è Champion Power Loss</h5>
          <p>Champion protects every night. First time protection triggers: both survive, Champion learns a villain's identity, but loses power permanently.</p>
        </div>
        <div class="quick-ref-cheat">
          <h5>üé≤ Sidekick Day Powers</h5>
          <p>During day phase, Sidekicks can activate powers with dice roll: 4-6 = Success, 1-3 = Failure. One use per day.</p>
        </div>
      </div>
    </div>
  </div>

  <template id="player-card-template">
    <article class="player-card" data-status="alive" data-connected="false">
      <header>
        <div>
          <div class="player-name"></div>
          <div class="player-meta">
            <span class="player-role-info"></span>
            <span class="player-connection-indicator disconnected">
              <span class="status-dot"></span>
              <span class="status-text">Offline</span>
            </span>
          </div>
        </div>
        <span class="badge"></span>
      </header>
      <p class="player-ability"></p>
      <div class="player-actions">
        <button data-action="toggle-eliminated" type="button">Toggle Eliminated</button>
        <button data-action="toggle-protected" type="button">Toggle Protected</button>
      </div>
      <textarea class="player-notes" placeholder="Add notes for this player"></textarea>
    </article>
  </template>

  <!-- Shared Character Data - Single source of truth for all 30 characters -->
  <script src="characters.js"></script>
  
  <script>
    // CHARACTERS and TYPE_DETAILS are now loaded from characters.js
    // Log confirmation that shared data is being used
    if (typeof CHARACTERS !== 'undefined' && CHARACTERS.length === 30) {
      console.log('‚úì characters.js loaded successfully with', CHARACTERS.length, 'characters');
    } else {
      console.error('‚úó characters.js failed to load or contains wrong number of characters');
    }

    const THEMES = {
      village: {
        name: "Classic Village",
        description: "Foggy streets, flickering lanterns, and suspicious glances.",
        visual: {
          background: "radial-gradient(circle at top, rgba(139, 92, 46, 0.15), transparent 60%), linear-gradient(180deg, #1a1410 0%, #2d1b0e 100%)",
          accentColor: "#d97706",
          textGlow: "0 0 10px rgba(217, 119, 6, 0.3)",
          cardBackground: "rgba(41, 37, 36, 0.6)",
          animation: "flicker 3s ease-in-out infinite",
          fontFamily: "'Georgia', 'Times New Roman', serif",
          buttonGradient: "linear-gradient(135deg, #d97706, #b45309)",
          buttonRadius: "8px",
          texture: "repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(217, 119, 6, 0.03) 2px, rgba(217, 119, 6, 0.03) 4px)"
        },
        audio: {
          night: "audio/village-night.mp3",
          day: "audio/village-day.mp3"
        },
        script: {
          nightIntro: "The fog rolls through the cobblestone streets as the village descends into darkness. The lanterns flicker and fade... The clock tower strikes midnight. Villagers, bow your heads and close your eyes. Let your shoulders slump in peaceful slumber as shadows begin to stir...",
          nightEnds: "The clock tower strikes dawn! The fog begins to lift... Villagers, open your eyes slowly and look around the square...",
          dayIntro: "A rooster crows! The morning sun pierces through the fog. Open your eyes slowly, stretching awake. Look around with weary suspicion - who among you seems... different today?",
          noDeaths: "By some miracle, the village remains whole. Exchange looks of exhausted relief, but remember - the beast still lurks among you. No one is safe. Tomorrow may tell a different tale...",
          deaths: victim => `A scream echoes through the village square! Gather around... we have lost ${victim}. The tragedy is immense - let your grief pour forth!`,
          vote: "The village mob gathers! Whispered accusations grow to shouts. On the count of three, raise your arm and point with righteous fury to the one you believe must face justice! One... two... THREE!",
          deathScene: "Clutch your heart, stagger backward, and collapse dramatically! Reach toward the sky as you fall. The village watches in horror!",
          evilCall: "Exchange knowing glances. Let a subtle, wicked smile cross your lips. You are the wolves among sheep.",
          accusationPrompt: "The village elders demand answers! Who among you dares to make an accusation?",
          discussionPrompt: "Speak in hushed, suspicious tones. Point fingers with trembling accusation. The village square rings with melodrama!",
          protectionCue: "A guardian watches from the shadows, ready to sacrifice all for the innocent...",
          villainVictoryTease: "The darkness grows stronger. Soon the village will fall to shadows eternal...",
          goodWins: "The fog lifts! The sun breaks through the clouds at last! The wolves have been driven from the village forever! The church bells ring in celebration! REJOICE, good villagers, for peace has returned to your streets! Take a bow, heroes of the village!",
          evilWins: "Darkness descends upon the village forever! The wolves howl in triumph as the last lantern flickers out! The village square falls silent... for there are none left to speak. The shadows have WON! Evil villains, take your victory bow as the village crumbles!"
        }
      },
      mansion: {
        name: "Millionaire's Mansion",
        description: "Champagne towers, hidden wills, and backstabbing at the gala.",
        visual: {
          background: "radial-gradient(circle at center, rgba(234, 179, 8, 0.12), transparent 70%), linear-gradient(180deg, #1c1917 0%, #292524 100%)",
          accentColor: "#eab308",
          textGlow: "0 0 12px rgba(234, 179, 8, 0.4)",
          cardBackground: "rgba(68, 64, 60, 0.5)",
          animation: "shimmer 4s ease-in-out infinite",
          fontFamily: "'Playfair Display', 'Didot', serif",
          buttonGradient: "linear-gradient(135deg, #eab308, #ca8a04)",
          buttonRadius: "4px",
          texture: "repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(234, 179, 8, 0.02) 10px, rgba(234, 179, 8, 0.02) 20px)"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "The grandfather clock chimes eleven... The chandelier dims as servants extinguish the candelabras. Guests at the gala retire to their luxurious rooms. Silk robes rustle, champagne glasses are set aside. Close your eyes, wealthy inheritors, as the mansion falls silent... except for footsteps in the hidden passages...",
          nightEnds: "The grandfather clock chimes morning! Sunlight streams through the velvet curtains... Wake slowly, wealthy heirs, and check your surroundings...",
          dayIntro: "The butler rings the breakfast bell! Wake to the smell of coffee and croissants - but wait... is someone missing from the dining table? Cast suspicious glances at the empty chair, then at each other...",
          noDeaths: "Against all odds, every heir survived the night. Raise your crystal glasses in mock celebration, but trust no one - the will is still contested, and the fortune still up for grabs.",
          deaths: victim => `The butler clears his throat: 'It pains me to inform you... ${victim} won't be attending breakfast. They've been... permanently removed from the will.' Gasp in exaggerated shock!`,
          vote: "The family lawyer demands a vote! The inheritance hangs in the balance. On three, point your manicured finger at the relative you wish to... disinherit! One... two... THREE!",
          deathScene: "Clutch your pearls! Swoon onto the nearest fainting couch. Die with your pinky extended, as befits high society!",
          evilCall: "Raise an eyebrow of superiority. Swirl an imaginary glass of expensive wine. You will have the fortune - by any means necessary.",
          accusationPrompt: "The family lawyer clears his throat! Who wishes to make a formal accusation against a fellow heir?",
          discussionPrompt: "Speak with cut-glass accents and barely concealed venom. Money is on the line!",
          protectionCue: "A loyal servant moves silently, ready to take a bullet for their master...",
          villainVictoryTease: "The fortune grows closer. Soon, the entire estate will be yours...",
          goodWins: "The will is SAVED! The true heirs stand triumphant as the family lawyer unseals the final testament! The fortune goes to the RIGHTEOUS! Pop the champagne and raise your glasses - the mansion belongs to those with honor! Take your well-deserved bow, noble heirs!",
          evilWins: "The will is YOURS! The mansion doors slam shut on the last honest relative! The fortune, the estate, the POWER - all belong to the schemers now! Raise your crystal goblets in wicked celebration! The high society villains have WON! Take your diabolical bow!"
        }
      },
      haunted: {
        name: "Haunted House",
        description: "Thunder cracks, portraits watch, and secrets lurk in every corridor.",
        visual: {
          background: "radial-gradient(ellipse at bottom, rgba(124, 58, 237, 0.2), transparent 60%), linear-gradient(180deg, #0a0118 0%, #1e0b37 100%)",
          accentColor: "#a855f7",
          textGlow: "0 0 15px rgba(168, 85, 247, 0.5)",
          cardBackground: "rgba(30, 11, 55, 0.7)",
          animation: "pulse 2s ease-in-out infinite",
          fontFamily: "'Creepster', 'Courier New', monospace",
          buttonGradient: "linear-gradient(135deg, #a855f7, #7c3aed)",
          buttonRadius: "12px",
          texture: "radial-gradient(circle at 20% 50%, transparent 0%, rgba(168, 85, 247, 0.05) 100%), radial-gradient(circle at 80% 80%, transparent 0%, rgba(168, 85, 247, 0.05) 100%)"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "Thunder CRASHES! The lights flicker... once... twice... and die. In the darkness, the grandfather clock strikes thirteen. Spirits trapped in this cursed mansion, close your eyes. Let your heads fall forward. Feel the cold draft creeping through the halls as spectral forces awaken...",
          nightEnds: "A single candle flickers to life! The spirits grow quiet... Open your eyes slowly and peer into the shadows...",
          dayIntro: "Lightning illuminates the parlor! Wake with a start - gasp as if shaken from a nightmare! Look around the dusty room... The portraits on the wall seem to have moved. Someone is... missing from this s√©ance...",
          noDeaths: "The spirits were restless but claimed no victims tonight. Sigh with ghostly relief - but the mansion still holds its dark secrets. The next night may not be so merciful...",
          deaths: victim => `A bloodcurdling scream echoes through the halls! The s√©ance reveals the terrible truth... ${victim} has joined the spirits forever. Their ghost now walks these corridors!`,
          vote: "The surviving souls must perform a banishment ritual! On three, point with trembling finger to the entity you wish to exorcise! One... two... THREE!",
          deathScene: "Float backward as if lifted by invisible hands! Wail a ghostly lament as you fade into the spirit realm! The mansion claims another soul!",
          evilCall: "Let your eyes gleam with otherworldly malevolence. You are the darkness that feeds on fear. Move with supernatural stillness.",
          accusationPrompt: "The s√©ance table trembles! Who among you senses a dark presence? Speak now!",
          discussionPrompt: "Whisper fearfully, jumping at every creak. Accuse with trembling voices and point with shaking fingers!",
          protectionCue: "A protective spirit watches over you, their ethereal form a shield against the darkness...",
          villainVictoryTease: "The veil between worlds grows thin. Soon, all souls shall belong to the darkness...",
          goodWins: "The s√©ance is COMPLETE! The protective spirits RISE in blinding light! The darkness SCREAMS as it is banished forever! The haunted house falls silent... peaceful at last! The living have prevailed! Take your triumphant bow as the ghosts fade away!",
          evilWins: "The mansion is OURS! The spirits of darkness spread through every corridor! The last flicker of hope is extinguished! Eternal night falls upon this cursed place! The evil entities cackle in unholy triumph! Take your spectral victory bow!"
        }
      },
      castle: {
        name: "Castle Tower",
        description: "Medieval intrigue, throne room conspiracies, and royal betrayals.",
        visual: {
          background: "radial-gradient(circle at top, rgba(71, 85, 105, 0.2), transparent 65%), linear-gradient(180deg, #1e293b 0%, #334155 100%)",
          accentColor: "#64748b",
          textGlow: "0 0 8px rgba(100, 116, 139, 0.3)",
          cardBackground: "rgba(51, 65, 85, 0.6)",
          animation: "none",
          fontFamily: "'Cinzel', 'Trajan Pro', serif",
          buttonGradient: "linear-gradient(135deg, #64748b, #475569)",
          buttonRadius: "0px",
          texture: "repeating-linear-gradient(0deg, rgba(100, 116, 139, 0.03), rgba(100, 116, 139, 0.03) 1px, transparent 1px, transparent 3px), repeating-linear-gradient(90deg, rgba(100, 116, 139, 0.03), rgba(100, 116, 139, 0.03) 1px, transparent 1px, transparent 3px)"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "The drawbridge rises with a thunderous groan. Torches are extinguished one by one. In the stone corridors, only shadows move. Noble knights and scheming courtiers, close your eyes and bow your heads. The king sleeps... but treachery never rests within these ancient walls...",
          nightEnds: "The royal trumpet sounds from the tower! Dawn breaks over the kingdom... Open thy eyes and gather in the great hall...",
          dayIntro: "Trumpets sound! Arise, members of the royal court! Gather in the great hall - but count your numbers... is the throne room missing a familiar face? Look upon each other with suspicion most royal!",
          noDeaths: "By the crown's mercy, all subjects survived the night. Exchange formal bows, but keep one hand on your sword hilt. The conspirators still lurk within the court.",
          deaths: victim => `Hear ye, hear ye! Tragedy befalls the kingdom! ${victim} has fallen to dark treachery! Let the mourning bells toll, and prepare a funeral most grand!`,
          vote: "The royal court demands justice! Knights, nobles, and courtiers - on three, raise thy sword-arm and point to the traitor among us! For the realm! One... two... THREE!",
          deathScene: "Fall to your knees, clutch your royal garments, and cry 'FOR THE KINGDOM!' as you collapse! Die with honor and theatrical flourish!",
          evilCall: "Let your lip curl with aristocratic contempt. You scheme for the throne. Exchange knowing glances with your fellow conspirators.",
          accusationPrompt: "The royal herald demands order! Who wishes to bring charges before the court?",
          discussionPrompt: "Speak in formal, dramatic tones! 'I accuse thee, villain!' Point with righteous medieval fury!",
          protectionCue: "A loyal knight stands guard, sword drawn, ready to defend the innocent...",
          villainVictoryTease: "The throne grows closer. Soon, the crown shall rest upon your treacherous brow...",
          goodWins: "FOR THE KINGDOM! The conspirators are VANQUISHED! The true monarch sits upon the throne once more! The royal trumpets sound in glorious fanfare! Long live the righteous rulers! Take your noble bow before the court!",
          evilWins: "THE THRONE IS OURS! The crown falls into treacherous hands! The kingdom descends into shadow as the usurpers rise to power! The drawbridge slams shut on justice forever! Evil conspirators, take your royal victory bow!"
        }
      },
      theatre: {
        name: "Magic Show / Theatre",
        description: "Spotlights, trapdoors, and illusions gone deadly.",
        visual: {
          background: "radial-gradient(circle at center, rgba(239, 68, 68, 0.15), rgba(234, 179, 8, 0.1), transparent 70%), linear-gradient(180deg, #18181b 0%, #27272a 100%)",
          accentColor: "#f59e0b",
          textGlow: "0 0 20px rgba(245, 158, 11, 0.6)",
          cardBackground: "rgba(39, 39, 42, 0.7)",
          animation: "spotlight 5s ease-in-out infinite",
          fontFamily: "'Lobster', 'Brush Script MT', cursive",
          buttonGradient: "linear-gradient(135deg, #f59e0b, #dc2626)",
          buttonRadius: "25px",
          texture: "radial-gradient(circle at 50% 50%, rgba(245, 158, 11, 0.1) 0%, transparent 50%), repeating-conic-gradient(from 0deg at 50% 50%, transparent 0deg, rgba(245, 158, 11, 0.02) 15deg, transparent 30deg)"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "The stage lights fade to black. The orchestra plays its final note. Behind the velvet curtain, the performers take their places... Close your eyes, theatre stars. The intermission has begun... but backstage, deadly games are played in darkness...",
          nightEnds: "The spotlight flickers back to life! The orchestra tunes up... Open your eyes, performers, and check the stage...",
          dayIntro: "The spotlight BLAZES! Strike a pose - the show must go on! But wait... scan the dressing rooms... someone missed their call! Their costume hangs empty! What drama unfolds?!",
          noDeaths: "Miraculous! Every performer survived the night. Take a theatrical bow - but remember, in show business, the understudy is always waiting in the wings...",
          deaths: victim => `The director speaks: 'I regret to announce... ${victim} gave their FINAL performance last night. The theatre has lost a star!' Let the mourning be DRAMATIC!`,
          vote: "Center stage, everyone! The audience of your peers demands justice! On three, point with theatrical grandeur to the villain of this drama! Places everyone! One... two... THREE!",
          deathScene: "This is your FINAL bow! Clutch the curtain as you fall! Reach for the spotlight! Let your last words echo through the rafters! Exit... stage FOREVER!",
          evilCall: "You are the villain of this opera! Twirl an imaginary mustache. Let your stage presence ooze menace and theatrical evil!",
          accusationPrompt: "The director calls for silence! Who wishes to improvise an accusation scene?",
          discussionPrompt: "Project from the diaphragm! Make accusations with operatic intensity! Gesture grandly - this is THEATRE!",
          protectionCue: "A stagehand lurks in the shadows, ready to pull their ally through the trapdoor to safety...",
          villainVictoryTease: "The final act approaches. Soon, you alone will take the standing ovation...",
          goodWins: "STANDING OVATION! The villains of this drama take their final bow - off stage FOREVER! The theatre rings with applause! The show has been SAVED! Heroes of the stage, bask in the spotlight and take your triumphant curtain call!",
          evilWins: "THE SHOW IS OURS! The curtain falls on the last honest performer! The theatre belongs to the villains now! Let the audience weep as evil takes center stage! Diabolical performers, take your grand finale bow!"
        }
      },
      space: {
        name: "Space Station",
        description: "Red alerts, mysterious airlocks, and dramatic zero-g reveals.",
        visual: {
          background: "radial-gradient(circle at center, rgba(6, 182, 212, 0.2), rgba(34, 211, 238, 0.1), transparent 75%), linear-gradient(180deg, #020617 0%, #0c4a6e 100%)",
          accentColor: "#22d3ee",
          textGlow: "0 0 18px rgba(34, 211, 238, 0.7)",
          cardBackground: "rgba(12, 74, 110, 0.5)",
          animation: "tech-glow 3s ease-in-out infinite",
          fontFamily: "'Orbitron', 'Consolas', monospace",
          buttonGradient: "linear-gradient(135deg, #22d3ee, #0891b2)",
          buttonRadius: "2px",
          texture: "repeating-linear-gradient(0deg, rgba(34, 211, 238, 0.02) 0px, transparent 1px, transparent 2px, rgba(34, 211, 238, 0.02) 3px), repeating-linear-gradient(90deg, rgba(34, 211, 238, 0.02) 0px, transparent 1px, transparent 2px, rgba(34, 211, 238, 0.02) 3px)"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "ALERT: Initiating station-wide sleep cycle. The oxygen levels stabilize as the artificial lights dim to emergency blue. The hum of the life support systems fills the corridors. Crew members, close your eyes and enter stasis mode. But in the maintenance shafts, something stirs...",
          nightEnds: "ALERT: Stasis cycle complete. Station lights returning to normal... Crew, open your eyes and report to the command deck...",
          dayIntro: "ALERT: Sleep cycle complete. Station lights activate! Stretch in your zero-gravity pods and float to the command deck. Check the life sign monitors... WARNING: Crew member offline! Someone has been... spaced!",
          noDeaths: "ALERT: All crew vitals stable. The station survived another rotation. Exchange relieved salutes - but the saboteur still moves among you. The next cycle may not be so fortunate.",
          deaths: victim => `CRITICAL ALERT: Life signs terminated! ${victim} has been... jettisoned into the void. A moment of silence as we watch their form drift into the infinite darkness of space...`,
          vote: "EMERGENCY PROTOCOL: Crew must identify the imposter! On three, aim your targeting sensors - I mean, FINGERS - at the suspected saboteur! Coordinates locked! One... two... THREE!",
          deathScene: "Clutch your helmet! Gasp for oxygen! Float in slow-motion as you drift toward the airlock! 'Tell my family... I... was a good astronaut...' WHOOOOSH into space!",
          evilCall: "Your optical sensors glow with calculated malice. You are the virus in the system. Process your next elimination with cold, mechanical precision.",
          accusationPrompt: "EMERGENCY PROTOCOL ACTIVATED: Crew members, submit your suspect analysis!",
          discussionPrompt: "Speak in robotic, precise tones! 'Probability analysis suggests you are the saboteur!' Point with technical authority!",
          protectionCue: "The emergency force field activates around a crew member, deflecting the saboteur's attack...",
          villainVictoryTease: "Systems failing. Soon, you will be the only signal broadcasting from this dead station...",
          goodWins: "MISSION SUCCESSFUL! The saboteurs have been JETTISONED into the void! The station systems stabilize! ALERT: All remaining crew vitals... STABLE! Float in zero-gravity celebration! The station is SAVED! Take your heroic bow, brave crew!",
          evilWins: "CRITICAL FAILURE! The station is OURS! The last loyal crew member drifts into the infinite darkness! System override COMPLETE! The saboteurs control everything now! Take your mechanical victory bow as the station falls silent!"
        }
      },
      western: {
        name: "Wild West Town",
        description: "Dusty saloons, high noon showdowns, and outlaws in the shadows.",
        visual: {
          background: "radial-gradient(circle at top, rgba(161, 98, 7, 0.2), transparent 60%), linear-gradient(180deg, #292524 0%, #44403c 100%)",
          accentColor: "#d97706",
          textGlow: "0 0 10px rgba(217, 119, 6, 0.4)",
          cardBackground: "rgba(68, 64, 60, 0.6)",
          animation: "dust 6s ease-in-out infinite",
          fontFamily: "'Rye', 'Rockwell', serif",
          buttonGradient: "linear-gradient(135deg, #92400e, #78350f)",
          buttonRadius: "6px",
          texture: "repeating-linear-gradient(45deg, transparent, transparent 5px, rgba(217, 119, 6, 0.02) 5px, rgba(217, 119, 6, 0.02) 10px), repeating-linear-gradient(-45deg, transparent, transparent 5px, rgba(217, 119, 6, 0.02) 5px, rgba(217, 119, 6, 0.02) 10px)"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "The saloon piano falls silent. Tumbleweeds roll past the empty main street as the desert sun sets in a blaze of orange. The last candle in the window flickers out. Cowboys and outlaws, tip your hats over your eyes. The frontier sleeps... but bandits ride under the cover of darkness...",
          nightEnds: "The rooster crows in the distance! The desert sun peeks over the horizon... Wake up, partners, and check the town square...",
          dayIntro: "YEEHAW! The rooster crows and the sun blazes over the dusty town! Tip back your cowboy hats, stretch those spurs, and mosey on down to the saloon. But hold on, partner... someone ain't made it to breakfast. Check the Wanted posters...",
          noDeaths: "Well I'll be hornswoggled! Every varmint in town survived the night! Raise your sarsaparillas in celebration - but keep one hand on your holster. The outlaws are still out there...",
          deaths: victim => `The Sheriff speaks: 'Folks, I've got some bad news... ${victim} bit the dust last night. This town ain't big enough for outlaws AND honest folk. Let's have a moment of silence... then a LOUD death scene!'`,
          vote: "HIGH NOON! The townfolk gather in the dusty square! On three, draw your pointing finger like a six-shooter and AIM at the varmint you reckon's the outlaw! One... two... DRAW!",
          deathScene: "Clutch your heart! Stagger backward through the saloon doors! Collapse in the dusty street! 'They... got me, partner...' *THUD*",
          evilCall: "Squint like a desperado. Chew an imaginary piece of straw. You're the meanest outlaw this side of the Rio Grande.",
          accusationPrompt: "The Sheriff calls fer order! Who's got a bone to pick with someone in this here town?",
          discussionPrompt: "Speak in your best Wild West drawl! 'I reckon you're the varmint we're lookin' fer!' Point accusingly!",
          protectionCue: "A loyal deputy stands guard, hand on holster, ready to take a bullet for the innocent...",
          villainVictoryTease: "The gold is almost yours. Soon, this town will belong to the outlaws...",
          goodWins: "YEEHAW! The outlaws have been RUN OUT OF TOWN! The sheriff hangs up their spurs in triumph! The saloon piano plays a victorious tune! This town is SAFE once more, partners! Tip your cowboy hats and take your heroic bow!",
          evilWins: "The town is OURS, partners! The last honest deputy bites the dust! The outlaws ride into the sunset with ALL the gold! This here's BANDIT territory now! Take your outlaw victory bow, ye varmints!"
        }
      },
      pirate: {
        name: "Pirate Harbour",
        description: "Treasure maps, plank-walking, and mutiny on the high seas.",
        visual: {
          background: "radial-gradient(circle at bottom, rgba(14, 116, 144, 0.25), transparent 65%), linear-gradient(180deg, #0c4a6e 0%, #164e63 100%)",
          accentColor: "#06b6d4",
          textGlow: "0 0 12px rgba(6, 182, 212, 0.5)",
          cardBackground: "rgba(22, 78, 99, 0.6)",
          animation: "wave 4s ease-in-out infinite",
          fontFamily: "'Pirata One', 'Brush Script MT', cursive",
          buttonGradient: "linear-gradient(135deg, #06b6d4, #0e7490)",
          buttonRadius: "18px",
          texture: "repeating-linear-gradient(120deg, transparent 0px, rgba(6, 182, 212, 0.03) 2px, transparent 4px, transparent 8px), repeating-linear-gradient(60deg, transparent 0px, rgba(6, 182, 212, 0.03) 2px, transparent 4px, transparent 8px)"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "Avast, ye scallywags! The moon rises over the Caribbean as the ship rocks in the harbor. Below deck, hammocks sway in the darkness. Close yer eyes, ye sea dogs, and let the waves rock ye to sleep. But above deck, conspirators gather under the Jolly Roger...",
          nightEnds: "The ship's bell rings across the harbor! The sun rises over the Caribbean... Wake up, ye sea dogs, and report to the deck!",
          dayIntro: "ALL HANDS ON DECK! The sun blazes over the harbor! Rise from yer hammocks, ye bilge rats! Check the crew manifest... by Davy Jones' locker... someone's MISSING from the deck! Who's been fed to the sharks?!",
          noDeaths: "Shiver me timbers! Every scurvy dog survived the night! Raise yer grog in celebration - but keep one eye on the horizon. The mutineers still sail among us...",
          deaths: victim => `Gather 'round, ye salty sea dogs! Last night, ${victim} walked the plank! The sharks had themselves a feast! Give us one final 'ARRRRR!' before ye sink beneath the waves!`,
          vote: "MUTINY TIME, me hearties! The crew must decide who gets fed to the fishes! On three, point yer cutlass - I mean, FINGER - at the traitor! Ready... aim... ARRR!",
          deathScene: "Walk the plank with pirate swagger! 'Tell me mum... I found the treasure...' Then SPLASH into Davy Jones' locker! ARRRRR!",
          evilCall: "Flash yer golden tooth! You're the mutineers, seeking to steal the treasure and maroon the crew. Exchange knowing 'arrrrs' of villainy.",
          accusationPrompt: "The Captain demands order on deck! Who wants to accuse a fellow sailor of mutiny?",
          discussionPrompt: "Speak in yer best pirate accent! 'I accuse ye of mutiny, ye scurvy dog!' Wave yer hook hand dramatically!",
          protectionCue: "A loyal first mate stands ready to take a cannonball for their captain...",
          villainVictoryTease: "The treasure grows closer. Soon, the ship will sail under YOUR black flag...",
          goodWins: "YO HO HO! The mutineers have been FED TO THE FISHES! The loyal crew stands victorious on the deck! The treasure belongs to the HONEST sailors! Raise the sails and sound the cannons in celebration! Take your heroic bow, ye brave sea dogs! ARRRRR!",
          evilWins: "THE SHIP IS OURS, me hearties! The last loyal sailor walks the plank! The Jolly Roger flies high as the mutineers claim the treasure! These waters belong to the PIRATES now! Take your villainous bow, ye scurvy dogs! ARRRRR!"
        }
      },
      hospital: {
        name: "Soap Opera Hospital",
        description: "Medical drama, secret diagnoses, and relationship scandals.",
        visual: {
          background: "radial-gradient(circle at top, rgba(56, 189, 248, 0.15), rgba(255, 255, 255, 0.05), transparent 70%), linear-gradient(180deg, #f8fafc 0%, #e2e8f0 100%)",
          accentColor: "#0ea5e9",
          textGlow: "0 0 10px rgba(14, 165, 233, 0.3)",
          cardBackground: "rgba(226, 232, 240, 0.8)",
          animation: "heartbeat 2s ease-in-out infinite",
          fontFamily: "'Montserrat', 'Helvetica Neue', sans-serif",
          buttonGradient: "linear-gradient(135deg, #0ea5e9, #0284c7)",
          buttonRadius: "20px",
          texture: "repeating-linear-gradient(0deg, transparent, transparent 10px, rgba(14, 165, 233, 0.02) 10px, rgba(14, 165, 233, 0.02) 11px)"
        },
        audio: {
          night: null,
          day: null
        },
        script: {
          nightIntro: "The hospital PA system crackles: 'Visiting hours are over.' The fluorescent lights dim to night mode. In the corridors, only the beeping of heart monitors breaks the silence. Close your eyes, doctors, nurses, and patients. Rest now... but in the darkened wards, someone writes a FATAL prescription...",
          nightEnds: "The PA system crackles: 'Good morning, hospital staff.' The lights flicker back on... Open your eyes and check the patient monitors...",
          dayIntro: "CODE BLUE! CODE BLUE! The hospital awakens in CHAOS! Nurses rush through the halls! Doctors sprint to the ward! Check the patient roster... someone has been... DISCHARGED PERMANENTLY! Who flatlined in the night?!",
          noDeaths: "Miraculous! All patients stable through the night! The monitors beep with reassuring rhythm. Exchange relieved looks over your surgical masks - but the malpractice continues. Someone in scrubs is NOT who they seem...",
          deaths: victim => `*BEEEEEEEEP* The flatline echoes through the ward! Gather 'round the bed... ${victim} has coded! Their chart reads 'DECEASED.' Give us your most melodramatic soap opera reaction! Gasp! Clutch each other! Cry out 'NOOOO!'`,
          vote: "EMERGENCY BOARD MEETING! The medical staff must decide who's been practicing... MALPRACTICE! On three, point your stethoscope - I mean, FINGER - at the suspect! Stat! One... two... THREE!",
          deathScene: "Reach for the call button! Gasp for air! Your heart monitor goes BEEEEEEP! 'Tell... my secret twin... I always loved them...' *flatline*",
          evilCall: "Adjust your surgical mask to hide your smile. You're the one switching the charts, tampering with the IVs. Look clinical and cold.",
          accusationPrompt: "The Chief of Medicine demands answers! Who wishes to file a formal complaint against a colleague?",
          discussionPrompt: "Speak in urgent medical tones! 'I ACCUSE you of malpractice, Doctor!' Point dramatically across the operating table!",
          protectionCue: "A loyal nurse prepares an emergency injection, ready to revive the innocent at any cost...",
          villainVictoryTease: "The hospital is almost yours. Soon, you'll be the only one with a heartbeat...",
          goodWins: "CODE GREEN! ALL CLEAR! The malpractice has been STOPPED! The hospital returns to saving lives! The monitors beep with healthy rhythms! Let out your most melodramatic sigh of relief! The good doctors and nurses have SAVED THE DAY! Take your heroic bow!",
          evilWins: "FLATLINE! The hospital is OURS! The last honest doctor's chart reads DECEASED! The malpractice runs rampant now! Let out your most villainous medical laugh! The evil medical staff takes CONTROL! Take your diabolical bow!"
        }
      }
    };

    // Quick Start Presets - Balanced character selections for common class sizes
    const PRESETS = {
      15: {
        name: "15 Players - Beginner Friendly",
        roles: [1, 2, 3, 6, 7, 11, 12, 16, 17, 21, 22, 26, 27, 28, 29], // Simple, clear abilities
        description: "Simplified roles perfect for first-time players",
        timeEstimate: "~25 min"
      },
      18: {
        name: "18 Players - Most Popular",
        roles: [1, 2, 3, 4, 6, 7, 8, 11, 12, 13, 16, 17, 21, 22, 26, 27, 28, 29], // Balanced mix
        description: "Great balance of roles for a full class experience",
        timeEstimate: "~30 min"
      },
      21: {
        name: "21 Players - Full Class",
        roles: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 16, 17, 18, 21, 22, 23, 26, 28, 29], // More complex
        description: "Full roster with advanced mechanics",
        timeEstimate: "~35 min"
      }
    };

    const PHASES = {
      night: "Night Phase",
      day: "Day Phase",
      setup: "Setup"
    };

    const INITIAL_STATE = {
      phase: "setup",
      night: 1,
      stepIndex: 0,
      selectedRoles: [],
      players: [],
      theme: "village",
      nameList: "",
      notes: "",
      mode: "dark",
      gameCode: null, // 4-character game code for player devices
      audio: {
        enabled: false,
        volume: 0.5,
        currentTrack: null,
        phase: "night"
      },
      timer: {
        remaining: 180,
        running: false,
        handle: null
      },
      nightActions: {
        villainTarget: null,
        assassinTarget: null,
        stalkerActive: false,
        stalkerBackupTarget: null,
        championProtect: null,
        healerProtect: null,
        guardianProtect: null,
        defenderTrap: null,
        rightHandBlock: null,
        healerLastProtected: null
      },
      resolutionResult: null,
      specialTrackers: {
        championPowerActive: true,
        championIdentifiedVillain: null,
        assassinUsed: false,
        rightHandUsed: false
      },
      silencedPlayer: null, // Manipulator silence effect
      markedPlayer: null, // Traitor's marked player
      sfxEnabled: true, // Sound effects toggle
      voting: {
        phase: null,
        nominations: [],
        accusedPlayer: null,
        votesVisible: false,
        revoteCount: 0,
        tiedPlayers: []
      },
      // Special mechanics state tracking
      markedRevoteUsed: false,     // The Marked (D1) revote power
      traitorRevoteUsed: false,    // The Traitor (A4) revote power
      voicePowerUsed: false,       // The Voice (S2) double elimination
      voiceSecondElimination: null // Player ID for Voice's second elimination
    };

    let state = loadState();

    const setupSection = document.getElementById("setup-section");
    const gameSection = document.getElementById("game-section");
    const playerCountInput = document.getElementById("player-count");
    const playerCountDisplay = document.getElementById("player-count-display");
    const suggestedGoodDisplay = document.getElementById("suggested-good");
    const suggestedEvilDisplay = document.getElementById("suggested-evil");
    const roleGroupsContainer = document.getElementById("role-groups");
    const balanceBadge = document.getElementById("role-balance");
    const balanceWarning = document.getElementById("balance-warning");
    const startButton = document.getElementById("start-game");
    const themeSelect = document.getElementById("theme-select");
    const themeDescription = document.getElementById("theme-description");
    const namesInput = document.getElementById("player-names");
    const previewShuffleBtn = document.getElementById("preview-shuffle");
    const shuffleAssignmentsBtn = document.getElementById("shuffle-assignments");
    const shufflePreviewDiv = document.getElementById("shuffle-preview");
    const assignmentListDiv = document.getElementById("assignment-list");

    const scriptStepsContainer = document.getElementById("script-steps");
    const scriptTitle = document.getElementById("script-title");
    const phaseLabel = document.getElementById("phase-label");
    const prevStepButton = document.getElementById("prev-step");
    const nextStepButton = document.getElementById("next-step");

    const timerDisplay = document.getElementById("timer-display");
    const timerButtons = document.querySelectorAll(".timer-controls button[data-timer]");
    const startTimerBtn = document.getElementById("start-timer");
    const pauseTimerBtn = document.getElementById("pause-timer");
    const resetTimerBtn = document.getElementById("reset-timer");
    const timerPhase = document.getElementById("timer-phase");

    const nightNumber = document.getElementById("night-number");
    const aliveCount = document.getElementById("alive-count");
    const goodCount = document.getElementById("good-count");
    const evilCount = document.getElementById("evil-count");

    const playerList = document.getElementById("player-list");
    const playerCardTemplate = document.getElementById("player-card-template");
    const notesArea = document.getElementById("narrator-notes");

    const toggleModeButton = document.getElementById("toggle-mode");
    const resetGameButton = document.getElementById("reset-game");
    const helpButton = document.getElementById("help-button");
    const downloadNotesLink = document.getElementById("download-notes");
    const openProjectorButton = document.getElementById("open-projector");

    // Game code display element
    const gameCodeValue = document.getElementById("game-code-value");

    // BroadcastChannel for projector synchronization
    let projectorChannel = null;
    const CHANNEL_NAME = 'melodrama-narrator-projector';

    // Firebase-based player device synchronization (for cross-device communication)
    // BroadcastChannel kept only for backward compatibility on same-device
    let playerChannel = null;
    const PLAYER_CHANNEL_NAME = 'melodrama-player-channel';
    
    // Track Firebase listeners for cleanup
    let firebasePlayersUnsubscribe = null;
    
    // Track connected players (transient state - not persisted)
    const connectedPlayers = new Map(); // Map<firebasePlayerId, { name: string, gamePlayerId: number, joinedAt: number }>

    function initProjectorChannel() {
      if ('BroadcastChannel' in window) {
        try {
          projectorChannel = new BroadcastChannel(CHANNEL_NAME);
          
          projectorChannel.onmessage = (event) => {
            // Handle requests from projector
            if (event.data.type === 'request-state' || event.data.type === 'ping') {
              sendFullStateToProjector();
            }
          };

          console.log('Projector BroadcastChannel initialized');
        } catch (error) {
          console.error('Failed to initialize projector channel:', error);
        }
      }
    }

    // Render game code display
    function renderGameCode() {
      if (gameCodeValue) {
        gameCodeValue.textContent = state.gameCode || '----';
      }
    }

    // Generate a random 4-character game code
    function generateGameCode() {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Excludes 0, O, 1, I to avoid confusion
      let code = '';
      for (let i = 0; i < 4; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return code;
    }

    function initPlayerChannel() {
      // Initialize BroadcastChannel for same-device backward compatibility
      if ('BroadcastChannel' in window) {
        try {
          playerChannel = new BroadcastChannel(PLAYER_CHANNEL_NAME);
          
          playerChannel.onmessage = (event) => {
            handlePlayerMessage(event.data);
          };

          console.log('Player BroadcastChannel initialized (same-device fallback)');
        } catch (error) {
          console.error('Failed to initialize player channel:', error);
        }
      }
      
      // Firebase is initialized in the module script - we check for it here
      if (window.firebaseDB && window.firebaseDB.initialized) {
        console.log('Firebase available for cross-device player communication');
      } else {
        console.warn('Firebase not available - cross-device player communication disabled');
      }
    }

    // Create Firebase game session when game starts
    function createFirebaseGameSession() {
      if (!window.firebaseDB || !window.firebaseDB.initialized || !state.gameCode) {
        console.log('Firebase not available for game session creation');
        return;
      }
      
      const db = window.firebaseDB;
      const gameRef = db.ref(db.database, `games/${state.gameCode}`);
      
      // Create game session with initial state
      const gameData = {
        gameState: {
          phase: state.phase,
          night: state.night,
          theme: state.theme,
          winTeam: null
        },
        players: {},
        createdAt: Date.now()
      };
      
      db.set(gameRef, gameData)
        .then(() => {
          console.log(`Firebase game session created: ${state.gameCode}`);
          // Listen for player joins
          setupFirebasePlayersListener();
        })
        .catch((error) => {
          console.error('Failed to create Firebase game session:', error);
        });
    }

    // Listen for players joining via Firebase
    function setupFirebasePlayersListener() {
      if (!window.firebaseDB || !window.firebaseDB.initialized || !state.gameCode) {
        return;
      }
      
      const db = window.firebaseDB;
      const playersRef = db.ref(db.database, `games/${state.gameCode}/players`);
      
      // Clean up any existing listener
      if (firebasePlayersUnsubscribe) {
        firebasePlayersUnsubscribe();
      }
      
      firebasePlayersUnsubscribe = db.onValue(playersRef, (snapshot) => {
        const playersData = snapshot.val();
        
        // Clear and rebuild connected players map
        connectedPlayers.clear();
        
        if (!playersData) {
          updatePlayerConnectionUI();
          return;
        }
        
        // Track connected players and check for new players needing assignment
        Object.entries(playersData).forEach(([playerId, playerData]) => {
          if (playerData.name && !playerData.character) {
            // Player is waiting for character assignment
            handleFirebasePlayerJoin(playerId, playerData);
          } else if (playerData.status === 'assigned' && playerData.gamePlayerId) {
            // Player is connected and has character assigned
            connectedPlayers.set(playerId, {
              name: playerData.name,
              gamePlayerId: playerData.gamePlayerId,
              joinedAt: playerData.joinedAt || Date.now()
            });
          }
        });
        
        // Update the UI to show connection status
        updatePlayerConnectionUI();
      });
    }
    
    // Update UI to show which players are connected
    function updatePlayerConnectionUI() {
      const connectionCount = document.getElementById('connection-count');
      const connectionDot = document.getElementById('connection-dot');
      
      if (!connectionCount || !connectionDot) return;
      
      const totalPlayers = state.players.length;
      const connectedCount = connectedPlayers.size;
      
      // Update the summary count
      connectionCount.textContent = `${connectedCount}/${totalPlayers} players connected`;
      
      // Update the dot color based on connection status
      connectionDot.classList.remove('connected', 'partial', 'none');
      connectionCount.classList.remove('all-connected', 'partial');
      
      if (connectedCount === 0) {
        connectionDot.classList.add('none');
      } else if (connectedCount === totalPlayers) {
        connectionDot.classList.add('connected');
        connectionCount.classList.add('all-connected');
      } else {
        connectionDot.classList.add('partial');
        connectionCount.classList.add('partial');
      }
      
      // Update individual player cards
      updatePlayerCardConnectionStatus();
    }
    
    // Update connection status on individual player cards
    function updatePlayerCardConnectionStatus() {
      const playerCards = document.querySelectorAll('.player-card[data-id]');
      
      playerCards.forEach(card => {
        const playerId = parseInt(card.dataset.id, 10);
        const indicator = card.querySelector('.player-connection-indicator');
        
        if (!indicator) return;
        
        // Check if this player is connected
        let isConnected = false;
        connectedPlayers.forEach((connectedPlayer) => {
          if (connectedPlayer.gamePlayerId === playerId) {
            isConnected = true;
          }
        });
        
        const statusDot = indicator.querySelector('.status-dot');
        const statusText = indicator.querySelector('.status-text');
        
        indicator.classList.remove('connected', 'disconnected');
        card.dataset.connected = isConnected ? 'true' : 'false';
        
        if (isConnected) {
          indicator.classList.add('connected');
          if (statusText) statusText.textContent = 'Online';
        } else {
          indicator.classList.add('disconnected');
          if (statusText) statusText.textContent = 'Offline';
        }
      });
    }

    // Handle player join from Firebase
    function handleFirebasePlayerJoin(playerId, playerData) {
      // Check if game has started
      if (state.phase === 'setup' || state.players.length === 0) {
        updateFirebasePlayerStatus(playerId, {
          status: 'rejected',
          reason: 'Game has not started yet. Please wait for the narrator.'
        });
        return;
      }

      // Find the player by name
      const player = state.players.find(p => 
        p.name.toLowerCase().trim() === playerData.name.toLowerCase().trim()
      );

      if (!player) {
        updateFirebasePlayerStatus(playerId, {
          status: 'rejected',
          reason: 'Player name not found. Check with your narrator that your name is entered correctly.'
        });
        return;
      }

      // Get full character data
      const character = CHARACTERS.find(c => c.id === player.charId);
      
      // Update player with character assignment
      const characterData = character ? {
        id: character.id,
        name: character.name,
        team: character.team,
        type: character.type,
        typeLabel: character.typeLabel || character.type,
        power: character.power,
        short: character.short,
        nightB: character.nightB,
        dayB: character.dayB
      } : null;
      
      updateFirebasePlayerStatus(playerId, {
        status: 'assigned',
        gamePlayerId: player.id,
        character: characterData
      });

      console.log(`Firebase player joined: ${playerData.name} as ${character ? character.name : 'Unknown'}`);
    }

    // Update player status in Firebase
    function updateFirebasePlayerStatus(playerId, data) {
      if (!window.firebaseDB || !window.firebaseDB.initialized || !state.gameCode) {
        return;
      }
      
      const db = window.firebaseDB;
      const playerRef = db.ref(db.database, `games/${state.gameCode}/players/${playerId}`);
      
      db.update(playerRef, data)
        .catch((error) => {
          console.error('Failed to update player status:', error);
        });
    }

    // Update game state in Firebase
    function updateFirebaseGameState() {
      if (!window.firebaseDB || !window.firebaseDB.initialized || !state.gameCode) {
        return;
      }
      
      const db = window.firebaseDB;
      const gameStateRef = db.ref(db.database, `games/${state.gameCode}/gameState`);
      
      db.update(gameStateRef, {
        phase: state.phase,
        night: state.night,
        theme: state.theme
      }).catch((error) => {
        console.error('Failed to update Firebase game state:', error);
      });
    }

    // Broadcast win to Firebase
    function updateFirebaseWin(winTeam) {
      if (!window.firebaseDB || !window.firebaseDB.initialized || !state.gameCode) {
        return;
      }
      
      const db = window.firebaseDB;
      const gameStateRef = db.ref(db.database, `games/${state.gameCode}/gameState`);
      
      db.update(gameStateRef, {
        winTeam: winTeam,
        night: state.night
      }).catch((error) => {
        console.error('Failed to update Firebase win state:', error);
      });
    }

    // Clean up Firebase game session
    function cleanupFirebaseGameSession() {
      if (!window.firebaseDB || !window.firebaseDB.initialized || !state.gameCode) {
        return;
      }
      
      // Clean up listener
      if (firebasePlayersUnsubscribe) {
        firebasePlayersUnsubscribe();
        firebasePlayersUnsubscribe = null;
      }
      
      // Clear connected players tracking
      connectedPlayers.clear();
      updatePlayerConnectionUI();
      
      const db = window.firebaseDB;
      const gameRef = db.ref(db.database, `games/${state.gameCode}`);
      
      // First update to notify players of reset, then remove
      db.update(db.ref(db.database, `games/${state.gameCode}/gameState`), {
        reset: true
      }).then(() => {
        // Give players a moment to receive the reset notification
        setTimeout(() => {
          db.remove(gameRef)
            .then(() => {
              console.log(`Firebase game session cleaned up: ${state.gameCode}`);
            })
            .catch((error) => {
              console.error('Failed to cleanup Firebase game session:', error);
            });
        }, 1000);
      }).catch((error) => {
        console.error('Failed to notify reset:', error);
      });
    }

    // Legacy BroadcastChannel handlers (for same-device compatibility)
    function handlePlayerMessage(data) {
      // Only handle messages for our game code
      if (data.gameCode && data.gameCode !== state.gameCode) {
        return;
      }

      switch (data.type) {
        case 'player-join':
          handlePlayerJoin(data);
          break;
        case 'player-leave':
          handlePlayerLeave(data);
          break;
        case 'player-request-state':
          sendStateToPlayer(data.playerName);
          break;
      }
    }

    function handlePlayerJoin(data) {
      // Check if game code matches
      if (data.gameCode !== state.gameCode) {
        if (playerChannel) {
          playerChannel.postMessage({
            type: 'join-rejected',
            gameCode: data.gameCode,
            playerName: data.playerName,
            reason: 'Invalid game code'
          });
        }
        return;
      }

      // Check if game has started
      if (state.phase === 'setup' || state.players.length === 0) {
        if (playerChannel) {
          playerChannel.postMessage({
            type: 'join-rejected',
            gameCode: data.gameCode,
            playerName: data.playerName,
            reason: 'Game has not started yet. Please wait for the narrator.'
          });
        }
        return;
      }

      // Find the player by name
      const player = state.players.find(p => 
        p.name.toLowerCase().trim() === data.playerName.toLowerCase().trim()
      );

      if (!player) {
        if (playerChannel) {
          playerChannel.postMessage({
            type: 'join-rejected',
            gameCode: data.gameCode,
            playerName: data.playerName,
            reason: 'Player name not found. Check with your narrator that your name is entered correctly.'
          });
        }
        return;
      }

      // Get full character data
      const character = CHARACTERS.find(c => c.id === player.charId);
      
      // Send player assignment via BroadcastChannel
      if (playerChannel) {
        playerChannel.postMessage({
          type: 'player-assigned',
          gameCode: state.gameCode,
          playerName: data.playerName,
          playerId: player.id,
          character: character ? {
            id: character.id,
            name: character.name,
            team: character.team,
            type: character.type,
            typeLabel: character.typeLabel || character.type,
            power: character.power,
            short: character.short,
            nightB: character.nightB,
            dayB: character.dayB
          } : null
        });
      }

      // Also send current game state
      setTimeout(() => sendStateToPlayer(data.playerName), 100);

      console.log(`Player joined (BroadcastChannel): ${data.playerName} as ${character ? character.name : 'Unknown'}`);
    }

    function handlePlayerLeave(data) {
      console.log(`Player left: ${data.playerName}`);
      // Could add tracking here if needed
    }

    function sendStateToPlayer(playerName) {
      if (!playerChannel || !state.gameCode) return;

      playerChannel.postMessage({
        type: 'game-state',
        gameCode: state.gameCode,
        phase: state.phase,
        night: state.night
      });
    }

    function broadcastToPlayers(message) {
      // Broadcast via BroadcastChannel (same-device)
      if (playerChannel && state.gameCode) {
        playerChannel.postMessage({
          ...message,
          gameCode: state.gameCode
        });
      }
      
      // Also update Firebase game state for cross-device
      if (message.type === 'phase-change') {
        updateFirebaseGameState();
      } else if (message.type === 'WIN') {
        updateFirebaseWin(message.team);
      }
    }

    function broadcastGameResetToPlayers() {
      // Broadcast via BroadcastChannel (same-device)
      if (playerChannel) {
        playerChannel.postMessage({
          type: 'game-reset',
          gameCode: state.gameCode
        });
      }
      
      // Clean up Firebase session
      cleanupFirebaseGameSession();
    }

    // Helper function to calculate player counts
    function calculatePlayerCounts() {
      const alivePlayers = state.players.filter(p => !p.eliminated);
      return {
        alive: alivePlayers.length,
        good: alivePlayers.filter(p => p.team === 'good').length,
        evil: alivePlayers.filter(p => p.team === 'evil').length
      };
    }

    function sendFullStateToProjector() {
      if (!projectorChannel) return;
      
      const eliminatedPlayers = state.players
        .filter(p => p.eliminated)
        .map(p => p.name);
      
      const counts = calculatePlayerCounts();
      
      // Build roster data for projector - hide player names and team/role until eliminated
      const rosterData = state.players.map(p => {
        const char = CHARACTERS.find(c => c.id === p.charId);
        // Only reveal player name and team/role info when eliminated
        if (p.eliminated) {
          return {
            id: p.id,
            name: p.name,
            roleName: p.roleName,
            team: p.team,
            type: char ? char.type : 'unknown',
            ability: char ? char.short : '',
            eliminated: true
          };
        } else {
          // For alive players, hide identity - just show they exist
          return {
            id: p.id,
            name: '???',
            roleName: 'Unknown',
            team: 'unknown',
            type: 'unknown',
            ability: '',
            eliminated: false
          };
        }
      });

      projectorChannel.postMessage({
        type: 'full-state',
        phase: state.phase,
        night: state.night,
        timer: {
          remaining: state.timer.remaining,
          running: state.timer.running
        },
        eliminated: eliminatedPlayers,
        theme: state.theme,
        aliveCount: counts.alive,
        goodCount: counts.good,
        evilCount: counts.evil,
        roster: rosterData
      });
    }

    function broadcastPhaseChange(phase, night) {
      if (projectorChannel) {
        projectorChannel.postMessage({
          type: 'phase-change',
          phase: phase,
          night: night
        });
      }
      // Also broadcast to player devices
      broadcastToPlayers({
        type: 'phase-change',
        phase: phase,
        night: night
      });
    }

    function broadcastTimerUpdate(remaining, running) {
      if (!projectorChannel) return;
      projectorChannel.postMessage({
        type: 'timer-update',
        remaining: remaining,
        running: running
      });
    }

    function broadcastPlayerEliminated(playerName) {
      if (!projectorChannel) return;
      projectorChannel.postMessage({
        type: 'player-eliminated',
        playerName: playerName
      });
    }

    function broadcastPlayersEliminated() {
      if (!projectorChannel) return;
      const eliminatedPlayers = state.players
        .filter(p => p.eliminated)
        .map(p => p.name);
      projectorChannel.postMessage({
        type: 'players-eliminated',
        players: eliminatedPlayers
      });
      // Also broadcast updated player counts
      broadcastPlayerCounts();
    }

    function broadcastPlayerCounts() {
      if (!projectorChannel) return;
      const counts = calculatePlayerCounts();
      projectorChannel.postMessage({
        type: 'player-counts',
        alive: counts.alive,
        good: counts.good,
        evil: counts.evil
      });
    }

    function broadcastGameReset() {
      if (projectorChannel) {
        projectorChannel.postMessage({
          type: 'reset-game'
        });
      }
      // Also reset player devices
      broadcastGameResetToPlayers();
    }

    function broadcastThemeChange(theme) {
      if (!projectorChannel) return;
      projectorChannel.postMessage({
        type: 'theme-change',
        theme: theme
      });
    }

    function broadcastVotingUpdate(active, phase, nominations) {
      if (!projectorChannel) return;
      // Get nominated player names (not IDs) for display on projector
      const nominationNames = nominations ? nominations.map(id => {
        const player = state.players.find(p => p.id === id);
        return player ? player.name : 'Unknown';
      }) : [];
      projectorChannel.postMessage({
        type: 'voting-update',
        active: active,
        phase: phase,
        nominations: nominationNames
      });
    }

    function broadcastRosterUpdate() {
      if (!projectorChannel) return;
      // Build roster data for projector - hide player name and team/role until eliminated
      const rosterData = state.players.map(p => {
        const char = CHARACTERS.find(c => c.id === p.charId);
        // Only reveal player name and team/role info when eliminated
        if (p.eliminated) {
          return {
            id: p.id,
            name: p.name,
            roleName: p.roleName,
            team: p.team,
            type: char ? char.type : 'unknown',
            ability: char ? char.short : '',
            eliminated: true
          };
        } else {
          // For alive players, hide identity - just show they exist
          return {
            id: p.id,
            name: '???',
            roleName: 'Unknown',
            team: 'unknown',
            type: 'unknown',
            ability: '',
            eliminated: false
          };
        }
      });
      projectorChannel.postMessage({
        type: 'roster-update',
        players: rosterData
      });
    }

    const audioControls = document.getElementById("audio-controls");
    const toggleAudioButton = document.getElementById("toggle-audio");
    const volumeSlider = document.getElementById("volume-slider");
    const audioIndicator = document.getElementById("audio-indicator");
    const audioPhase = document.getElementById("audio-phase");

    // Audio system
    let audioContext = null;
    let currentAudio = null;

    function initAudioSystem() {
      // Audio context will be created on first user interaction due to browser policies
      toggleAudioButton.addEventListener("click", toggleAudio);
      volumeSlider.addEventListener("input", (e) => {
        state.audio.volume = e.target.value / 100;
        if (currentAudio) {
          currentAudio.volume = state.audio.volume;
        }
        persistState();
      });
    }

    function toggleAudio() {
      state.audio.enabled = !state.audio.enabled;
      toggleAudioButton.textContent = state.audio.enabled ? "üîä" : "üîá";
      audioIndicator.classList.toggle("playing", state.audio.enabled);
      
      if (state.audio.enabled) {
        playThemeAudio();
      } else {
        stopAudio();
      }
      persistState();
    }

    function playThemeAudio() {
      // Stop any currently playing audio
      stopAudio();

      const theme = THEMES[state.theme];
      const audioUrl = state.audio.phase === "night" ? theme.audio.night : theme.audio.day;

      // If no audio URL is set, just update indicator
      if (!audioUrl) {
        return;
      }

      try {
        currentAudio = new Audio(audioUrl);
        currentAudio.loop = true;
        currentAudio.volume = state.audio.volume;
        currentAudio.play().catch(err => {
          console.warn("Audio playback failed:", err);
          state.audio.enabled = false;
          toggleAudioButton.textContent = "üîá";
        });
      } catch (err) {
        console.warn("Audio initialization failed:", err);
      }
    }

    function stopAudio() {
      if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio = null;
      }
    }

    function updateAudioPhase(phase) {
      state.audio.phase = phase;
      audioPhase.textContent = phase === "night" ? "Night" : "Day";
      
      if (state.audio.enabled) {
        playThemeAudio();
      }
    }

    function applyThemeVisuals() {
      const theme = THEMES[state.theme];
      const visual = theme.visual;
      
      // Apply theme-specific background to body
      document.body.style.background = visual.background;
      document.body.style.minHeight = "100vh";
      
      // Apply theme font family
      document.body.style.fontFamily = visual.fontFamily;
      
      // Apply texture overlay
      const mainElement = document.querySelector("main");
      if (mainElement) {
        mainElement.style.backgroundImage = visual.texture;
      }
      
      // Apply accent color to CSS variable
      document.documentElement.style.setProperty("--theme-accent", visual.accentColor);
      
      // Apply text glow to headers and important elements
      const headers = document.querySelectorAll("h1, h2, h3");
      headers.forEach(header => {
        header.style.textShadow = visual.textGlow;
      });

      // Apply semi-transparent backgrounds to sections to let theme show through
      const sections = document.querySelectorAll("section");
      sections.forEach(section => {
        // Use a more transparent overlay that lets the theme background show
        section.style.backgroundColor = "rgba(15, 23, 42, 0.4)";
        section.style.backdropFilter = "blur(12px)";
        section.style.border = `1px solid ${visual.accentColor}40`;
      });
      
      // Apply theme accent to role cards and UI elements
      const roleCards = document.querySelectorAll(".role-card");
      roleCards.forEach(card => {
        card.style.borderColor = `${visual.accentColor}60`;
      });

      // Apply themed button styles
      const buttons = document.querySelectorAll("button:not(.player-actions button)");
      buttons.forEach(button => {
        button.style.background = visual.buttonGradient;
        button.style.borderRadius = visual.buttonRadius;
        button.style.boxShadow = `0 8px 18px ${visual.accentColor}40`;
      });

      // Apply animation to body if specified
      if (visual.animation && visual.animation !== "none") {
        document.body.style.animation = visual.animation;
      } else {
        document.body.style.animation = "none";
      }
    }

    function applyMode(mode) {
      document.body.classList.toggle("light", mode === "light");
      toggleModeButton.setAttribute("aria-pressed", String(mode === "light"));
      
      // Reapply theme visuals after mode change
      applyThemeVisuals();
    }

    function loadState() {
      const stored = localStorage.getItem("melodrama-state-v1");
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          return { 
            ...INITIAL_STATE, 
            ...parsed, 
            timer: { ...INITIAL_STATE.timer, ...parsed.timer, handle: null },
            voting: { ...INITIAL_STATE.voting, ...(parsed.voting || {}) }
          };
        } catch (error) {
          console.warn("Failed to parse stored state", error);
        }
      }
      return structuredClone(INITIAL_STATE);
    }

    function persistState() {
      const toStore = { ...state, timer: { ...state.timer, handle: null } };
      localStorage.setItem("melodrama-state-v1", JSON.stringify(toStore));
    }

    function resetState() {
      state = structuredClone(INITIAL_STATE);
      persistState();
      if (downloadNotesLink.dataset.url) {
        URL.revokeObjectURL(downloadNotesLink.dataset.url);
        delete downloadNotesLink.dataset.url;
      }
      broadcastGameReset();
      applyMode(state.mode);
      // Hide quick reference panel on reset
      quickRefPanel.classList.remove("open");
      quickRefToggle.classList.add("hidden");
      quickRefToggle.classList.remove("panel-open");
      renderAll();
      setupSection.classList.remove("hidden");
      gameSection.classList.add("hidden");
    }

    function renderThemeSelect() {
      themeSelect.innerHTML = "";
      Object.entries(THEMES).forEach(([key, info]) => {
        const option = document.createElement("option");
        option.value = key;
        option.textContent = info.name;
        themeSelect.append(option);
      });
      themeSelect.value = state.theme;
      themeDescription.textContent = THEMES[state.theme].description;
    }

    function renderRoleGroups() {
      const grouped = CHARACTERS.reduce((acc, char) => {
        acc[char.type] ??= [];
        acc[char.type].push(char);
        return acc;
      }, {});

      roleGroupsContainer.innerHTML = "";
      Object.entries(TYPE_DETAILS).forEach(([type, meta]) => {
        const wrapper = document.createElement("div");
        wrapper.className = "role-group";
        wrapper.style.setProperty("--accent", meta.accent);

        const header = document.createElement("div");
        header.className = "role-group-header";
        const title = document.createElement("div");
        title.innerHTML = `<strong style="color:${meta.accent}">${meta.label}</strong><br><small>${meta.description}</small>`;
        const rangeInfo = document.createElement("small");
        rangeInfo.textContent = `Select ${meta.min} ‚Äì ${meta.max}`;
        header.append(title, rangeInfo);

        const cards = document.createElement("div");
        cards.className = "role-cards";
        (grouped[type] || []).forEach(char => {
          const card = document.createElement("article");
          card.className = "role-card";
          card.dataset.id = String(char.id);
          card.dataset.team = char.team;
          card.dataset.type = char.type;
          card.innerHTML = `
            <span class="type">${meta.label}</span>
            <h3>${char.name}</h3>
            <span class="team-label">
              <span class="badge ${char.team}">${char.team.toUpperCase()}</span>
              ${char.limited ? `‚Ä¢ ${char.limited} use` : ""}
            </span>
            <p>${char.short}</p>
          `;
          card.addEventListener("click", () => toggleRoleSelection(char.id));
          cards.append(card);
        });

        wrapper.append(header, cards);
        roleGroupsContainer.append(wrapper);
      });
    }

    function toggleRoleSelection(id) {
      const selected = new Set(state.selectedRoles);
      if (selected.has(id)) {
        selected.delete(id);
      } else {
        selected.add(id);
      }
      state.selectedRoles = Array.from(selected);
      updateRoleSelectionUI();
      persistState();
      // Reset preview when roles change
      previewPlayers = [];
      shufflePreviewDiv.classList.add('hidden');
    }

    function updateRoleSelectionUI() {
      const cards = roleGroupsContainer.querySelectorAll(".role-card");
      cards.forEach(card => {
        card.dataset.selected = state.selectedRoles.includes(Number(card.dataset.id)) ? "true" : "false";
      });
      const totals = state.selectedRoles.reduce((acc, id) => {
        const character = CHARACTERS.find(c => c.id === id);
        if (!character) return acc;
        acc.total += 1;
        acc[character.team] += 1;
        acc.byType[character.type] ??= 0;
        acc.byType[character.type] += 1;
        return acc;
      }, { total: 0, good: 0, evil: 0, byType: {} });

      balanceBadge.textContent = `Good: ${totals.good} ‚Ä¢ Evil: ${totals.evil} ‚Ä¢ Selected: ${totals.total}`;

      const target = Number(playerCountInput.value);
      const typeIssues = Object.entries(TYPE_DETAILS).filter(([type, info]) => {
        const count = totals.byType[type] || 0;
        return count < info.min || count > info.max;
      });
      const ready = totals.total === target && typeIssues.length === 0;
      startButton.disabled = !ready;
      previewShuffleBtn.disabled = !ready;
      balanceWarning.textContent = ready ? "Ready! Dramatic chaos awaits." : "Adjust counts to match the player total and type ranges.";
    }

    // Fisher-Yates shuffle algorithm
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // Store current preview assignments
    let previewPlayers = [];

    // Generate preview of player assignments without starting the game
    function generatePreviewAssignments() {
      const selected = state.selectedRoles.map(id => CHARACTERS.find(c => c.id === id));
      const names = state.nameList.split(/\n+/).map(n => n.trim()).filter(Boolean);
      
      // Shuffle the names to randomly assign players to characters
      const shuffledNames = shuffleArray(names);
      
      previewPlayers = selected.map((char, index) => ({
        id: index,
        charId: char.id,
        name: shuffledNames[index] || `Player ${index + 1}`,
        roleName: char.name,
        team: char.team,
        type: char.type
      }));
      
      return previewPlayers;
    }

    // Render the preview list
    function renderPreviewAssignments() {
      assignmentListDiv.innerHTML = '';
      
      previewPlayers.forEach(player => {
        const div = document.createElement('div');
        const isEvil = player.team === 'evil';
        div.className = 'preview-assignment-item';
        div.style.cssText = `
          padding: 0.5rem 0.75rem;
          border-radius: 8px;
          background: ${isEvil ? 'rgba(244, 114, 182, 0.15)' : 'rgba(56, 189, 248, 0.15)'};
          border: 1px solid ${isEvil ? 'rgba(244, 114, 182, 0.4)' : 'rgba(56, 189, 248, 0.4)'};
          font-size: 0.9rem;
        `;
        div.innerHTML = `
          <strong style="color: var(${isEvil ? '--accent-evil' : '--accent-good'});">${player.name}</strong>
          <span style="color: var(--text-secondary);"> ‚Üí ${player.roleName}</span>
        `;
        assignmentListDiv.appendChild(div);
      });
    }

    // Show preview with current shuffle
    function showShufflePreview() {
      generatePreviewAssignments();
      renderPreviewAssignments();
      shufflePreviewDiv.classList.remove('hidden');
    }

    // Shuffle again without closing preview
    function shuffleAgain() {
      generatePreviewAssignments();
      renderPreviewAssignments();
    }

    function preparePlayers() {
      const selected = state.selectedRoles.map(id => CHARACTERS.find(c => c.id === id));
      const names = state.nameList.split(/\n+/).map(n => n.trim()).filter(Boolean);
      
      // If we have preview players from the shuffle preview, use those assignments
      // Otherwise, generate new random assignments
      let shuffledNames;
      if (previewPlayers.length > 0 && previewPlayers.length === selected.length) {
        // Use the previewed assignments
        shuffledNames = previewPlayers.map(p => p.name);
      } else {
        // Shuffle the names to randomly assign players to characters
        shuffledNames = shuffleArray(names);
      }
      
      return selected.map((char, index) => ({
        id: index,
        charId: char.id,
        name: shuffledNames[index] || `Player ${index + 1}`,
        roleName: char.name,
        team: char.team,
        type: char.type,
        ability: char.short,
        eliminated: false,
        protected: false,
        notes: "",
        abilityUsesRemaining: char.limited || -1, // -1 means unlimited
        blocked: false,
        linkedTo: null, // for Twins, Champion-Companion
        hasNightAction: char.hasNightAction || false,
        firstNightSetup: char.firstNightSetup || false,
        passive: char.passive || false
      }));
    }

    function buildScriptSteps() {
      const theme = THEMES[state.theme];
      const hasType = type => state.players.some(player => player.type === type && !player.eliminated);
      const hasRole = id => state.players.some(player => player.charId === id && !player.eliminated);
      const hasActiveRole = id => {
        const player = state.players.find(p => p.charId === id && !p.eliminated);
        return player && (player.abilityUsesRemaining !== 0);
      };

      const nightSteps = [];
      
      // Night 1 Opening - Unified flowing script
      if (state.night === 1) {
        // Get villain and accomplice names for the script
        const villains = state.players.filter(p => p.type === "villain" && !p.eliminated).map(p => `${p.name} (${p.roleName})`).join(", ");
        const accomplices = state.players.filter(p => p.type === "accomplice" && !p.eliminated).map(p => `${p.name} (${p.roleName})`).join(", ");
        const hasVillains = hasType("villain");
        const hasAccomplices = hasType("accomplice");
        
        // Build unified Night 1 opening script with formatting
        let unifiedScript = theme.script.nightIntro;
        
        if (hasVillains && hasAccomplices) {
          // Both villains and accomplices - wake together so accomplices can see villains
          unifiedScript += `\n\n**Villains and Accomplices** [${villains}, ${accomplices}], please wake up now. ${theme.script.evilCall}\n\n**Accomplices** [${accomplices}], back to sleep.`;
        } else if (hasVillains) {
          // Only villains
          unifiedScript += `\n\n**Villains** [${villains}], please wake up now. ${theme.script.evilCall}`;
        } else if (hasAccomplices) {
          // Only accomplices (rare edge case)
          unifiedScript += `\n\n**Accomplices** [${accomplices}], please wake up now. ${theme.script.evilCall}\n\n**Accomplices** [${accomplices}], back to sleep.`;
        }
        
        nightSteps.push({
          title: "Night 1 Opening",
          phase: "night",
          blocks: [
            { type: "say", text: unifiedScript }
          ]
        });
        
        // NOTE: Champion sees Cursed, Twins Meet, and Loyal Companion meets Champion
        // are inserted at their correct positions later in the sequence (see below)
      } else {
        // Subsequent nights opening - unified script
        const villains = state.players.filter(p => p.type === "villain" && !p.eliminated).map(p => `${p.name} (${p.roleName})`).join(", ");
        const hasVillains = hasType("villain");
        
        let unifiedScript = theme.script.nightIntro;
        
        if (hasVillains) {
          unifiedScript += `\n\n**Villains** [${villains}], please wake up now. ${theme.script.evilCall}`;
        }
        
        nightSteps.push({
          title: `Night ${state.night} Begins`,
          phase: "night",
          blocks: [
            { type: "say", text: unifiedScript }
          ]
        });
      }

      // Step 1: Villain-Type - Villains choose their victim
      if (hasType("villain")) {
        const villains = state.players.filter(p => p.type === "villain" && !p.eliminated).map(p => `${p.name} (${p.roleName})`).join(", ");
        
        let villainScript = `**Villains** [${villains}], choose your victim now.\n\n**Point silently** to your target. Once you have agreed, **close your eyes**.`;
        
        nightSteps.push({
          title: "Step 1: Villain-Type",
          phase: "night",
          blocks: [
            { type: "say", text: villainScript },
            { type: "info", text: `Villains alive: ${villains || "None"}` }
          ]
        });
      }

      // Step 2: Accomplice-Type - Simplified thumb-out prompt for night powers
      const accomplicesWithAbilities = state.players.filter(p => 
        p.type === "accomplice" && !p.eliminated && p.abilityUsesRemaining !== 0
      );
      
      if (accomplicesWithAbilities.length > 0) {
        const accompliceNames = accomplicesWithAbilities.map(p => `${p.name} (${p.roleName})`).join(", ");
        
        let accompliceScript = `**Accomplices** [${accompliceNames}], please wake up now.\n\nPlease **put your thumb out** now if you would like to use your once-per-game power tonight.\n\n**Accomplices**, back to sleep.`;
        
        nightSteps.push({
          title: "Step 2: Accomplice-Type",
          phase: "night",
          blocks: [
            { type: "say", text: accompliceScript },
            { type: "info", text: `Accomplices with powers: ${accompliceNames}` },
            { type: "narrator", text: "**For any accomplice who signals**, perform their action:\n‚Ä¢ **Right Hand** - blocks night ability\n‚Ä¢ **Spy** - reveals if target has night action\n‚Ä¢ **Manipulator** - silences vote\n‚Ä¢ **Traitor** - marks for revote\n‚Ä¢ **Informant** - reveals role to villains" }
          ]
        });
      }

      // Night 1 Special: Champion sees Cursed (before Step 3, per design brief)
      if (state.night === 1 && hasRole(16) && hasRole(30)) {
        const cursedPlayer = state.players.find(p => p.charId === 30);
        const championPlayer = state.players.find(p => p.charId === 16);
        nightSteps.push({
          title: "Night 1: Champion Sees the Cursed",
          phase: "night",
          blocks: [
            { type: "say", text: `**Champion** [${championPlayer ? championPlayer.name : "Champion"}], open your eyes and look for the Cursed.\n\n**Point silently** to [${cursedPlayer ? cursedPlayer.name : "the Cursed player"}]'s seat.\n\n**Champion**, close your eyes.` }
          ]
        });
      }

      // Night 1 Special: Twins see each other (before Step 3, per design brief)
      if (state.night === 1 && hasRole(28) && hasRole(29)) {
        const twinA = state.players.find(p => p.charId === 28);
        const twinB = state.players.find(p => p.charId === 29);
        nightSteps.push({
          title: "Night 1: Twins Meet",
          phase: "night",
          blocks: [
            { type: "say", text: `**Twin A and Twin B** [${twinA ? twinA.name : "Twin A"}, ${twinB ? twinB.name : "Twin B"}], open your eyes and find each other.\n\n**Remember**: if one is eliminated, the other falls immediately.\n\n**Twins**, close your eyes.` }
          ]
        });
      }

      // Step 3: Elder-Type - Unified script for each elder
      const elders = state.players.filter(p => p.type === "elder" && !p.eliminated && !p.blocked);
      
      if (elders.length > 0) {
        const elderNames = elders.map(p => `${p.name} (${p.roleName})`).join(", ");
        nightSteps.push({
          title: "Step 3: Elder-Type",
          phase: "night",
          blocks: [
            { type: "say", text: `**Elders** [${elderNames}], you will each wake individually to receive information.` }
          ]
        });
        
        // Call each elder with unified script format
        elders.forEach(player => {
          let elderScript = `**${player.roleName}** [${player.name}], open your eyes.\n\n`;
          let infoText = "";
          
          if (player.charId === 11) { // The Sage
            elderScript += `Point to **TWO people** you want to check. I will tell you if **at least one is evil**.\n\n**${player.name}**, close your eyes.`;
            infoText = "Thumbs UP if at least one is evil, thumbs DOWN if both are good.";
          } else if (player.charId === 12) { // The Oracle
            elderScript += `Point to **ONE person** you want to check. I will tell you if they are **good or evil**.\n\n**${player.name}**, close your eyes.`;
            infoText = "Thumbs UP if good, thumbs DOWN if evil. Note: The Pretender appears GOOD.";
          } else if (player.charId === 13) { // The Sensitive
            elderScript += `Point to **someone**. I will tell you if they have a **night action**.\n\n**${player.name}**, close your eyes.`;
            infoText = "Thumbs UP if they have night action, thumbs DOWN otherwise.";
          } else if (player.charId === 14) { // The Dreamer
            elderScript += `I will show you how many **evil players** sit immediately beside you.\n\n**${player.name}**, close your eyes.`;
            infoText = "Show 0, 1, or 2 fingers for number of evil neighbors.";
          } else if (player.charId === 15) { // The Witness
            elderScript += `Listen carefully for a **cryptic clue** about tonight's events.\n\n**${player.name}**, close your eyes.`;
            infoText = "Give a theatrical clue about night actions without revealing identities.";
          }
          
          nightSteps.push({
            title: `Step 3: ${player.roleName}`,
            phase: "night",
            blocks: [
              { type: "say", text: elderScript },
              { type: "info", text: infoText }
            ]
          });
        });
      }

      // Step 4: Hero-Type - Unified script for each hero
      const heroes = state.players.filter(p => p.type === "hero" && !p.eliminated && !p.blocked && p.hasNightAction);
      
      if (heroes.length > 0) {
        const heroNames = heroes.map(p => `${p.name} (${p.roleName})`).join(", ");
        nightSteps.push({
          title: "Step 4: Hero-Type",
          phase: "night",
          blocks: [
            { type: "say", text: `**Heroes** [${heroNames}], you will each wake individually to protect the village.` }
          ]
        });
        
        // Call each hero with unified script format
        heroes.forEach(player => {
          let heroScript = `**${player.roleName}** [${player.name}], open your eyes.\n\n`;
          let infoText = "";
          
          if (player.charId === 16) { // The Champion
            if (state.specialTrackers.championPowerActive) {
              heroScript += `Point to **someone you want to protect** tonight.\n\n**${player.name}**, close your eyes.`;
              infoText = "If protection triggers: Champion identifies a random villain but LOSES the power permanently.";
            } else {
              heroScript += `Your power has been used. You can no longer protect.\n\n**${player.name}**, close your eyes.`;
              infoText = "The Champion's power ended after successfully blocking an attack.";
            }
          } else if (player.charId === 17) { // The Healer
            heroScript += `Point to **someone you want to save** tonight. **Cannot be the same as last night**.\n\n**${player.name}**, close your eyes.`;
            if (state.nightActions.healerLastProtected !== null) {
              const lastProtected = state.players.find(p => p.id === state.nightActions.healerLastProtected);
              infoText = `Cannot protect ${lastProtected ? lastProtected.name : 'the same player'} again tonight.`;
            }
          } else if (player.charId === 18) { // The Guardian
            heroScript += `Point to **someone to guard**. If they're attacked, **you will die instead** to save them.\n\n**${player.name}**, close your eyes.`;
            infoText = "This is a sacrifice play. The Guardian takes the hit for their chosen player.";
          } else if (player.charId === 20) { // The Defender
            heroScript += `Point to **someone to trap**. If they die tonight, **a random villain dies too**.\n\n**${player.name}**, close your eyes.`;
            infoText = "This creates a trap. Villain team doesn't know until it's too late.";
          }
          
          nightSteps.push({
            title: `Step 4: ${player.roleName}`,
            phase: "night",
            blocks: [
              { type: "say", text: heroScript },
              { type: "info", text: infoText }
            ]
          });
        });
      }

      // Night 1 Special: Loyal Companion sees Champion (before Step 5, per design brief)
      if (state.night === 1 && hasRole(21) && hasRole(16)) {
        const companion = state.players.find(p => p.charId === 21);
        const champion = state.players.find(p => p.charId === 16);
        nightSteps.push({
          title: "Night 1: Loyal Companion Meets Champion",
          phase: "night",
          blocks: [
            { type: "say", text: `**Loyal Companion** [${companion ? companion.name : "Loyal Companion"}], open your eyes.\n\n**Champion** [${champion ? champion.name : "Champion"}], give them a nod.\n\n**Loyal Companion and Champion**, close your eyes.` }
          ]
        });
      }

      // Step 5: Sidekick-Type night check (for those that signal at night) - Skip if none alive
      if (hasType("sidekick")) {
        const sidekicks = state.players.filter(p => p.type === "sidekick" && !p.eliminated).map(p => `${p.name} (${p.roleName})`).join(", ");
        nightSteps.push({
          title: "Step 5: Sidekick-Type",
          phase: "night",
          blocks: [
            { type: "say", text: `**Sidekicks** [${sidekicks}], if you want to use your **day power** tomorrow, give a **silent thumbs-up** now.\n\n**Sidekicks**, hands down.` },
            { type: "info", text: "Note which sidekicks signaled - they will trigger a dice roll during the day phase." }
          ]
        });
      }

      // Night Closing - wake everyone before resolution
      nightSteps.push({
        title: "Night Ends",
        phase: "night",
        blocks: [
          { type: "say", text: theme.script.nightEnds || "The night is over. **Everyone**, open your eyes and look around..." },
          { type: "narrator", text: "**Pause dramatically.** Let the tension build as players look for who might be missing.\n\nNow proceed to the Night Resolution to calculate the outcomes privately." }
        ]
      });

      // Night Resolution - Private calculation step with detailed order
      nightSteps.push({
        title: "Night Resolution (Private)",
        phase: "night",
        blocks: [
          { type: "narrator", text: "**PRIVATE CALCULATION STEP** - Work through this systematically:\n\n**1. BLOCKS:** If Right Hand blocked someone, their ability doesn't activate\n\n**2. VILLAIN TARGET:** Confirm who the villains chose to eliminate\n\n**3. ASSASSIN:** If Assassin used their one-time power, note the second target\n\n**4. PROTECTIONS:** Check each protection in order:\n‚Ä¢ **Champion:** If protecting villain target AND power is active, trigger happens\n‚Ä¢ **Healer:** If protecting villain target AND not same as last night, save succeeds\n‚Ä¢ **Guardian:** If protecting villain target, Guardian DIES but target lives\n‚Ä¢ **Defender:** If trapped player dies, select random villain to die too\n\n**5. SURVIVOR:** If target is The Survivor and hasn't been hit before, they survive until after next vote\n\n**6. STALKER:** If villain target was saved AND Stalker is alive, Stalker can backup-kill (Elder/Damsel types only)\n\n**7. FINAL TALLY:** Count all eliminations including linked deaths (Twins, Cursed)" },
          { type: "action", text: "Use the Action Tracker panel below to record all actions, then click 'Calculate Resolution' for automated results." }
        ],
        showActionTracker: true,
        showResolutionButton: true
      });

      // Day Phase Steps - with unified script format
      const daySteps = [
        {
          title: `Day ${state.night} Dawn`,
          phase: "day",
          blocks: [
            { type: "say", text: theme.script.dayIntro + `\n\n**Death Scene Cue:** ${theme.script.deathScene}` }
          ]
        },
        {
          title: "Announcements & Death Scenes",
          phase: "day",
          blocks: [
            { type: "say", text: `**Build suspense:** "Last night was... eventful..."\n\n**If anyone was eliminated:** Announce dramatically with theme-appropriate language!\n\n**If no one died:** ${theme.script.noDeaths || "Miraculously, everyone survived the night!"}\n\n**Death Scene Cue:** ${theme.script.deathScene}` },
            { type: "info", text: "Give each eliminated player 5-10 seconds for their melodramatic death scene.\n\nCheck for linked deaths: If Twins died, both perform death scenes. If Cursed died, additional victims die too." }
          ]
        },
        {
          title: "Check Win Condition",
          phase: "day",
          blocks: [
            { type: "narrator", text: "**COUNT REMAINING PLAYERS:**\n\n‚Ä¢ If **NO evil players** remain ‚Üí **GOOD WINS** (announce immediately)\n‚Ä¢ If **evil ‚â• good** ‚Üí **EVIL WINS** (announce immediately)\n‚Ä¢ Otherwise ‚Üí Game continues to discussion" },
            { type: "action", text: "Use the 'Check Win Condition' button below for automated checking" }
          ],
          showWinCheckButton: true
        },
        // ACCUSATION PHASE
        {
          title: "Accusation Phase",
          phase: "day",
          blocks: [
            { type: "say", text: `${theme.script.accusationPrompt || "The floor is yours! Who do you suspect?"}\n\n${theme.script.discussionPrompt || "Encourage dramatic accusations!"}` },
            { type: "narrator", text: "**ACCUSATION RULES:**\n\n‚Ä¢ Players take turns making accusations\n‚Ä¢ Each accusation requires a **seconder** to be valid\n‚Ä¢ At 30 seconds, announce **'Final accusations!'**\n\n**Watch for:** The Innocent can reveal once to prove their innocence!" }
          ],
          showNominationTracker: true
        },
        // DEFENSE PHASE
        {
          title: "Defense Phase",
          phase: "day",
          blocks: [
            { type: "say", text: "**The accused shall speak in their defense!**\n\nEach nominated player gets **30 seconds** to defend themselves.\n\n**No interruptions** during defense speeches." }
          ],
          showDefenseTracker: true
        },
        // VOTE PHASE
        {
          title: "Vote Phase",
          phase: "day",
          blocks: [
            { type: "say", text: theme.script.vote },
            { type: "narrator", text: "**VOTE PROCEDURE:**\n\n1. \"All players **close your eyes** and put your hands down\"\n2. \"On my count, raise your hand to vote for [nominee]\"\n3. Count: \"1... 2... 3... **VOTE!**\" (players raise hands)\n4. Count the votes quickly\n5. \"Hands down. Eyes open.\" and announce the count\n6. Repeat for each nominated player" }
          ],
          showVotePhaseTracker: true
        }
      ];
      
      // Add Sidekick Power step if any sidekicks are alive and may use powers
      const aliveSidekicks = state.players.filter(p => 
        !p.eliminated && 
        [21, 22, 23, 24, 25].includes(p.charId)
      );
      
      if (aliveSidekicks.length > 0) {
        const sidekickNames = aliveSidekicks.map(p => `${p.name} (${p.roleName})`).join(", ");
        const sidekickStep = {
          title: "Sidekick Day Powers",
          phase: "day",
          blocks: [
            { type: "say", text: `**Sidekicks** [${sidekickNames}], if you signaled last night, you may now use your **day power**.\n\n**Dice roll required:** Roll 4-6 to succeed, 1-3 to fail.` }
          ]
        };
        
        // Add button for each alive sidekick
        aliveSidekicks.forEach(player => {
          sidekickStep.blocks.push({
            type: "action",
            text: `[${player.name}] - ${player.roleName}`,
            buttonText: "Roll Dice",
            buttonAction: () => triggerSidekickPower(player.id)
          });
        });
        
        daySteps.splice(2, 0, sidekickStep); // Insert after "Accusation Phase" step
      }
      
      // VOTE RESOLUTION PHASE (enhanced with tie handling)
      daySteps.push({
        title: "Vote Resolution",
        phase: "day",
        blocks: [
          { type: "narrator", text: `**VOTE RESOLUTION:**\n\n‚Ä¢ Review the vote counts below\n‚Ä¢ If there's a **TIE**: Choose REVOTE or NO ELIMINATION\n‚Ä¢ Check for **The Marked**: If eliminated, they can demand ONE revote\n‚Ä¢ Check for **The Traitor**: If their marked player was eliminated, Traitor can force revote\n\n**Death Scene Cue:** ${theme.script.deathScene}` }
        ],
        showVoteTracker: true
      });
      
      daySteps.push({
        title: "Apply Vote Aftermath",
        phase: "day",
        blocks: [
          { type: "narrator", text: `**AFTER VOTE ELIMINATION** - Check these in order:\n\n**1. TWINS:** If Twin A or Twin B was eliminated, the other twin **IMMEDIATELY** dies too\n\n**2. CURSED:** If The Cursed was eliminated, random players also die (1-4 victims, can include Evil!)\n\n**3. THE INNOCENT:** Did they reveal during discussion?\n\n**4. SURVIVOR:** If hit last night and survived, they can now be eliminated normally\n\n**Death Scene Cue:** ${theme.script.deathScene}` },
          { type: "action", text: "Mark all eliminated players in the Player Management panel below." }
        ]
      });
      
      daySteps.push({
        title: "Final Win Check",
        phase: "day",
        blocks: [
          { type: "narrator", text: `**FINAL WIN CONDITION CHECK:**\n\n‚Ä¢ If **NO evil players** remain ‚Üí **GOOD WINS!**\n‚Ä¢ If **evil ‚â• good** ‚Üí **EVIL WINS!**\n‚Ä¢ Otherwise ‚Üí Proceed to **Night ${state.night + 1}**` },
          { type: "action", text: "Use 'Check Win Condition' button below or click 'Next Night' to continue" }
        ],
        showWinCheckButton: true
      });

      return [...nightSteps, ...daySteps];
    }

    // Resolution Calculator Functions
    function calculateNightResolution() {
      const actions = state.nightActions;
      const result = {
        actions: [],
        protections: [],
        preDoctorEliminations: [],
        finalEliminations: [],
        specialEvents: [],
        stateChanges: {}
      };

      // Step 1: Record all actions
      if (actions.villainTarget !== null) {
        result.actions.push({
          type: 'target',
          actor: 'Villain Team',
          target: actions.villainTarget
        });
      }

      if (actions.assassinTarget !== null) {
        result.actions.push({
          type: 'target',
          actor: 'Assassin',
          target: actions.assassinTarget
        });
      }

      if (actions.rightHandBlock !== null) {
        result.actions.push({
          type: 'block',
          actor: 'Right Hand',
          target: actions.rightHandBlock
        });
      }

      // Step 2: Apply blocks (prevent blocked players' actions)
      const blockedPlayer = actions.rightHandBlock;
      let championBlocked = false;
      let healerBlocked = false;
      let guardianBlocked = false;
      let defenderBlocked = false;

      if (blockedPlayer !== null) {
        const blocked = state.players.find(p => p.id === blockedPlayer);
        if (blocked) {
          if (blocked.charId === 16) championBlocked = true; // Champion
          if (blocked.charId === 17) healerBlocked = true; // Healer
          if (blocked.charId === 18) guardianBlocked = true; // Guardian
          if (blocked.charId === 20) defenderBlocked = true; // Defender
        }
      }

      // Step 3: Collect targets
      const targets = [];
      if (actions.villainTarget !== null) {
        targets.push({ playerId: actions.villainTarget, source: 'villain' });
      }
      if (actions.assassinTarget !== null) {
        targets.push({ playerId: actions.assassinTarget, source: 'assassin' });
      }

      // Step 4: Apply protections
      const protectedPlayers = new Set();

      // Champion protection
      if (!championBlocked && actions.championProtect !== null && state.specialTrackers.championPowerActive) {
        protectedPlayers.add(actions.championProtect);
        result.protections.push({
          player: actions.championProtect,
          protectedBy: 'Champion',
          triggered: false
        });
      }

      // Healer protection (can't repeat last target)
      if (!healerBlocked && actions.healerProtect !== null && actions.healerProtect !== actions.healerLastProtected) {
        protectedPlayers.add(actions.healerProtect);
        result.protections.push({
          player: actions.healerProtect,
          protectedBy: 'Healer',
          triggered: false
        });
      }

      // Guardian protection
      if (!guardianBlocked && actions.guardianProtect !== null) {
        protectedPlayers.add(actions.guardianProtect);
        result.protections.push({
          player: actions.guardianProtect,
          protectedBy: 'Guardian',
          triggered: false
        });
      }

      // Step 5: Check which protections were triggered
      targets.forEach(target => {
        if (protectedPlayers.has(target.playerId)) {
          const protection = result.protections.find(p => p.player === target.playerId);
          if (protection) {
            protection.triggered = true;

            // Special Champion logic
            if (protection.protectedBy === 'Champion' && state.specialTrackers.championPowerActive) {
              // Both survive, Champion identifies a villain
              const villains = state.players.filter(p => 
                (p.type === 'villain' || p.type === 'accomplice') && 
                p.team === 'evil' && 
                !p.eliminated
              );
              if (villains.length > 0) {
                const randomVillain = villains[Math.floor(Math.random() * villains.length)];
                result.specialEvents.push({
                  type: 'championIdentified',
                  villain: randomVillain.id,
                  villainName: `${randomVillain.name} (${randomVillain.roleName})`
                });
                result.stateChanges['specialTrackers.championIdentifiedVillain'] = randomVillain.id;
              }
              result.specialEvents.push({
                type: 'championPowerLost',
                champion: actions.championProtect
              });
              result.stateChanges['specialTrackers.championPowerActive'] = false;
            }

            // Guardian sacrifice
            if (protection.protectedBy === 'Guardian') {
              const guardian = state.players.find(p => p.charId === 18 && !p.eliminated);
              if (guardian) {
                result.preDoctorEliminations.push({
                  player: guardian.id,
                  playerName: `${guardian.name} (${guardian.roleName})`,
                  cause: 'Guardian Sacrifice'
                });
              }
            }
          }
        } else {
          // Target not protected - add to eliminations
          const targetPlayer = state.players.find(p => p.id === target.playerId);
          if (targetPlayer && !targetPlayer.eliminated) {
            // Check for Survivor passive (char ID 19)
            if (targetPlayer.charId === 19 && !targetPlayer.survivorUsed) {
              result.specialEvents.push({
                type: 'survivorTriggered',
                player: target.playerId,
                playerName: `${targetPlayer.name} (${targetPlayer.roleName})`
              });
              result.stateChanges[`players.${target.playerId}.survivorUsed`] = true;
            } else {
              result.preDoctorEliminations.push({
                player: target.playerId,
                playerName: `${targetPlayer.name} (${targetPlayer.roleName})`,
                cause: target.source === 'assassin' ? 'Assassin' : 'Villain Team'
              });
            }
          }
        }
      });

      // Step 6: Check Defender trap
      if (!defenderBlocked && actions.defenderTrap !== null) {
        const trapped = result.preDoctorEliminations.find(e => e.player === actions.defenderTrap);
        if (trapped) {
          // Defender trap triggered - random villain dies
          const villains = state.players.filter(p => 
            p.type === 'villain' && !p.eliminated
          );
          if (villains.length > 0) {
            const randomVillain = villains[Math.floor(Math.random() * villains.length)];
            result.preDoctorEliminations.push({
              player: randomVillain.id,
              playerName: `${randomVillain.name} (${randomVillain.roleName})`,
              cause: 'Defender Trap'
            });
            result.specialEvents.push({
              type: 'defenderTrapTriggered',
              victim: actions.defenderTrap,
              villain: randomVillain.id
            });
          }
        }
      }

      // Step 7: Check Stalker backup (if primary target was protected and Stalker is in game)
      if (actions.villainTarget !== null && protectedPlayers.has(actions.villainTarget)) {
        const stalker = state.players.find(p => p.charId === 5 && !p.eliminated);
        if (stalker) {
          // Check if stalker backup target was specified
          if (actions.stalkerBackupTarget !== null) {
            const backupTarget = state.players.find(p => p.id === actions.stalkerBackupTarget);
            if (backupTarget && !backupTarget.eliminated) {
              // Stalker backup ONLY works on Elder or Damsel types
              if (backupTarget.type === 'elder' || backupTarget.type === 'damsel') {
                // Check if backup target is protected
                if (!protectedPlayers.has(actions.stalkerBackupTarget)) {
                  // Check for Survivor passive on backup target (char ID 19)
                  if (backupTarget.charId === 19 && !backupTarget.survivorUsed) {
                    result.specialEvents.push({
                      type: 'survivorTriggered',
                      player: backupTarget.id,
                      playerName: `${backupTarget.name} (${backupTarget.roleName})`
                    });
                    result.stateChanges[`players.${backupTarget.id}.survivorUsed`] = true;
                  } else {
                    result.preDoctorEliminations.push({
                      player: backupTarget.id,
                      playerName: `${backupTarget.name} (${backupTarget.roleName})`,
                      cause: 'Stalker Backup Kill'
                    });
                    result.specialEvents.push({
                      type: 'stalkerBackupSuccess',
                      message: `Stalker backup kill succeeded on ${backupTarget.name} (${backupTarget.type})`
                    });
                  }
                } else {
                  result.specialEvents.push({
                    type: 'stalkerBackupBlocked',
                    message: `Stalker backup target (${backupTarget.name}) was also protected!`
                  });
                }
              } else {
                result.specialEvents.push({
                  type: 'stalkerBackupFailed',
                  message: `Stalker backup failed - ${backupTarget.name} is a ${backupTarget.type} (only works on Elder/Damsel)`
                });
              }
            }
          } else {
            result.specialEvents.push({
              type: 'stalkerBackupAttempt',
              message: 'Stalker can attempt backup kill (only works on Damsel/Elder types)'
            });
          }
        }
      }

      // Copy pre-doctor to final eliminations (will be modified if doctor acts)
      result.finalEliminations = [...result.preDoctorEliminations];

      return result;
    }

    function processLinkedDeaths(eliminations) {
      const linkedDeaths = [];
      const processedIds = new Set(eliminations.map(e => e.player));

      eliminations.forEach(elim => {
        const player = state.players.find(p => p.id === elim.player);
        if (!player) return;

        // Check for Twins (char IDs 28, 29)
        if (player.charId === 28 || player.charId === 29) {
          const twinCharId = player.charId === 28 ? 29 : 28;
          const twin = state.players.find(p => p.charId === twinCharId && !p.eliminated && !processedIds.has(p.id));
          if (twin) {
            linkedDeaths.push({
              player: twin.id,
              playerName: `${twin.name} (${twin.roleName})`,
              cause: 'Twin Link'
            });
            processedIds.add(twin.id);
          }
        }

        // Check for Cursed (char ID 30) - random weighted elimination based on remaining players
        if (player.charId === 30) {
          // Calculate victim count based on remaining players (excluding The Cursed and already processed)
          const alivePlayers = state.players.filter(p => !p.eliminated && p.id !== player.id && !processedIds.has(p.id));
          const aliveCount = alivePlayers.length;
          
          let victimCount;
          if (aliveCount >= 24) victimCount = 4;
          else if (aliveCount >= 18) victimCount = 3;
          else if (aliveCount >= 12) victimCount = 2;
          else victimCount = 1; // Minimum 1 victim
          
          // Separate into Evil and Good pools
          let aliveEvil = alivePlayers.filter(p => p.team === 'evil');
          let aliveGood = alivePlayers.filter(p => p.team === 'good');
          
          // Select victims with independent weighted rolls
          for (let i = 0; i < victimCount; i++) {
            if (aliveEvil.length === 0 && aliveGood.length === 0) break;
            
            const targetEvil = Math.random() < 0.33; // Independent 1-in-3 chance
            let victim = null;
            
            if (targetEvil && aliveEvil.length > 0) {
              const randomIndex = Math.floor(Math.random() * aliveEvil.length);
              victim = aliveEvil.splice(randomIndex, 1)[0];
            } else if (aliveGood.length > 0) {
              const randomIndex = Math.floor(Math.random() * aliveGood.length);
              victim = aliveGood.splice(randomIndex, 1)[0];
            } else if (aliveEvil.length > 0) {
              // Fallback if no Good players left
              const randomIndex = Math.floor(Math.random() * aliveEvil.length);
              victim = aliveEvil.splice(randomIndex, 1)[0];
            }
            
            if (victim) {
              linkedDeaths.push({
                player: victim.id,
                playerName: `${victim.name} (${victim.roleName})`,
                cause: 'Cursed Explosion'
              });
              processedIds.add(victim.id);
            }
          }
        }
      });

      return linkedDeaths;
    }

    function showResolutionSummary(result) {
      const summaryDiv = document.createElement('div');
      summaryDiv.className = 'resolution-summary';
      summaryDiv.innerHTML = `
        <h3>üìä Night Resolution Summary</h3>
        <div class="resolution-section">
          <h4>üéØ Actions Taken:</h4>
          ${result.actions.map(a => `<p>‚Ä¢ ${a.actor} ‚Üí Player ${a.target + 1}</p>`).join('')}
        </div>
        <div class="resolution-section">
          <h4>üõ°Ô∏è Protections:</h4>
          ${result.protections.map(p => {
            const player = state.players.find(pl => pl.id === p.player);
            return `<p>‚Ä¢ Player ${p.player + 1} (${player ? player.roleName : 'Unknown'}) protected by ${p.protectedBy}${p.triggered ? ' ‚úì TRIGGERED' : ''}</p>`;
          }).join('') || '<p>None</p>'}
        </div>
        <div class="resolution-section">
          <h4>‚ö†Ô∏è Special Events:</h4>
          ${result.specialEvents.map(e => {
            if (e.type === 'championIdentified') {
              return `<p class="special-event">‚Ä¢ Champion identified villain: ${e.villainName}</p>`;
            }
            if (e.type === 'championPowerLost') {
              return `<p class="special-event">‚Ä¢ Champion loses power permanently</p>`;
            }
            if (e.type === 'survivorTriggered') {
              return `<p class="special-event">‚Ä¢ ${e.playerName} survived attack (Survivor passive)</p>`;
            }
            if (e.type === 'defenderTrapTriggered') {
              return `<p class="special-event">‚Ä¢ Defender trap killed a villain!</p>`;
            }
            if (e.type === 'stalkerBackupSuccess') {
              return `<p class="special-event" style="color: var(--accent-evil);">‚Ä¢ üó°Ô∏è ${e.message}</p>`;
            }
            if (e.type === 'stalkerBackupFailed') {
              return `<p class="special-event" style="color: var(--accent-neutral);">‚Ä¢ ‚ö†Ô∏è ${e.message}</p>`;
            }
            if (e.type === 'stalkerBackupBlocked') {
              return `<p class="special-event" style="color: var(--accent-good);">‚Ä¢ üõ°Ô∏è ${e.message}</p>`;
            }
            if (e.type === 'stalkerBackupAttempt') {
              return `<p class="special-event" style="color: var(--accent-neutral);">‚Ä¢ üëÅÔ∏è ${e.message}</p>`;
            }
            return `<p class="special-event">‚Ä¢ ${e.message || JSON.stringify(e)}</p>`;
          }).join('') || '<p>None</p>'}
        </div>
        <div class="resolution-section">
          <h4>üíÄ Pending Eliminations:</h4>
          ${result.preDoctorEliminations.map(e => `<p class="elimination">‚Ä¢ ${e.playerName} (${e.cause})</p>`).join('') || '<p>No eliminations</p>'}
        </div>
      `;
      return summaryDiv;
    }

    function applyResolution(result) {
      // Apply state changes
      Object.entries(result.stateChanges).forEach(([key, value]) => {
        if (key.startsWith('specialTrackers.')) {
          const trackerKey = key.replace('specialTrackers.', '');
          state.specialTrackers[trackerKey] = value;
        } else if (key.startsWith('players.')) {
          const match = key.match(/players\.(\d+)\.(.+)/);
          if (match) {
            const playerId = parseInt(match[1]);
            const prop = match[2];
            const player = state.players.find(p => p.id === playerId);
            if (player) {
              player[prop] = value;
            }
          }
        }
      });

      // Apply eliminations
      result.finalEliminations.forEach(elim => {
        const player = state.players.find(p => p.id === elim.player);
        if (player) {
          player.eliminated = true;
        }
      });

      // Process linked deaths
      const linkedDeaths = processLinkedDeaths(result.finalEliminations);
      linkedDeaths.forEach(death => {
        const player = state.players.find(p => p.id === death.player);
        if (player) {
          player.eliminated = true;
        }
        result.finalEliminations.push(death);
      });

      // Broadcast eliminations to projector
      broadcastPlayersEliminated();

      // Store result
      state.resolutionResult = result;

      // Clear night actions for next night
      if (result.finalEliminations.length > 0 || result.specialEvents.length > 0) {
        // Update healer's last protected
        if (state.nightActions.healerProtect !== null) {
          state.nightActions.healerLastProtected = state.nightActions.healerProtect;
        }
      }

      persistState();
      
      // Check win condition after eliminations
      checkWinCondition();
    }

    function renderScript() {
      const steps = buildScriptSteps();
      const step = steps[state.stepIndex];
      scriptStepsContainer.innerHTML = "";
      if (!step) {
        scriptTitle.textContent = "End of Phase";
        phaseLabel.textContent = "Summary";
        scriptStepsContainer.innerHTML = "<p>All steps complete. Advance when ready for the next night.";
      } else {
        scriptTitle.textContent = step.title;
        phaseLabel.textContent = PHASES[step.phase] || "Script";
        
        // Update audio phase if it changed
        if (step.phase && step.phase !== state.audio.phase) {
          updateAudioPhase(step.phase);
        }
        // Broadcast phase change if it changed and play sound effect
        if (state.phase !== step.phase) {
          // Play phase change sound
          if (step.phase === 'night') {
            playNightStartSound();
            // Hide voting display on projector during night
            broadcastVotingUpdate(false, null, []);
          } else if (step.phase === 'day') {
            playDayStartSound();
          }
          state.phase = step.phase;
          broadcastPhaseChange(state.phase, state.night);
          // Update layout based on phase
          const gameGrid = document.querySelector("#game-section .game-grid");
          if (gameGrid) {
            gameGrid.setAttribute('data-phase', state.phase);
          }
        }
        
        step.blocks.forEach(block => {
          const div = document.createElement("div");
          div.className = `script-block block-${block.type}`;
          
          // Format the text with line breaks, bold guidance, and colored character names
          let formattedText = block.text
            // Escape HTML first for safety
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            // Convert newlines to <br> tags
            .replace(/\n/g, '<br>')
            // Bold text using **text** syntax (non-greedy, handles multiline)
            .replace(/\*\*([^*]+)\*\*/g, '<span class="guidance">$1</span>')
            // Highlight character names in brackets [Name (Role)]
            .replace(/\[([^\]]+)\]/g, '<span class="character-names">[$1]</span>');
          
          div.innerHTML = formattedText;
          
          // If this block has a button action, add a button
          if (block.buttonAction && block.buttonText) {
            const button = document.createElement('button');
            button.textContent = block.buttonText;
            button.className = 'pill';
            button.style.marginLeft = '1rem';
            button.onclick = async () => {
              await block.buttonAction();
              renderPlayers();
              updateCounts();
            };
            div.appendChild(button);
          }
          
          scriptStepsContainer.append(div);
        });

        // Add action tracker if this step needs it
        if (step.showActionTracker) {
          const actionTracker = createActionTracker();
          scriptStepsContainer.append(actionTracker);
        }

        // Add nomination tracker if this step needs it
        if (step.showNominationTracker) {
          const nominationTracker = createNominationTracker();
          scriptStepsContainer.append(nominationTracker);
          // Broadcast voting phase to projector
          broadcastVotingUpdate(true, 'nomination', state.voting.nominations);
        }

        // Add defense tracker if this step needs it
        if (step.showDefenseTracker) {
          const defenseTracker = createDefenseTracker();
          scriptStepsContainer.append(defenseTracker);
          // Broadcast voting phase to projector
          broadcastVotingUpdate(true, 'defense', state.voting.nominations);
        }

        // Add vote phase tracker if this step needs it
        if (step.showVotePhaseTracker) {
          const votePhaseTracker = createVotePhaseTracker();
          scriptStepsContainer.append(votePhaseTracker);
          // Broadcast voting phase to projector
          broadcastVotingUpdate(true, 'vote', state.voting.nominations);
        }

        // Add vote tracker if this step needs it
        if (step.showVoteTracker) {
          const voteTracker = createVoteTracker();
          scriptStepsContainer.append(voteTracker);
        }

        // Add resolution button if this step needs it
        if (step.showResolutionButton) {
          const resolutionButton = document.createElement('button');
          resolutionButton.textContent = 'üìä Calculate Night Resolution';
          resolutionButton.className = 'resolution-calc-btn';
          resolutionButton.style.marginTop = '1rem';
          resolutionButton.style.width = '100%';
          resolutionButton.onclick = () => {
            const result = calculateNightResolution();
            applyResolution(result);
            const summary = showResolutionSummary(result);
            
            // Insert summary before the button
            const existingSummary = scriptStepsContainer.querySelector('.resolution-summary');
            if (existingSummary) {
              existingSummary.remove();
            }
            scriptStepsContainer.insertBefore(summary, resolutionButton);
            renderPlayers();
            updateCounts();
          };
          scriptStepsContainer.append(resolutionButton);
        }

        // Add win check button if this step needs it
        if (step.showWinCheckButton) {
          const winCheckButton = document.createElement('button');
          winCheckButton.textContent = 'üèÜ Check Win Condition';
          winCheckButton.className = 'resolution-calc-btn';
          winCheckButton.style.marginTop = '1rem';
          winCheckButton.style.width = '100%';
          winCheckButton.onclick = () => {
            checkWinCondition();
          };
          scriptStepsContainer.append(winCheckButton);
        }

        // Show existing resolution if available
        if (state.resolutionResult && step.title === "Night Resolution (Private)") {
          const summary = showResolutionSummary(state.resolutionResult);
          scriptStepsContainer.append(summary);
        }
      }

      prevStepButton.disabled = state.stepIndex === 0;
      nextStepButton.textContent = state.stepIndex >= steps.length - 1 ? "Next Night" : "Next";

      const accusationIndex = steps.findIndex(step => step.title === "Accusation Phase");
      if (accusationIndex >= 0 && state.stepIndex >= accusationIndex) {
        timerPhase.textContent = "Voting Timer";
      } else {
        timerPhase.textContent = "Timer";
      }
    }

    function createActionTracker() {
      const tracker = document.createElement('div');
      tracker.className = 'action-tracker';
      
      const alivePlayers = state.players.filter(p => !p.eliminated);
      const playerOptions = alivePlayers.map(p => 
        `<option value="${p.id}">${p.name} (${p.roleName})</option>`
      ).join('');

      tracker.innerHTML = `
        <h4>Action Tracker</h4>
        <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1rem;">
          Record the actions taken during this night phase. The resolution calculator will process them automatically.
        </p>
        
        <label>Villain Target:</label>
        <select id="action-villain-target">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Assassin Target (if used):</label>
        <select id="action-assassin-target">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Champion Protected:</label>
        <select id="action-champion-protect">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Healer Protected:</label>
        <select id="action-healer-protect">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Guardian Protected:</label>
        <select id="action-guardian-protect">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Defender Trapped:</label>
        <select id="action-defender-trap">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Right Hand Blocked:</label>
        <select id="action-right-hand-block">
          <option value="">-- None --</option>
          ${playerOptions}
        </select>

        <label>Stalker Backup Target (if main target protected):</label>
        <select id="action-stalker-backup">
          <option value="">-- None --</option>
          ${alivePlayers.filter(p => p.type === 'elder' || p.type === 'damsel').map(p => 
            `<option value="${p.id}">${p.name} (${p.roleName}) [${p.type.toUpperCase()}]</option>`
          ).join('')}
        </select>
        <small style="display: block; color: var(--text-secondary); margin-bottom: 1rem;">‚ö†Ô∏è Stalker backup ONLY works on Elder or Damsel types!</small>

        <div class="action-buttons">
          <button onclick="saveNightActions()" style="background: linear-gradient(135deg, rgba(34, 211, 238, 0.7), rgba(56, 189, 248, 0.9));">
            üíæ Save Actions
          </button>
          <button onclick="clearNightActions()" style="background: linear-gradient(135deg, rgba(148, 163, 184, 0.5), rgba(100, 116, 139, 0.7));">
            üóëÔ∏è Clear All
          </button>
        </div>
      `;

      // Load existing actions if any
      setTimeout(() => {
        if (state.nightActions.villainTarget !== null) {
          document.getElementById('action-villain-target').value = state.nightActions.villainTarget;
        }
        if (state.nightActions.assassinTarget !== null) {
          document.getElementById('action-assassin-target').value = state.nightActions.assassinTarget;
        }
        if (state.nightActions.championProtect !== null) {
          document.getElementById('action-champion-protect').value = state.nightActions.championProtect;
        }
        if (state.nightActions.healerProtect !== null) {
          document.getElementById('action-healer-protect').value = state.nightActions.healerProtect;
        }
        if (state.nightActions.guardianProtect !== null) {
          document.getElementById('action-guardian-protect').value = state.nightActions.guardianProtect;
        }
        if (state.nightActions.defenderTrap !== null) {
          document.getElementById('action-defender-trap').value = state.nightActions.defenderTrap;
        }
        if (state.nightActions.rightHandBlock !== null) {
          document.getElementById('action-right-hand-block').value = state.nightActions.rightHandBlock;
        }
        if (state.nightActions.stalkerBackupTarget !== null) {
          document.getElementById('action-stalker-backup').value = state.nightActions.stalkerBackupTarget;
        }
      }, 0);

      return tracker;
    }

    function saveNightActions() {
      const villainTarget = document.getElementById('action-villain-target').value;
      const assassinTarget = document.getElementById('action-assassin-target').value;
      const championProtect = document.getElementById('action-champion-protect').value;
      const healerProtect = document.getElementById('action-healer-protect').value;
      const guardianProtect = document.getElementById('action-guardian-protect').value;
      const defenderTrap = document.getElementById('action-defender-trap').value;
      const rightHandBlock = document.getElementById('action-right-hand-block').value;
      const stalkerBackup = document.getElementById('action-stalker-backup').value;

      state.nightActions.villainTarget = villainTarget ? parseInt(villainTarget) : null;
      state.nightActions.assassinTarget = assassinTarget ? parseInt(assassinTarget) : null;
      state.nightActions.championProtect = championProtect ? parseInt(championProtect) : null;
      state.nightActions.healerProtect = healerProtect ? parseInt(healerProtect) : null;
      state.nightActions.guardianProtect = guardianProtect ? parseInt(guardianProtect) : null;
      state.nightActions.defenderTrap = defenderTrap ? parseInt(defenderTrap) : null;
      state.nightActions.rightHandBlock = rightHandBlock ? parseInt(rightHandBlock) : null;
      state.nightActions.stalkerBackupTarget = stalkerBackup ? parseInt(stalkerBackup) : null;

      persistState();
      alert('‚úì Night actions saved! Now click "Calculate Night Resolution" to see the results.');
    }

    function clearNightActions() {
      if (confirm('Clear all recorded actions for this night?')) {
        state.nightActions = {
          villainTarget: null,
          assassinTarget: null,
          stalkerActive: false,
          stalkerBackupTarget: null,
          championProtect: null,
          healerProtect: null,
          guardianProtect: null,
          defenderTrap: null,
          rightHandBlock: null,
          healerLastProtected: state.nightActions.healerLastProtected
        };
        state.resolutionResult = null;
        persistState();
        renderScript();
      }
    }

    // VOTING MECHANICS TRACKERS

    function createNominationTracker() {
      const tracker = document.createElement('div');
      tracker.className = 'action-tracker';
      
      const alivePlayers = state.players.filter(p => !p.eliminated);
      
      // Build nomination checkboxes for each player
      const nominationInputs = alivePlayers.map(p => {
        const isNominated = state.voting.nominations.includes(p.id);
        const isSilenced = state.silencedPlayer === p.id;
        
        return `
          <div class="nomination-item" style="display: flex; gap: 0.75rem; align-items: center; margin: 0.5rem 0; padding: 0.5rem; border-radius: 8px; background: ${isNominated ? 'rgba(244, 114, 182, 0.15)' : 'transparent'}; border: 1px solid ${isNominated ? 'var(--accent-evil)' : 'transparent'};">
            <input 
              type="checkbox" 
              id="nominate-${p.id}" 
              ${isNominated ? 'checked' : ''}
              style="width: 20px; height: 20px; accent-color: var(--accent-evil);"
              onchange="toggleNomination(${p.id})"
            />
            <label for="nominate-${p.id}" style="flex: 1; cursor: pointer;">
              <strong>${p.name}</strong> <span style="color: var(--text-secondary);">(${p.roleName})</span>
            </label>
            ${isSilenced ? '<span style="color: var(--accent-evil); font-size: 0.85rem;" title="Cannot vote - Silenced by Manipulator">üîá Silenced</span>' : ''}
          </div>
        `;
      }).join('');

      const nominatedCount = state.voting.nominations.length;
      
      tracker.innerHTML = `
        <h4>üìã Nomination Tracker</h4>
        <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1rem;">
          Check the box next to any player who has been nominated (and seconded) for elimination.
        </p>
        
        <div style="margin-bottom: 1rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px;">
          <strong>Nominated Players:</strong> <span id="nomination-count" style="color: var(--accent-evil); font-size: 1.1rem;">${nominatedCount}</span>
        </div>
        
        ${nominationInputs}
        
        <div class="action-buttons" style="margin-top: 1rem;">
          <button onclick="clearNominations()" style="background: linear-gradient(135deg, rgba(148, 163, 184, 0.5), rgba(100, 116, 139, 0.7));">
            üóëÔ∏è Clear All Nominations
          </button>
        </div>
      `;

      return tracker;
    }

    function toggleNomination(playerId) {
      const index = state.voting.nominations.indexOf(playerId);
      if (index > -1) {
        state.voting.nominations.splice(index, 1);
      } else {
        state.voting.nominations.push(playerId);
      }
      persistState();
      renderScript();
      // Broadcast to projector
      broadcastVotingUpdate(true, 'nomination', state.voting.nominations);
    }

    function clearNominations() {
      if (confirm('Clear all nominations?')) {
        state.voting.nominations = [];
        persistState();
        renderScript();
        // Broadcast to projector
        broadcastVotingUpdate(true, 'nomination', []);
      }
    }

    function createDefenseTracker() {
      const tracker = document.createElement('div');
      tracker.className = 'action-tracker';
      
      const nominatedPlayers = state.players.filter(p => 
        !p.eliminated && state.voting.nominations.includes(p.id)
      );
      
      if (nominatedPlayers.length === 0) {
        tracker.innerHTML = `
          <h4>üõ°Ô∏è Defense Tracker</h4>
          <div style="padding: 1rem; text-align: center; color: var(--text-secondary); font-style: italic;">
            No players have been nominated yet. Go back to the Accusation Phase to nominate suspects.
          </div>
        `;
        return tracker;
      }
      
      const defenseOrder = nominatedPlayers.map((p, index) => {
        const isCurrentDefender = state.voting.accusedPlayer === p.id;
        const isSilenced = state.silencedPlayer === p.id;
        
        return `
          <div class="defense-item" style="display: flex; gap: 0.75rem; align-items: center; margin: 0.5rem 0; padding: 0.75rem; border-radius: 10px; background: ${isCurrentDefender ? 'rgba(56, 189, 248, 0.2)' : 'rgba(15, 23, 42, 0.5)'}; border: 2px solid ${isCurrentDefender ? 'var(--accent-good)' : 'transparent'};">
            <div style="width: 30px; height: 30px; border-radius: 50%; background: var(--accent-evil); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold;">
              ${index + 1}
            </div>
            <div style="flex: 1;">
              <strong>${p.name}</strong> <span style="color: var(--text-secondary);">(${p.roleName})</span>
              ${isSilenced ? '<span style="color: var(--accent-evil); font-size: 0.85rem; margin-left: 0.5rem;">üîá Silenced</span>' : ''}
              ${isCurrentDefender ? '<span style="color: var(--accent-good); font-size: 0.85rem; margin-left: 0.5rem;">üé§ SPEAKING</span>' : ''}
            </div>
            <button onclick="setCurrentDefender(${p.id})" style="padding: 0.4rem 0.8rem; font-size: 0.8rem; ${isCurrentDefender ? 'opacity: 0.5;' : ''}">
              ${isCurrentDefender ? '‚úì Active' : 'Select'}
            </button>
          </div>
        `;
      }).join('');

      tracker.innerHTML = `
        <h4>üõ°Ô∏è Defense Tracker</h4>
        <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1rem;">
          Each nominated player gets 30 seconds to defend themselves. Click "Select" to highlight the current speaker.
        </p>
        
        <div style="margin-bottom: 1rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
          <span><strong>Accused Players:</strong> ${nominatedPlayers.length}</span>
          <span style="color: var(--text-secondary);">30 seconds each</span>
        </div>
        
        ${defenseOrder}
        
        <div class="action-buttons" style="margin-top: 1rem;">
          <button onclick="clearCurrentDefender()" style="background: linear-gradient(135deg, rgba(148, 163, 184, 0.5), rgba(100, 116, 139, 0.7));">
            Clear Selection
          </button>
        </div>
      `;

      return tracker;
    }

    function setCurrentDefender(playerId) {
      state.voting.accusedPlayer = playerId;
      persistState();
      renderScript();
    }

    function clearCurrentDefender() {
      state.voting.accusedPlayer = null;
      persistState();
      renderScript();
    }

    function createVotePhaseTracker() {
      const tracker = document.createElement('div');
      tracker.className = 'action-tracker';
      
      const nominatedPlayers = state.players.filter(p => 
        !p.eliminated && state.voting.nominations.includes(p.id)
      );
      
      const alivePlayers = state.players.filter(p => !p.eliminated);
      
      // Check for Corrupted Authority and Silenced players
      const corruptedPlayer = alivePlayers.find(p => p.charId === 4);
      const silencedPlayerObj = alivePlayers.find(p => p.id === state.silencedPlayer);
      
      if (nominatedPlayers.length === 0) {
        tracker.innerHTML = `
          <h4>üó≥Ô∏è Vote Phase Tracker</h4>
          <div style="padding: 1rem; text-align: center; color: var(--text-secondary); font-style: italic;">
            No players have been nominated yet. Go back to the Accusation Phase to nominate suspects.
          </div>
        `;
        return tracker;
      }
      
      // Build vote count inputs for each nominated player
      const voteInputs = nominatedPlayers.map(p => {
        return `
          <div class="vote-item" style="display: flex; gap: 0.75rem; align-items: center; margin: 0.5rem 0; padding: 0.75rem; border-radius: 10px; background: rgba(15, 23, 42, 0.5); border: 1px solid rgba(148, 163, 184, 0.2);">
            <div style="flex: 1;">
              <strong>${p.name}</strong> <span style="color: var(--text-secondary);">(${p.roleName})</span>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <label style="font-size: 0.85rem; color: var(--text-secondary);">Votes:</label>
              <input 
                type="number" 
                id="vote-phase-${p.id}" 
                min="0" 
                max="50" 
                value="0" 
                style="width: 60px; padding: 0.35rem; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: inherit;"
                oninput="updateVotePhase()"
              />
            </div>
          </div>
        `;
      }).join('');

      // Build voter list with silenced indicator
      const voterIndicators = alivePlayers.map(p => {
        const isCorrupted = p.charId === 4;
        const isSilenced = state.silencedPlayer === p.id;
        
        return `
          <span style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.25rem 0.5rem; margin: 0.15rem; border-radius: 999px; font-size: 0.75rem; background: ${isSilenced ? 'rgba(244, 114, 182, 0.2)' : isCorrupted ? 'rgba(250, 204, 21, 0.2)' : 'rgba(56, 189, 248, 0.1)'}; border: 1px solid ${isSilenced ? 'var(--accent-evil)' : isCorrupted ? 'var(--accent-neutral)' : 'transparent'};">
            ${p.name}
            ${isCorrupted ? '<span title="Corrupted Authority - Double Vote">√ó2</span>' : ''}
            ${isSilenced ? '<span title="Silenced - Cannot Vote">üîá</span>' : ''}
          </span>
        `;
      }).join('');

      tracker.innerHTML = `
        <h4>üó≥Ô∏è Vote Phase Tracker</h4>
        
        <div style="margin-bottom: 1rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px;">
          <div style="margin-bottom: 0.5rem;"><strong>Show/Hide Hands Voting:</strong></div>
          <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 0.75rem;">
            1. "Eyes closed, hands down"<br>
            2. Call each nominee's name<br>
            3. "Raise hand to vote for [Name]... NOW!"<br>
            4. Count hands, then "Hands down"
          </div>
          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
            <button onclick="toggleVotesVisible()" style="padding: 0.5rem 1rem;">
              ${state.voting.votesVisible ? 'üëÅÔ∏è Votes VISIBLE' : 'üôà Votes HIDDEN'}
            </button>
          </div>
        </div>
        
        <div style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(15, 23, 42, 0.4); border-radius: 8px;">
          <div style="margin-bottom: 0.5rem; font-size: 0.85rem;"><strong>Voters:</strong></div>
          <div style="display: flex; flex-wrap: wrap; gap: 0.25rem;">
            ${voterIndicators}
          </div>
          ${corruptedPlayer ? `<div style="margin-top: 0.5rem; color: var(--accent-neutral); font-size: 0.85rem;">‚ö†Ô∏è ${corruptedPlayer.name}'s vote counts DOUBLE (auto-calculated)</div>` : ''}
          ${silencedPlayerObj ? `<div style="margin-top: 0.5rem; color: var(--accent-evil); font-size: 0.85rem;">üîá ${silencedPlayerObj.name} CANNOT vote (silenced)</div>` : ''}
        </div>
        
        <div style="margin-bottom: 0.5rem;"><strong>Vote Count per Nominee:</strong></div>
        ${voteInputs}
        
        <div id="vote-phase-tally" style="margin-top: 1rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
          <h5 style="margin: 0 0 0.5rem;">üìä Current Tally</h5>
          <div id="vote-phase-results" style="font-family: monospace; font-size: 0.9rem;">Enter votes above to see results</div>
        </div>
        
        <div class="action-buttons" style="margin-top: 1rem;">
          <button onclick="updateVotePhase()" style="background: linear-gradient(135deg, rgba(34, 211, 238, 0.7), rgba(56, 189, 248, 0.9));">
            üìä Update Tally
          </button>
          <button onclick="clearVotePhase()" style="background: linear-gradient(135deg, rgba(148, 163, 184, 0.5), rgba(100, 116, 139, 0.7));">
            üóëÔ∏è Clear Votes
          </button>
        </div>
      `;

      // Add event listeners after render
      setTimeout(() => updateVotePhase(), 0);

      return tracker;
    }

    function toggleVotesVisible() {
      state.voting.votesVisible = !state.voting.votesVisible;
      persistState();
      renderScript();
    }

    function updateVotePhase() {
      const nominatedPlayers = state.players.filter(p => 
        !p.eliminated && state.voting.nominations.includes(p.id)
      );
      
      const results = [];
      nominatedPlayers.forEach(p => {
        const input = document.getElementById(`vote-phase-${p.id}`);
        if (input) {
          const votes = parseInt(input.value) || 0;
          results.push({ player: p, votes: votes });
        }
      });
      
      // Sort by votes descending
      results.sort((a, b) => b.votes - a.votes);
      
      const resultsEl = document.getElementById('vote-phase-results');
      if (!resultsEl) return;
      
      if (results.length === 0 || results.every(r => r.votes === 0)) {
        resultsEl.innerHTML = '<div style="color: var(--text-secondary);">Enter votes above to see results</div>';
        return;
      }
      
      let html = '';
      results.forEach((r, index) => {
        if (r.votes > 0) {
          const isFirst = index === 0;
          const style = isFirst ? 'color: var(--accent-evil); font-weight: bold;' : '';
          html += `<div style="${style}">${index + 1}. ${r.player.name}: ${r.votes} votes</div>`;
        }
      });
      
      // Check for tie
      const firstPlace = results[0];
      const secondPlace = results[1];
      
      if (firstPlace && firstPlace.votes > 0) {
        html += '<hr style="margin: 0.5rem 0; opacity: 0.3;">';
        
        if (secondPlace && secondPlace.votes === firstPlace.votes) {
          // TIE!
          const tiedPlayers = results.filter(r => r.votes === firstPlace.votes);
          state.voting.tiedPlayers = tiedPlayers.map(r => r.player.id);
          
          html += `<div style="color: var(--accent-neutral); font-weight: bold; margin-top: 0.5rem;">
            ‚ö†Ô∏è TIE between ${tiedPlayers.map(r => r.player.name).join(' and ')}!
          </div>`;
          html += `<div style="margin-top: 0.5rem;">
            <button onclick="handleTieRevote()" style="margin-right: 0.5rem; padding: 0.4rem 0.8rem; font-size: 0.85rem;">üîÑ REVOTE</button>
            <button onclick="handleTieNoElimination()" style="padding: 0.4rem 0.8rem; font-size: 0.85rem;">‚ùå NO ELIMINATION</button>
          </div>`;
        } else {
          // Clear winner
          state.voting.tiedPlayers = [];
          html += `<div style="color: var(--accent-evil); margin-top: 0.5rem;">
            ‚Üí ${firstPlace.player.name} is to be ELIMINATED
          </div>`;
          
          // Check for The Marked (char ID 26)
          if (firstPlace.player.charId === 26 && !state.markedRevoteUsed) {
            html += `<div style="color: var(--accent-good); margin-top: 0.5rem; padding: 0.5rem; background: rgba(168, 85, 247, 0.2); border-radius: 8px;">
              ‚ö†Ô∏è <strong>The Marked (${firstPlace.player.name})</strong> can demand a REVOTE!
              <button onclick="triggerMarkedRevote(${firstPlace.player.id})" style="margin-left: 0.5rem; padding: 0.4rem 0.8rem; font-size: 0.85rem;">üîÑ Trigger Revote</button>
              <button onclick="skipMarkedRevote()" style="margin-left: 0.25rem; padding: 0.4rem 0.8rem; font-size: 0.85rem;">‚ùå Skip</button>
            </div>`;
          }
          
          // Check for Traitor's marked player (char ID 9)
          const traitor = state.players.find(p => p.charId === 9 && !p.eliminated);
          if (traitor && state.markedPlayer === firstPlace.player.id && !state.traitorRevoteUsed) {
            html += `<div style="color: var(--accent-evil); margin-top: 0.5rem; padding: 0.5rem; background: rgba(251, 113, 133, 0.2); border-radius: 8px;">
              ‚ö†Ô∏è <strong>The Traitor (${traitor.name})</strong> can force a REVOTE!
              <button onclick="triggerTraitorRevote(${traitor.id})" style="margin-left: 0.5rem; padding: 0.4rem 0.8rem; font-size: 0.85rem;">üîÑ Force Revote</button>
              <button onclick="skipTraitorRevote()" style="margin-left: 0.25rem; padding: 0.4rem 0.8rem; font-size: 0.85rem;">‚ùå Skip</button>
            </div>`;
          }
          
          // Voice double elimination check (char ID 22)
          const voice = state.players.find(p => p.charId === 22 && !p.eliminated);
          const secondPlace = results[1];
          if (voice && secondPlace && secondPlace.votes > 0 && !state.voicePowerUsed) {
            html += `<div style="color: var(--accent-good); margin-top: 0.5rem; padding: 0.5rem; background: rgba(190, 242, 100, 0.2); border-radius: 8px;">
              üé§ <strong>The Voice (${voice.name})</strong> can attempt DOUBLE ELIMINATION!
              <button onclick="triggerVoicePower(${voice.id}, ${secondPlace.player.id})" style="margin-left: 0.5rem; padding: 0.4rem 0.8rem; font-size: 0.85rem;">üé≤ Roll Dice</button>
            </div>`;
          }
        }
      }
      
      resultsEl.innerHTML = html;
      persistState();
    }

    function handleTieRevote() {
      state.voting.revoteCount++;
      clearVotePhase();
      // Show inline notification in the results area
      const resultsEl = document.getElementById('vote-phase-results');
      if (resultsEl) {
        resultsEl.innerHTML = `<div style="color: var(--accent-good); font-weight: bold; padding: 0.5rem; background: rgba(56, 189, 248, 0.15); border-radius: 8px; text-align: center;">
          üîÑ Revote #${state.voting.revoteCount} called! Votes cleared. Conduct a new vote.
        </div>`;
      }
    }

    function handleTieNoElimination() {
      state.voting.tiedPlayers = [];
      persistState();
      // Show inline notification in the results area
      const resultsEl = document.getElementById('vote-phase-results');
      if (resultsEl) {
        resultsEl.innerHTML = `<div style="color: var(--accent-neutral); font-weight: bold; padding: 0.5rem; background: rgba(250, 204, 21, 0.15); border-radius: 8px; text-align: center;">
          ‚ùå No elimination this round. Proceed to the next phase.
        </div>`;
      }
    }

    function clearVotePhase() {
      const nominatedPlayers = state.players.filter(p => 
        !p.eliminated && state.voting.nominations.includes(p.id)
      );
      
      nominatedPlayers.forEach(p => {
        const input = document.getElementById(`vote-phase-${p.id}`);
        if (input) {
          input.value = '0';
        }
      });
      
      state.voting.tiedPlayers = [];
      updateVotePhase();
      persistState();
    }

    // The Marked revote mechanic (char ID 26)
    function triggerMarkedRevote(playerId) {
      const markedPlayer = state.players.find(p => p.id === playerId);
      if (!markedPlayer) return;
      
      state.markedRevoteUsed = true;
      state.voting.revoteCount++;
      clearVotePhase();
      
      const resultsEl = document.getElementById('vote-phase-results');
      if (resultsEl) {
        resultsEl.innerHTML = `<div style="color: var(--accent-good); font-weight: bold; padding: 0.75rem; background: rgba(168, 85, 247, 0.2); border-radius: 8px; text-align: center;">
          üé≠ <strong>THE MARKED DEMANDS A REVOTE!</strong><br>
          <em>${markedPlayer.name} reveals their mark of fate. All previous votes are cancelled!</em><br>
          Conduct a complete new vote. The Marked can no longer use this power.
        </div>`;
      }
      persistState();
    }

    function skipMarkedRevote() {
      state.markedRevoteUsed = true; // Power is forfeited
      persistState();
      updateVotePhase();
    }

    // The Traitor revote mechanic (char ID 9)
    function triggerTraitorRevote(traitorId) {
      const traitor = state.players.find(p => p.id === traitorId);
      if (!traitor) return;
      
      state.traitorRevoteUsed = true;
      state.voting.revoteCount++;
      clearVotePhase();
      
      const resultsEl = document.getElementById('vote-phase-results');
      if (resultsEl) {
        resultsEl.innerHTML = `<div style="color: var(--accent-evil); font-weight: bold; padding: 0.75rem; background: rgba(251, 113, 133, 0.2); border-radius: 8px; text-align: center;">
          ‚öîÔ∏è <strong>THE TRAITOR REVEALS THEMSELVES!</strong><br>
          <em>${traitor.name} steps forward: "You cannot eliminate my ally!"</em><br>
          All previous votes are cancelled. Conduct a complete new vote.
        </div>`;
      }
      persistState();
    }

    function skipTraitorRevote() {
      state.traitorRevoteUsed = true; // Power is forfeited
      persistState();
      updateVotePhase();
    }

    // The Voice double elimination mechanic (char ID 22)
    async function triggerVoicePower(voiceId, secondPlaceId) {
      const voice = state.players.find(p => p.id === voiceId);
      const secondPlace = state.players.find(p => p.id === secondPlaceId);
      if (!voice || !secondPlace) return;
      
      state.voicePowerUsed = true;
      
      const result = await triggerSidekickPower(voiceId);
      
      const resultsEl = document.getElementById('vote-phase-results');
      if (result && resultsEl) {
        if (result.success) {
          resultsEl.innerHTML = `<div style="color: var(--accent-good); font-weight: bold; padding: 0.75rem; background: rgba(190, 242, 100, 0.3); border-radius: 8px; text-align: center;">
            üé§‚úÖ <strong>THE VOICE SUCCEEDS! (Roll: ${result.roll})</strong><br>
            <em>${voice.name}'s dramatic proclamation carries weight!</em><br>
            <strong>${secondPlace.name}</strong> is ALSO eliminated as second-place!
          </div>`;
          // Mark second place for elimination
          state.voiceSecondElimination = secondPlaceId;
        } else {
          resultsEl.innerHTML = `<div style="color: var(--accent-evil); font-weight: bold; padding: 0.75rem; background: rgba(239, 68, 68, 0.2); border-radius: 8px; text-align: center;">
            üé§‚ùå <strong>THE VOICE FAILS! (Roll: ${result.roll})</strong><br>
            <em>${voice.name}'s plea falls on deaf ears...</em><br>
            Only the voted player is eliminated. The Voice is now exposed!
          </div>`;
        }
      }
      persistState();
    }

    function createVoteTracker() {
      const tracker = document.createElement('div');
      tracker.className = 'action-tracker';
      
      const alivePlayers = state.players.filter(p => !p.eliminated);
      
      // Build vote inputs for each player
      const voteInputs = alivePlayers.map(p => {
        const isCorrupted = p.charId === 4; // Corrupted Authority
        const isSilenced = state.silencedPlayer === p.id; // Manipulator effect
        
        return `
          <div style="display: flex; gap: 0.5rem; align-items: center; margin: 0.5rem 0;">
            <label style="flex: 1;">${p.name} (${p.roleName}):</label>
            <input 
              type="number" 
              id="vote-${p.id}" 
              min="0" 
              max="50" 
              value="0" 
              style="width: 60px; padding: 0.25rem;"
              ${isSilenced ? 'disabled title="Silenced by Manipulator"' : ''}
            />
            ${isCorrupted ? '<span style="color: var(--accent-evil); font-size: 0.85rem;">√ó2</span>' : ''}
            ${isSilenced ? '<span style="color: var(--accent-evil); font-size: 0.85rem;">üîá</span>' : ''}
          </div>
        `;
      }).join('');

      tracker.innerHTML = `
        <h4>Vote Tracker</h4>
        <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1rem;">
          Enter the vote count for each player. Corrupted Authority votes count double (√ó2).
        </p>
        
        ${voteInputs}
        
        <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
          <h5 style="margin: 0 0 0.5rem;">Vote Tally</h5>
          <div id="vote-tally" style="font-family: monospace; font-size: 0.9rem;"></div>
        </div>
        
        <div class="action-buttons">
          <button onclick="calculateVotes()" style="background: linear-gradient(135deg, rgba(34, 211, 238, 0.7), rgba(56, 189, 248, 0.9));">
            üó≥Ô∏è Calculate Votes
          </button>
          <button onclick="clearVotes()" style="background: linear-gradient(135deg, rgba(148, 163, 184, 0.5), rgba(100, 116, 139, 0.7));">
            üóëÔ∏è Clear Votes
          </button>
        </div>
      `;

      // Add event listeners to auto-calculate on input
      setTimeout(() => {
        alivePlayers.forEach(p => {
          const input = document.getElementById(`vote-${p.id}`);
          if (input) {
            input.addEventListener('input', calculateVotes);
          }
        });
      }, 0);

      return tracker;
    }

    function calculateVotes() {
      const alivePlayers = state.players.filter(p => !p.eliminated);
      const voteTally = {};
      
      // Collect votes
      alivePlayers.forEach(p => {
        const input = document.getElementById(`vote-${p.id}`);
        if (input) {
          let votes = parseInt(input.value) || 0;
          
          // Apply Corrupted Authority double vote
          if (p.charId === 4) {
            votes = votes * 2;
          }
          
          voteTally[p.id] = {
            name: p.name,
            role: p.roleName,
            votes: votes,
            player: p
          };
        }
      });
      
      // Sort by votes
      const sorted = Object.values(voteTally).sort((a, b) => b.votes - a.votes);
      
      // Display tally
      const tallyEl = document.getElementById('vote-tally');
      if (tallyEl && sorted.length > 0) {
        let tallyHTML = '';
        sorted.forEach((entry, index) => {
          if (entry.votes > 0) {
            const isFirst = index === 0 && entry.votes > 0;
            const isSecond = index === 1 && entry.votes > 0;
            const style = isFirst ? 'color: var(--accent-evil); font-weight: bold;' : 
                         isSecond ? 'color: var(--accent-good);' : '';
            tallyHTML += `<div style="${style}">${index + 1}. ${entry.name}: ${entry.votes} votes</div>`;
          }
        });
        
        if (tallyHTML === '') {
          tallyHTML = '<div style="color: var(--text-secondary);">No votes recorded yet</div>';
        } else {
          // Add elimination indicators
          const firstPlace = sorted[0];
          const secondPlace = sorted[1];
          
          tallyHTML += '<hr style="margin: 0.5rem 0; opacity: 0.3;">';
          tallyHTML += `<div style="margin-top: 0.5rem;">`;
          
          if (firstPlace && firstPlace.votes > 0) {
            // Check for tie
            if (secondPlace && secondPlace.votes === firstPlace.votes) {
              // TIE!
              const tiedPlayers = sorted.filter(e => e.votes === firstPlace.votes);
              tallyHTML += `<div style="color: var(--accent-neutral); font-weight: bold;">
                ‚ö†Ô∏è TIE between ${tiedPlayers.map(e => e.name).join(' and ')}!
              </div>`;
              tallyHTML += `<div style="margin-top: 0.5rem; display: flex; gap: 0.5rem;">
                <button onclick="handleVoteRevote()" style="padding: 0.4rem 0.8rem; font-size: 0.85rem; border-radius: 6px; background: linear-gradient(135deg, rgba(56, 189, 248, 0.7), rgba(244, 114, 182, 0.9)); border: none; cursor: pointer; font-weight: 600;">üîÑ REVOTE</button>
                <button onclick="handleVoteNoElimination()" style="padding: 0.4rem 0.8rem; font-size: 0.85rem; border-radius: 6px; background: linear-gradient(135deg, rgba(148, 163, 184, 0.5), rgba(100, 116, 139, 0.7)); border: none; cursor: pointer; font-weight: 600;">‚ùå NO ELIMINATION</button>
              </div>`;
            } else {
              // Clear winner
              tallyHTML += `<div style="color: var(--accent-evil);">‚Üí ${firstPlace.name} is ELIMINATED</div>`;
              
              // Check for Marked revote
              if (firstPlace.player.charId === 26) {
                tallyHTML += `<div style="color: var(--accent-good); margin-top: 0.25rem;">‚ö†Ô∏è The Marked demands a REVOTE!</div>`;
              }
              
              // Check for Traitor revote trigger
              const traitor = state.players.find(p => p.charId === 9 && !p.eliminated);
              if (traitor && state.markedPlayer === firstPlace.player.id) {
                tallyHTML += `<div style="color: var(--accent-evil); margin-top: 0.25rem;">‚ö†Ô∏è Traitor triggers REVOTE!</div>`;
              }
            }
          }
          
          tallyHTML += `</div>`;
        }
        
        tallyEl.innerHTML = tallyHTML;
      }
      
      return sorted;
    }

    function handleVoteRevote() {
      state.voting.revoteCount++;
      clearVotes();
      // Show inline notification in the tally area
      const tallyEl = document.getElementById('vote-tally');
      if (tallyEl) {
        tallyEl.innerHTML = `<div style="color: var(--accent-good); font-weight: bold; padding: 0.5rem; background: rgba(56, 189, 248, 0.15); border-radius: 8px; text-align: center;">
          üîÑ Revote #${state.voting.revoteCount} called! Votes cleared. Conduct a new vote.
        </div>`;
      }
    }

    function handleVoteNoElimination() {
      // Show inline notification in the tally area
      const tallyEl = document.getElementById('vote-tally');
      if (tallyEl) {
        tallyEl.innerHTML = `<div style="color: var(--accent-neutral); font-weight: bold; padding: 0.5rem; background: rgba(250, 204, 21, 0.15); border-radius: 8px; text-align: center;">
          ‚ùå No elimination this round. Proceed to the next phase.
        </div>`;
      }
    }

    function clearVotes() {
      const alivePlayers = state.players.filter(p => !p.eliminated);
      alivePlayers.forEach(p => {
        const input = document.getElementById(`vote-${p.id}`);
        if (input) {
          input.value = '0';
        }
      });
      calculateVotes();
    }

    function renderPlayers() {
      playerList.innerHTML = "";
      state.players.forEach(player => {
        const clone = playerCardTemplate.content.cloneNode(true);
        const card = clone.querySelector(".player-card");
        card.dataset.status = player.eliminated ? "eliminated" : player.protected ? "protected" : "alive";
        card.dataset.id = player.id;
        card.dataset.connected = "false"; // Will be updated by updatePlayerCardConnectionStatus
        clone.querySelector(".player-name").textContent = player.name;
        
        // Set role info in the meta section
        const roleInfoEl = clone.querySelector(".player-role-info");
        if (roleInfoEl) {
          roleInfoEl.textContent = `${player.roleName} ‚Ä¢ ${TYPE_DETAILS[player.type].label}`;
        }
        
        const badge = clone.querySelector(".badge");
        badge.classList.add(player.team);
        badge.textContent = player.team.toUpperCase();
        clone.querySelector(".player-ability").textContent = player.ability;
        const notes = clone.querySelector(".player-notes");
        notes.value = player.notes;
        notes.addEventListener("input", (event) => {
          player.notes = event.target.value;
          persistState();
        });
        clone.querySelectorAll("button").forEach(btn => {
          btn.addEventListener("click", () => handlePlayerAction(player.id, btn.dataset.action));
        });
        playerList.append(clone);
      });
      
      // Update connection status after rendering
      updatePlayerCardConnectionStatus();
    }

    function handlePlayerAction(id, action) {
      const player = state.players.find(p => p.id === id);
      if (!player) return;
      if (action === "toggle-eliminated") {
        const wasAlive = !player.eliminated;
        player.eliminated = !player.eliminated;
        if (player.eliminated) {
          player.protected = false;
          // Play elimination sound when player is eliminated
          if (wasAlive) {
            playEliminationSound();
          }
        }
        broadcastPlayersEliminated();
        broadcastRosterUpdate();
      }
      if (action === "toggle-protected") {
        const wasUnprotected = !player.protected;
        player.protected = !player.protected;
        if (player.protected) {
          player.eliminated = false;
          // Play protection sound when player is protected
          if (wasUnprotected) {
            playProtectionSound();
          }
        }
      }
      updateCounts();
      renderPlayers();
      persistState();
      
      // Check win condition after any elimination
      if (action === "toggle-eliminated" && player.eliminated) {
        checkWinCondition();
      }
    }

    function updateCounts() {
      const alivePlayers = state.players.filter(p => !p.eliminated);
      aliveCount.textContent = alivePlayers.length;
      goodCount.textContent = alivePlayers.filter(p => p.team === "good").length;
      evilCount.textContent = alivePlayers.filter(p => p.team === "evil").length;
      nightNumber.textContent = state.night;
    }

    function goToNextStep() {
      const steps = buildScriptSteps();
      state.stepIndex = Math.min(state.stepIndex + 1, steps.length);
      if (state.stepIndex >= steps.length) {
        state.night += 1;
        state.stepIndex = 0;
        // Reset voting state for the new round
        state.voting = {
          phase: null,
          nominations: [],
          accusedPlayer: null,
          votesVisible: false,
          revoteCount: 0,
          tiedPlayers: []
        };
      }
      persistState();
      renderScript();
    }

    function goToPrevStep() {
      state.stepIndex = Math.max(0, state.stepIndex - 1);
      persistState();
      renderScript();
    }

    function renderTimer() {
      const minutes = String(Math.floor(state.timer.remaining / 60)).padStart(2, "0");
      const seconds = String(state.timer.remaining % 60).padStart(2, "0");
      timerDisplay.textContent = `${minutes}:${seconds}`;
    }

    function startTimer(duration) {
      if (typeof duration === "number") {
        state.timer.remaining = duration;
      }
      if (state.timer.handle) {
        clearInterval(state.timer.handle);
      }
      state.timer.running = true;
      state.timer.handle = setInterval(() => {
        if (state.timer.remaining > 0) {
          state.timer.remaining -= 1;
          renderTimer();
          broadcastTimerUpdate(state.timer.remaining, state.timer.running);
          // Play warning sound at 30 seconds and when timer completes
          if (state.timer.remaining === 30) {
            playTimerWarningSound();
          }
          if (state.timer.remaining === 0) {
            playTimerWarningSound();
            setTimeout(() => playTimerWarningSound(), 300); // Double ding
            alert("‚è∞ Timer complete! Time for a dramatic decision.");
          }
        }
      }, 1000);
      broadcastTimerUpdate(state.timer.remaining, state.timer.running);
      persistState();
    }

    function pauseTimer() {
      state.timer.running = false;
      if (state.timer.handle) clearInterval(state.timer.handle);
      state.timer.handle = null;
      broadcastTimerUpdate(state.timer.remaining, state.timer.running);
      persistState();
    }

    function resetTimer() {
      pauseTimer();
      state.timer.remaining = 180;
      renderTimer();
      broadcastTimerUpdate(state.timer.remaining, state.timer.running);
      persistState();
    }

    function handleStartGame() {
      state.players = preparePlayers();
      state.phase = "night";
      state.night = 1;
      state.stepIndex = 0;
      state.notes = notesArea.value;
      state.audio.phase = "night";
      // Generate a game code for player devices
      state.gameCode = generateGameCode();
      persistState();
      setupSection.classList.add("hidden");
      gameSection.classList.remove("hidden");
      audioControls.classList.remove("hidden");
      // Show quick reference toggle during game
      quickRefToggle.classList.remove("hidden");
      applyThemeVisuals();
      broadcastPhaseChange(state.phase, state.night);
      // Set initial phase on game-grid
      const gameGrid = document.querySelector("#game-section .game-grid");
      if (gameGrid) {
        gameGrid.setAttribute('data-phase', state.phase);
      }
      // Play night start sound for game start
      playNightStartSound();
      renderAll();
      // Update quick reference abilities
      updateQuickRefAbilities();
      // Update game code display
      renderGameCode();
      // Create Firebase game session for cross-device player communication
      createFirebaseGameSession();
      // Initialize player connection status UI (even if Firebase isn't available)
      updatePlayerConnectionUI();
    }

    function renderDownloadLink() {
      const notes = [`Narrator Notes - Night ${state.night}`, "==============================", "", notesArea.value || "(none)", "", "Player Notes:"]; 
      state.players.forEach(player => {
        const status = player.eliminated ? "Eliminated" : "Alive";
        notes.push(`${player.name} - ${player.roleName} (${status})`);
        if (player.notes) notes.push(`  Notes: ${player.notes}`);
      });
      const blob = new Blob([notes.join("\n")], { type: "text/plain" });
      if (downloadNotesLink.dataset.url) {
        URL.revokeObjectURL(downloadNotesLink.dataset.url);
      }
      const objectUrl = URL.createObjectURL(blob);
      downloadNotesLink.href = objectUrl;
      downloadNotesLink.dataset.url = objectUrl;
    }

    // Help Modal Functions
    function showHelpModal() {
      const overlay = document.getElementById("help-modal-overlay");
      
      // Populate current characters list
      const currentList = document.getElementById("current-characters-list");
      currentList.innerHTML = "";
      
      if (state.players.length > 0) {
        state.players.forEach(player => {
          const char = CHARACTERS.find(c => c.id === player.charId);
          if (char) {
            currentList.appendChild(createCharacterHelpItem(char, player));
          }
        });
      } else {
        currentList.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 2rem;">No characters selected yet. Start a game to see current characters.</p>';
      }
      
      // Populate all characters list
      const allList = document.getElementById("all-characters-list");
      allList.innerHTML = "";
      CHARACTERS.forEach(char => {
        allList.appendChild(createCharacterHelpItem(char));
      });
      
      overlay.classList.add("active");
    }

    function createCharacterHelpItem(char, player = null) {
      const div = document.createElement("div");
      div.className = `character-help-item ${char.team}`;
      div.dataset.name = char.name.toLowerCase();
      div.dataset.type = char.type;
      
      const nameDisplay = player ? `${player.name} - ${char.name}` : char.name;
      
      div.innerHTML = `
        <h4>
          ${nameDisplay}
          <span class="type-badge">${TYPE_DETAILS[char.type].label}</span>
          <span class="type-badge" style="background: ${char.team === 'good' ? 'var(--accent-good)' : 'var(--accent-evil)'}; color: var(--bg-primary);">${char.team.toUpperCase()}</span>
        </h4>
        <p>${char.short}</p>
        ${char.oneTimeOnly ? '<p><strong>One-time use only</strong></p>' : ''}
        ${char.limited ? `<p><strong>Limited uses: ${char.limited}</strong></p>` : ''}
        ${char.passive ? '<p><strong>Passive ability</strong></p>' : ''}
        ${char.hasNightAction ? '<p><strong>Night Order: Step ${char.nightOrder}</strong></p>' : ''}
      `;
      
      return div;
    }

    function closeHelpModal() {
      const overlay = document.getElementById("help-modal-overlay");
      overlay.classList.remove("active");
    }

    function setupHelpModal() {
      // Tab switching
      const tabs = document.querySelectorAll(".help-tab");
      tabs.forEach(tab => {
        tab.addEventListener("click", () => {
          const targetTab = tab.dataset.tab;
          
          // Update active tab
          tabs.forEach(t => t.classList.remove("active"));
          tab.classList.add("active");
          
          // Update active content
          document.querySelectorAll(".help-content").forEach(content => {
            content.classList.remove("active");
          });
          document.getElementById(`help-${targetTab}`).classList.add("active");
        });
      });
      
      // Search functionality
      const searchCurrent = document.getElementById("help-search-current");
      const searchAll = document.getElementById("help-search-all");
      
      function filterCharacters(searchInput, listId) {
        const query = searchInput.value.toLowerCase();
        const items = document.querySelectorAll(`#${listId} .character-help-item`);
        
        items.forEach(item => {
          const name = item.dataset.name;
          const type = item.dataset.type;
          const text = item.textContent.toLowerCase();
          
          if (name.includes(query) || type.includes(query) || text.includes(query)) {
            item.style.display = "block";
          } else {
            item.style.display = "none";
          }
        });
      }
      
      searchCurrent.addEventListener("input", () => {
        filterCharacters(searchCurrent, "current-characters-list");
      });
      
      searchAll.addEventListener("input", () => {
        filterCharacters(searchAll, "all-characters-list");
      });
      
      // Close button
      document.getElementById("help-close").addEventListener("click", closeHelpModal);
      
      // Close on Esc key
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          const helpOverlay = document.getElementById("help-modal-overlay");
          if (helpOverlay.classList.contains("active")) {
            closeHelpModal();
          }
        }
      });
    }

    // Simple Sound Effects using Web Audio API
    function playSound(frequency, duration, type = 'sine') {
      // Check if SFX is enabled
      if (!state.sfxEnabled) return;
      
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        // Use the volume from audio controls
        const volume = state.audio.volume * 0.3;
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
      } catch (e) {
        // Silently fail if Web Audio API not supported
        console.log('Audio not supported');
      }
    }

    function playCelebrationSound() {
      if (!state.sfxEnabled) return;
      // Play a cheerful ascending melody
      playSound(523, 0.15); // C
      setTimeout(() => playSound(659, 0.15), 150); // E
      setTimeout(() => playSound(784, 0.15), 300); // G
      setTimeout(() => playSound(1047, 0.3), 450); // High C
    }

    function playTimerWarningSound() {
      // Play a gentle "ding" sound
      playSound(800, 0.2, 'sine');
    }

    // NEW: Game Event Sound Effects
    function playNightStartSound() {
      if (!state.sfxEnabled) return;
      // Spooky descending melody
      playSound(440, 0.3, 'sine');
      setTimeout(() => playSound(392, 0.3, 'sine'), 300);
      setTimeout(() => playSound(330, 0.4, 'sine'), 600);
    }

    function playDayStartSound() {
      if (!state.sfxEnabled) return;
      // Bright ascending wake-up sound
      playSound(392, 0.15, 'sine');
      setTimeout(() => playSound(523, 0.15, 'sine'), 150);
      setTimeout(() => playSound(659, 0.2, 'sine'), 300);
    }

    function playEliminationSound() {
      if (!state.sfxEnabled) return;
      // Dramatic low tone
      playSound(150, 0.4, 'sawtooth');
      setTimeout(() => playSound(100, 0.6, 'sawtooth'), 300);
    }

    function playVoteSound() {
      if (!state.sfxEnabled) return;
      // Quick vote confirmation sound
      playSound(600, 0.1, 'square');
    }

    function playDiceRollSound() {
      if (!state.sfxEnabled) return;
      // Rattling dice sound - quick succession
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          playSound(300 + Math.random() * 200, 0.05, 'square');
        }, i * 50);
      }
    }

    function playDiceSuccessSound() {
      if (!state.sfxEnabled) return;
      // Success fanfare
      playSound(523, 0.1, 'sine');
      setTimeout(() => playSound(659, 0.1, 'sine'), 100);
      setTimeout(() => playSound(784, 0.2, 'sine'), 200);
    }

    function playDiceFailSound() {
      if (!state.sfxEnabled) return;
      // Descending failure tone
      playSound(400, 0.2, 'sine');
      setTimeout(() => playSound(300, 0.3, 'sine'), 200);
    }

    function playProtectionSound() {
      if (!state.sfxEnabled) return;
      // Shield-like chime
      playSound(700, 0.15, 'sine');
      setTimeout(() => playSound(880, 0.2, 'sine'), 150);
    }

    // Win Condition Functions
    function checkWinCondition() {
      const alivePlayers = state.players.filter(p => !p.eliminated);
      const aliveGood = alivePlayers.filter(p => p.team === "good").length;
      const aliveEvil = alivePlayers.filter(p => p.team === "evil").length;
      
      // Check if all evil eliminated ‚Üí Good wins
      if (aliveEvil === 0 && aliveGood > 0) {
        showWinModal("good");
        return true;
      }
      
      // Check if evil ‚â• good ‚Üí Evil wins
      if (aliveEvil >= aliveGood && aliveEvil > 0) {
        showWinModal("evil");
        return true;
      }
      
      return false;
    }

    function showWinModal(winningTeam) {
      const modal = document.getElementById("win-modal");
      const overlay = document.getElementById("win-modal-overlay");
      const title = document.getElementById("win-title");
      const narrationEl = document.getElementById("win-narration");
      const nightsEl = document.getElementById("win-nights");
      const survivorsEl = document.getElementById("win-survivors");
      const eliminatedEl = document.getElementById("win-eliminated");
      const rolesListEl = document.getElementById("win-roles-list");
      
      // Play celebration sound
      playCelebrationSound();
      
      // Get theme-specific narration
      const theme = THEMES[state.theme] || THEMES.village;
      const narrationText = winningTeam === "good" 
        ? (theme.script.goodWins || "The forces of good have prevailed! Victory!")
        : (theme.script.evilWins || "Darkness triumphs! Evil has won!");
      
      // Set title and styling based on winner
      if (winningTeam === "good") {
        title.textContent = "üé≠ Good Team Wins! üé≠";
        modal.className = "win-modal good-wins";
      } else {
        title.textContent = "üòà Evil Team Wins! üòà";
        modal.className = "win-modal evil-wins";
      }
      
      // Set the dramatic narration
      narrationEl.textContent = narrationText;
      
      // Set statistics
      const alivePlayers = state.players.filter(p => !p.eliminated);
      const eliminatedPlayers = state.players.filter(p => p.eliminated);
      nightsEl.textContent = state.night;
      survivorsEl.textContent = alivePlayers.length;
      eliminatedEl.textContent = eliminatedPlayers.length;
      
      // Build roles list with reveal
      rolesListEl.innerHTML = "";
      state.players.forEach(player => {
        const roleDiv = document.createElement("div");
        roleDiv.className = `win-modal-role ${player.eliminated ? "eliminated" : ""}`;
        
        const nameSpan = document.createElement("span");
        nameSpan.textContent = `${player.name} - ${player.roleName}`;
        
        const teamBadge = document.createElement("span");
        teamBadge.className = `win-modal-role-team ${player.team}`;
        teamBadge.textContent = player.team.toUpperCase();
        
        roleDiv.appendChild(nameSpan);
        roleDiv.appendChild(teamBadge);
        rolesListEl.appendChild(roleDiv);
      });
      
      // Show the modal
      overlay.classList.add("active");
      
      // Broadcast win to projector
      broadcastWin(winningTeam);
    }

    function closeWinModal() {
      const overlay = document.getElementById("win-modal-overlay");
      overlay.classList.remove("active");
    }

    function broadcastWin(winningTeam) {
      if (projectorChannel) {
        projectorChannel.postMessage({
          type: "WIN",
          team: winningTeam,
          night: state.night
        });
      }
      // Also broadcast to player devices
      broadcastToPlayers({
        type: "WIN",
        team: winningTeam,
        night: state.night
      });
    }

    // Dice Roll System
    let currentDiceRoll = null;

    function showDiceRollModal(player, powerDescription) {
      return new Promise((resolve) => {
        const overlay = document.getElementById("dice-modal-overlay");
        const characterName = document.getElementById("dice-character-name");
        const rollButton = document.getElementById("dice-roll-button");
        const resultContainer = document.getElementById("dice-result-container");
        const resultEl = document.getElementById("dice-result");
        const outcomeEl = document.getElementById("dice-outcome");
        const descriptionEl = document.getElementById("dice-description");
        const confirmButton = document.getElementById("dice-confirm");
        const cancelButton = document.getElementById("dice-cancel");

        // Reset UI
        characterName.textContent = `${player.name} - ${player.roleName}`;
        resultContainer.style.display = "none";
        rollButton.style.display = "block";
        confirmButton.style.display = "none";
        cancelButton.textContent = "Cancel";

        currentDiceRoll = null;

        // Roll button handler
        const handleRoll = () => {
          // Play dice rolling sound
          playDiceRollSound();
          
          const roll = Math.floor(Math.random() * 6) + 1;
          const success = roll >= 4;
          
          currentDiceRoll = { roll, success, player, powerDescription };
          
          // Delay showing result for dramatic effect
          setTimeout(() => {
            // Play success or failure sound
            if (success) {
              playDiceSuccessSound();
            } else {
              playDiceFailSound();
            }
            
            // Show result with dice face emoji
            const diceFaces = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
            resultEl.innerHTML = `<span class="dice-face">${diceFaces[roll - 1]}</span>`;
            outcomeEl.textContent = success ? "‚úÖ SUCCESS!" : "‚ùå FAILURE!";
            outcomeEl.className = `dice-modal-outcome ${success ? "success" : "failure"}`;
            
            // Show power-specific description
            descriptionEl.textContent = powerDescription[success ? "success" : "failure"];
            
            resultContainer.style.display = "block";
            rollButton.style.display = "none";
            confirmButton.style.display = "block";
            cancelButton.textContent = "Re-roll";
          }, 300);
        };

        const handleConfirm = () => {
          overlay.classList.remove("active");
          rollButton.removeEventListener("click", handleRoll);
          confirmButton.removeEventListener("click", handleConfirm);
          cancelButton.removeEventListener("click", handleCancel);
          resolve(currentDiceRoll);
        };

        const handleCancel = () => {
          if (currentDiceRoll) {
            // Re-roll: reset UI
            resultContainer.style.display = "none";
            rollButton.style.display = "block";
            confirmButton.style.display = "none";
            cancelButton.textContent = "Cancel";
            currentDiceRoll = null;
          } else {
            // Cancel without rolling
            overlay.classList.remove("active");
            rollButton.removeEventListener("click", handleRoll);
            confirmButton.removeEventListener("click", handleConfirm);
            cancelButton.removeEventListener("click", handleCancel);
            resolve(null);
          }
        };

        rollButton.addEventListener("click", handleRoll);
        confirmButton.addEventListener("click", handleConfirm);
        cancelButton.addEventListener("click", handleCancel);

        overlay.classList.add("active");
      });
    }

    function getSidekickPowerDescription(charId) {
      const descriptions = {
        21: { // Loyal Companion
          success: "The Loyal Companion adds +3 votes to the Champion's target during voting!",
          failure: "The Loyal Companion's attempt fails. No bonus votes are added."
        },
        22: { // Voice
          success: "The Voice's power activates! The second-place player is ALSO eliminated!",
          failure: "The Voice's dramatic plea falls flat. Only the voted player is eliminated."
        },
        23: { // Fool
          success: "The Fool's wild accusation lands! They may dramatically accuse someone.",
          failure: "The Fool's accusation backfires! They become the prime suspect."
        },
        24: { // Trickster
          success: "The Trickster creates a convincing false claim about another player!",
          failure: "The Trickster is caught in their lie. Suspicion falls on them."
        },
        25: { // Imitator
          success: "The Imitator successfully copies another Sidekick's day power!",
          failure: "The Imitator's mimicry fails. No power is copied."
        }
      };
      return descriptions[charId] || {
        success: "Success!",
        failure: "Failure!"
      };
    }

    async function triggerSidekickPower(playerId) {
      const player = state.players.find(p => p.id === playerId);
      if (!player || player.eliminated) return null;

      const powerDescription = getSidekickPowerDescription(player.charId);
      const result = await showDiceRollModal(player, powerDescription);
      
      if (result) {
        // Store the result in game state for tracking
        if (!state.diceRolls) state.diceRolls = [];
        state.diceRolls.push({
          night: state.night,
          playerId: player.id,
          playerName: player.name,
          role: player.roleName,
          roll: result.roll,
          success: result.success
        });
        saveState();
      }
      
      return result;
    }

    function renderAll() {
      applyMode(state.mode);
      applyThemeVisuals();
      updatePlayerCountDisplays();
      updateRoleSelectionUI();
      renderThemeSelect();
      renderTimer();
      namesInput.value = state.nameList;
      
      // Update audio controls
      toggleAudioButton.textContent = state.audio.enabled ? "üîä" : "üîá";
      volumeSlider.value = state.audio.volume * 100;
      audioPhase.textContent = state.audio.phase === "night" ? "Night" : "Day";
      audioIndicator.classList.toggle("playing", state.audio.enabled);
      
      // Update SFX toggle
      const sfxToggleEl = document.getElementById("sfx-toggle");
      if (sfxToggleEl) {
        sfxToggleEl.checked = state.sfxEnabled;
      }
      
      if (state.phase === "setup") {
        setupSection.classList.remove("hidden");
        gameSection.classList.add("hidden");
        audioControls.classList.add("hidden");
        // Hide quick reference toggle during setup
        quickRefToggle.classList.add("hidden");
        quickRefPanel.classList.remove("open");
      } else {
        setupSection.classList.add("hidden");
        gameSection.classList.remove("hidden");
        audioControls.classList.remove("hidden");
        // Show quick reference toggle during game
        quickRefToggle.classList.remove("hidden");
        renderScript();
        renderPlayers();
        updateCounts();
        notesArea.value = state.notes;
        renderDownloadLink();
        // Update player connection status
        updatePlayerConnectionUI();
        // Update quick reference abilities if panel is open
        if (quickRefPanel.classList.contains("open")) {
          updateQuickRefAbilities();
        }
      }
    }

    // Preset loading function
    function loadPreset(playerCount) {
      const preset = PRESETS[playerCount];
      if (!preset) return;
      
      // Update player count
      playerCountInput.value = playerCount;
      state.selectedRoles = [...preset.roles];
      
      // Update UI
      updatePlayerCountDisplays();
      updateRoleSelectionUI();
      
      // Reset preview when preset is loaded
      previewPlayers = [];
      shufflePreviewDiv.classList.add('hidden');
      
      // Show preset info
      const presetInfo = document.getElementById("preset-info");
      const presetDetails = document.getElementById("preset-details");
      presetInfo.style.display = "block";
      presetDetails.textContent = `${preset.description} ‚Ä¢ ${preset.timeEstimate}`;
      
      // Hide after 5 seconds
      setTimeout(() => {
        presetInfo.style.display = "none";
      }, 5000);
      
      persistState();
    }

    // Calculate estimated game time based on player count
    function calculateEstimatedTime(playerCount) {
      // Base time: 20 minutes + 1 minute per player above 12
      const baseTime = 20;
      const perPlayerTime = 1;
      const totalMinutes = baseTime + ((playerCount - 12) * perPlayerTime);
      return `~${totalMinutes} min`;
    }

    function updatePlayerCountDisplays() {
      const count = Number(playerCountInput.value);
      playerCountDisplay.textContent = count;
      
      // Calculate good/evil split (roughly 2:1 ratio)
      const good = Math.round(count * 0.67);
      const evil = count - good;
      
      suggestedGoodDisplay.textContent = good;
      suggestedEvilDisplay.textContent = evil;
      document.getElementById("estimated-time").textContent = calculateEstimatedTime(count);
    }

    playerCountInput.addEventListener("input", () => {
      updatePlayerCountDisplays();
      updateRoleSelectionUI();
      persistState();
    });

    themeSelect.addEventListener("change", event => {
      state.theme = event.target.value;
      themeDescription.textContent = THEMES[state.theme].description;
      applyThemeVisuals();
      broadcastThemeChange(state.theme);
      persistState();
      if (state.phase !== "setup") {
        renderScript();
        if (state.audio.enabled) {
          playThemeAudio();
        }
      }
    });

    namesInput.addEventListener("input", () => {
      state.nameList = namesInput.value;
      persistState();
      // Reset preview when names change
      previewPlayers = [];
      shufflePreviewDiv.classList.add('hidden');
    });

    notesArea.addEventListener("input", event => {
      state.notes = event.target.value;
      persistState();
      renderDownloadLink();
    });

    // Preview and shuffle button event listeners
    previewShuffleBtn.addEventListener("click", showShufflePreview);
    shuffleAssignmentsBtn.addEventListener("click", shuffleAgain);

    startButton.addEventListener("click", handleStartGame);
    prevStepButton.addEventListener("click", goToPrevStep);
    nextStepButton.addEventListener("click", goToNextStep);

    timerButtons.forEach(btn => btn.addEventListener("click", () => startTimer(Number(btn.dataset.timer))));
    startTimerBtn.addEventListener("click", () => startTimer());
    pauseTimerBtn.addEventListener("click", pauseTimer);
    resetTimerBtn.addEventListener("click", resetTimer);

    toggleModeButton.addEventListener("click", () => {
      state.mode = state.mode === "light" ? "dark" : "light";
      applyMode(state.mode);
      persistState();
    });

    helpButton.addEventListener("click", showHelpModal);

    // Preset button event listeners
    document.getElementById("preset-15").addEventListener("click", () => loadPreset(15));
    document.getElementById("preset-18").addEventListener("click", () => loadPreset(18));
    document.getElementById("preset-21").addEventListener("click", () => loadPreset(21));

    resetGameButton.addEventListener("click", () => {
      if (confirm("Start a new game? Current progress will be cleared.")) {
        resetState();
      }
    });

    openProjectorButton.addEventListener("click", () => {
      // Open projector view in a new window
      const projectorWindow = window.open('projector.html', 'MelodramaProjector', 'width=1920,height=1080');
      if (projectorWindow) {
        // Send initial state after a brief delay to ensure the projector window is ready
        setTimeout(() => {
          sendFullStateToProjector();
        }, 1000);
      } else {
        alert('Failed to open projector window. Please check your popup blocker settings.');
      }
    });

    // Win modal event listeners
    document.getElementById("win-new-game").addEventListener("click", () => {
      closeWinModal();
      resetState();
    });

    document.getElementById("win-close").addEventListener("click", closeWinModal);

    // Quick Reference Panel Functions
    const quickRefToggle = document.getElementById("quick-ref-toggle");
    const quickRefPanel = document.getElementById("quick-ref-panel");
    const quickRefClose = document.getElementById("quick-ref-close");

    function toggleQuickRefPanel() {
      quickRefPanel.classList.toggle("open");
      quickRefToggle.classList.toggle("panel-open");
      
      // Update abilities list when opening
      if (quickRefPanel.classList.contains("open")) {
        updateQuickRefAbilities();
      }
    }

    function updateQuickRefAbilities() {
      const abilitiesList = document.getElementById("quick-ref-abilities");
      
      if (state.players.length === 0) {
        abilitiesList.innerHTML = '<li><em>Start a game to see active abilities</em></li>';
        return;
      }
      
      const alivePlayers = state.players.filter(p => !p.eliminated);
      
      // Group by type and show abilities
      const abilities = alivePlayers.map(p => {
        const char = CHARACTERS.find(c => c.id === p.charId);
        const isEvil = p.team === 'evil';
        return `<li class="${isEvil ? 'evil' : ''}"><strong>${char.name}</strong>: ${char.short}</li>`;
      });
      
      abilitiesList.innerHTML = abilities.join('');
    }

    quickRefToggle.addEventListener("click", toggleQuickRefPanel);
    quickRefClose.addEventListener("click", toggleQuickRefPanel);

    // SFX Toggle Event Listener
    const sfxToggle = document.getElementById("sfx-toggle");
    sfxToggle.addEventListener("change", (e) => {
      state.sfxEnabled = e.target.checked;
      persistState();
    });

    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("sw.js").catch(console.error);
      });
    }

    // Initialize audio system
    initAudioSystem();
    // Initialize projector channel
    initProjectorChannel();
    // Initialize player channel for player devices
    initPlayerChannel();
    // Setup help modal
    setupHelpModal();

    renderThemeSelect();
    renderRoleGroups();
    updatePlayerCountDisplays();
    updateRoleSelectionUI();
    renderAll();
    // Render game code if we have one (for resumed games)
    renderGameCode();
    
    // Initialize SFX toggle state
    sfxToggle.checked = state.sfxEnabled;
  </script>
</body>
</html>
