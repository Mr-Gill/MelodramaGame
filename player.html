<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Melodrama Werewolf - Player View</title>
  <meta name="description" content="Player view for Melodrama Werewolf game - see your character and take notes." />
  <!-- Google Fonts for theme-specific typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Cinzel:wght@400;700&family=Orbitron:wght@400;700&family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --text-primary: #f8fafc;
      --text-secondary: #e2e8f0;
      --accent-good: #38bdf8;
      --accent-evil: #f472b6;
      --accent-ui: #22d3ee;
      --border-color: #475569;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 18px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, rgba(124, 58, 237, 0.15), transparent 60%), var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1.5rem;
      text-align: center;
      border-bottom: 2px solid rgba(148, 163, 184, 0.2);
      background: rgba(15, 23, 42, 0.8);
      backdrop-filter: blur(10px);
    }

    header h1 {
      margin: 0 0 0.25rem 0;
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      letter-spacing: 0.05em;
    }

    header .subtitle {
      font-size: clamp(0.9rem, 2vw, 1.2rem);
      color: var(--text-secondary);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      font-weight: 500;
    }

    main {
      flex: 1;
      padding: 2rem;
      max-width: 800px;
      width: 100%;
      margin: 0 auto;
    }

    /* Login Section */
    .login-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 50vh;
      padding: 2rem 0;
      text-align: center;
    }

    @media (max-height: 600px) {
      .login-section {
        min-height: auto;
        padding: 1rem 0;
      }
    }

    .login-section h2 {
      margin: 0 0 1.5rem 0;
      font-size: clamp(1.5rem, 3vw, 2rem);
    }

    .login-form {
      background: rgba(30, 41, 59, 0.8);
      padding: 2rem;
      border-radius: 20px;
      border: 2px solid rgba(148, 163, 184, 0.3);
      width: 100%;
      max-width: 400px;
    }

    .login-form label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      font-size: 1rem;
      color: var(--text-secondary);
    }

    .game-code-input {
      width: 100%;
      padding: 1rem;
      font-size: 2rem;
      text-align: center;
      letter-spacing: 0.5rem;
      text-transform: uppercase;
      background: rgba(15, 23, 42, 0.8);
      border: 2px solid rgba(148, 163, 184, 0.4);
      border-radius: 12px;
      color: var(--text-primary);
      margin-bottom: 1rem;
    }

    .game-code-input:focus {
      outline: none;
      border-color: var(--accent-ui);
      box-shadow: 0 0 20px rgba(34, 211, 238, 0.3);
    }

    .game-code-input::placeholder {
      letter-spacing: 0.2rem;
      opacity: 0.5;
    }

    .player-name-input {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 1.1rem;
      background: rgba(15, 23, 42, 0.8);
      border: 2px solid rgba(148, 163, 184, 0.4);
      border-radius: 12px;
      color: var(--text-primary);
      margin-bottom: 1.5rem;
    }

    .player-name-input:focus {
      outline: none;
      border-color: var(--accent-ui);
      box-shadow: 0 0 20px rgba(34, 211, 238, 0.3);
    }

    .join-btn {
      width: 100%;
      padding: 1rem;
      font-size: 1.2rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.8), rgba(244, 114, 182, 0.9));
      border: none;
      border-radius: 12px;
      color: #0f172a;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .join-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(56, 189, 248, 0.4);
    }

    .join-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .error-message {
      color: #f87171;
      margin-top: 1rem;
      font-size: 0.95rem;
      display: none;
    }

    .error-message.visible {
      display: block;
    }

    /* Game Section (after joining) */
    .game-section {
      display: none;
    }

    .game-section.active {
      display: block;
    }

    /* Phase Indicator */
    .phase-indicator {
      text-align: center;
      padding: 1rem 1.5rem;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.7);
      border: 2px solid;
      margin-bottom: 1.5rem;
    }

    .phase-indicator.night {
      border-color: #7c3aed;
      box-shadow: 0 0 30px rgba(124, 58, 237, 0.4);
    }

    .phase-indicator.day {
      border-color: #f59e0b;
      box-shadow: 0 0 30px rgba(245, 158, 11, 0.4);
    }

    .phase-label {
      font-size: 1.5rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin: 0;
    }

    /* Character Card */
    .character-card {
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.98));
      border-radius: 24px;
      padding: 2rem;
      text-align: center;
      border: 3px solid;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      margin-bottom: 1.5rem;
    }

    .character-card.good {
      border-color: var(--accent-good);
      box-shadow: 0 0 40px rgba(56, 189, 248, 0.3);
    }

    .character-card.evil {
      border-color: var(--accent-evil);
      box-shadow: 0 0 40px rgba(244, 114, 182, 0.3);
    }

    .player-name-display {
      font-size: 1rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .character-name {
      font-size: clamp(1.8rem, 5vw, 2.5rem);
      font-weight: 700;
      margin: 0 0 0.5rem 0;
      letter-spacing: 0.03em;
    }

    .character-card.good .character-name {
      color: var(--accent-good);
      text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
    }

    .character-card.evil .character-name {
      color: var(--accent-evil);
      text-shadow: 0 0 20px rgba(244, 114, 182, 0.5);
    }

    .character-type {
      font-size: 1rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.15em;
      margin-bottom: 1rem;
    }

    .character-team {
      display: inline-block;
      padding: 0.5rem 1.25rem;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 1.5rem;
    }

    .character-team.good {
      background: rgba(56, 189, 248, 0.2);
      color: var(--accent-good);
      border: 2px solid var(--accent-good);
    }

    .character-team.evil {
      background: rgba(244, 114, 182, 0.2);
      color: var(--accent-evil);
      border: 2px solid var(--accent-evil);
    }

    .character-ability {
      font-size: 1.1rem;
      color: var(--text-primary);
      line-height: 1.7;
      padding: 1.25rem;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 16px;
      text-align: left;
    }

    .character-ability h4 {
      margin: 0 0 0.75rem 0;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-secondary);
    }

    /* Night/Day Instructions */
    .instructions-section {
      background: rgba(30, 41, 59, 0.7);
      border-radius: 16px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .instructions-section h3 {
      margin: 0 0 1rem 0;
      font-size: 1.1rem;
      color: var(--accent-ui);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .instructions-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .instructions-list li {
      padding: 0.5rem 0;
      padding-left: 1.5rem;
      position: relative;
      line-height: 1.5;
    }

    .instructions-list li::before {
      content: "‚Ä¢";
      position: absolute;
      left: 0;
      color: var(--accent-ui);
    }

    /* Notes Section */
    .notes-section {
      background: rgba(30, 41, 59, 0.7);
      border-radius: 16px;
      padding: 1.5rem;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .notes-section h3 {
      margin: 0 0 1rem 0;
      font-size: 1.1rem;
      color: var(--accent-ui);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .notes-section h3 span {
      font-size: 0.8rem;
      font-weight: normal;
      color: var(--text-secondary);
    }

    .notes-textarea {
      width: 100%;
      min-height: 200px;
      padding: 1rem;
      font-size: 1rem;
      line-height: 1.6;
      background: rgba(15, 23, 42, 0.8);
      border: 2px solid rgba(148, 163, 184, 0.3);
      border-radius: 12px;
      color: var(--text-primary);
      resize: vertical;
      font-family: inherit;
    }

    .notes-textarea:focus {
      outline: none;
      border-color: var(--accent-ui);
      box-shadow: 0 0 15px rgba(34, 211, 238, 0.2);
    }

    .notes-textarea::placeholder {
      color: var(--text-secondary);
      opacity: 0.6;
    }

    /* Connection Status */
    .connection-status {
      position: fixed;
      top: 1rem;
      right: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .connection-status.connected {
      background: rgba(34, 197, 94, 0.2);
      border: 2px solid #22c55e;
      color: #86efac;
    }

    .connection-status.disconnected {
      background: rgba(239, 68, 68, 0.2);
      border: 2px solid #ef4444;
      color: #fca5a5;
    }

    .connection-status .indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: blink 2s ease-in-out infinite;
    }

    .connection-status.connected .indicator {
      background: #22c55e;
    }

    .connection-status.disconnected .indicator {
      background: #ef4444;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    /* Leave Game Button */
    .leave-btn {
      display: block;
      width: 100%;
      padding: 0.75rem;
      margin-top: 1.5rem;
      font-size: 0.95rem;
      font-weight: 600;
      background: rgba(239, 68, 68, 0.2);
      border: 2px solid rgba(239, 68, 68, 0.5);
      border-radius: 12px;
      color: #fca5a5;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .leave-btn:hover {
      background: rgba(239, 68, 68, 0.3);
      border-color: #ef4444;
    }

    /* Win Overlay */
    .win-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(15, 23, 42, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      backdrop-filter: blur(10px);
    }

    .win-overlay.active {
      display: flex;
    }

    .win-content {
      text-align: center;
      animation: win-appear 0.5s ease-out;
    }

    @keyframes win-appear {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .win-emoji {
      font-size: clamp(4rem, 12vw, 8rem);
      margin-bottom: 1rem;
    }

    .win-title {
      font-size: clamp(2rem, 8vw, 5rem);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 1rem;
      animation: win-pulse 1.5s ease-in-out infinite;
    }

    .win-title.good {
      color: var(--accent-good);
      text-shadow: 0 0 40px rgba(56, 189, 248, 0.7);
    }

    .win-title.evil {
      color: var(--accent-evil);
      text-shadow: 0 0 40px rgba(244, 114, 182, 0.7);
    }

    @keyframes win-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.03); }
    }

    .win-subtitle {
      font-size: clamp(1.2rem, 3vw, 2rem);
      color: var(--text-secondary);
      letter-spacing: 0.1em;
    }

    /* Hidden */
    .hidden {
      display: none !important;
    }

    /* Responsive */
    @media (max-width: 600px) {
      main {
        padding: 1rem;
      }

      .character-card {
        padding: 1.5rem;
      }

      .notes-textarea {
        min-height: 150px;
      }
    }

    /* Waiting state */
    .waiting-message {
      text-align: center;
      padding: 2rem;
      color: var(--text-secondary);
      font-style: italic;
    }

    .waiting-message .spinner {
      display: inline-block;
      width: 24px;
      height: 24px;
      border: 3px solid rgba(148, 163, 184, 0.3);
      border-top-color: var(--accent-ui);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 0.75rem;
      vertical-align: middle;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Game Tips Section */
    .game-tips-section {
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.1), rgba(124, 58, 237, 0.1));
      border: 2px solid rgba(56, 189, 248, 0.3);
      border-radius: 16px;
      padding: 1.5rem;
      margin-top: 1.5rem;
      text-align: center;
    }

    .game-tips-section h3 {
      margin: 0 0 1rem 0;
      font-size: 1.1rem;
      color: var(--accent-ui);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .tip-card {
      background: rgba(15, 23, 42, 0.6);
      border-radius: 12px;
      padding: 1.25rem;
      min-height: 100px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      animation: tipFade 0.5s ease-out;
    }

    @keyframes tipFade {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .tip-title {
      font-weight: 700;
      font-size: 1.1rem;
      color: var(--accent-ui);
      margin-bottom: 0.5rem;
    }

    .tip-text {
      color: var(--text-secondary);
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .tip-category {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-top: 0.75rem;
    }

    .tip-category.strategy { 
      background: rgba(34, 197, 94, 0.2); 
      color: #86efac; 
      border: 1px solid rgba(34, 197, 94, 0.4);
    }
    .tip-category.acting { 
      background: rgba(244, 114, 182, 0.2); 
      color: #f9a8d4; 
      border: 1px solid rgba(244, 114, 182, 0.4);
    }
    .tip-category.rules { 
      background: rgba(56, 189, 248, 0.2); 
      color: #7dd3fc; 
      border: 1px solid rgba(56, 189, 248, 0.4);
    }
    .tip-category.fun { 
      background: rgba(250, 204, 21, 0.2); 
      color: #fde047; 
      border: 1px solid rgba(250, 204, 21, 0.4);
    }

    .tip-navigation {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .tip-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(148, 163, 184, 0.4);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .tip-dot.active {
      background: var(--accent-ui);
      transform: scale(1.3);
    }

    .tip-dot:hover {
      background: rgba(148, 163, 184, 0.7);
    }

    /* Voting Section */
    .voting-section {
      background: linear-gradient(135deg, rgba(244, 114, 182, 0.1), rgba(239, 68, 68, 0.1));
      border: 2px solid rgba(244, 114, 182, 0.4);
      border-radius: 16px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      display: none;
    }

    .voting-section.active {
      display: block;
      animation: voteAppear 0.3s ease-out;
    }

    @keyframes voteAppear {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .voting-section h3 {
      margin: 0 0 1rem 0;
      font-size: 1.2rem;
      color: var(--accent-evil);
      text-align: center;
    }

    .voting-instruction {
      text-align: center;
      color: var(--text-secondary);
      margin-bottom: 1rem;
      font-size: 0.95rem;
    }

    .vote-options {
      display: grid;
      gap: 0.5rem;
      max-height: 300px;
      overflow-y: auto;
    }

    .vote-option {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      background: rgba(15, 23, 42, 0.6);
      border: 2px solid transparent;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .vote-option:hover {
      border-color: rgba(244, 114, 182, 0.5);
      background: rgba(244, 114, 182, 0.1);
    }

    .vote-option.selected {
      border-color: var(--accent-evil);
      background: rgba(244, 114, 182, 0.2);
    }

    .vote-option-name {
      font-weight: 600;
      font-size: 1rem;
    }

    .vote-option-check {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid rgba(148, 163, 184, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
    }

    .vote-option.selected .vote-option-check {
      background: var(--accent-evil);
      border-color: var(--accent-evil);
      color: white;
    }

    .submit-vote-btn {
      width: 100%;
      padding: 1rem;
      margin-top: 1rem;
      font-size: 1.1rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      background: linear-gradient(135deg, rgba(244, 114, 182, 0.8), rgba(239, 68, 68, 0.9));
      border: none;
      border-radius: 12px;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .submit-vote-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(244, 114, 182, 0.4);
    }

    .submit-vote-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .vote-submitted {
      text-align: center;
      padding: 1.5rem;
      color: var(--accent-good);
      font-size: 1.1rem;
    }

    /* Dice Roll Section */
    .dice-roll-section {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(56, 189, 248, 0.1));
      border: 2px solid rgba(34, 197, 94, 0.4);
      border-radius: 16px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      text-align: center;
      display: none;
    }

    .dice-roll-section.active {
      display: block;
      animation: diceAppear 0.3s ease-out;
    }

    @keyframes diceAppear {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .dice-roll-section h3 {
      margin: 0 0 0.5rem 0;
      font-size: 1.2rem;
      color: var(--accent-good);
    }

    .dice-roll-section .dice-info {
      color: var(--text-secondary);
      margin-bottom: 1rem;
      font-size: 0.95rem;
    }

    .roll-dice-btn {
      padding: 1rem 2rem;
      font-size: 1.2rem;
      font-weight: 700;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.8), rgba(56, 189, 248, 0.9));
      border: none;
      border-radius: 12px;
      color: #0f172a;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .roll-dice-btn:hover:not(:disabled) {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 10px 30px rgba(34, 197, 94, 0.4);
    }

    .roll-dice-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .dice-result {
      margin-top: 1.5rem;
      padding: 1rem;
      border-radius: 12px;
      display: none;
    }

    .dice-result.active {
      display: block;
      animation: resultAppear 0.5s ease-out;
    }

    @keyframes resultAppear {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .dice-face {
      font-size: 4rem;
      margin-bottom: 0.5rem;
      animation: diceRoll 0.5s ease-out;
    }

    @keyframes diceRoll {
      0%, 20%, 40%, 60%, 80% {
        transform: rotate(0deg) scale(1);
      }
      10%, 30%, 50%, 70%, 90% {
        transform: rotate(180deg) scale(1.2);
      }
      100% {
        transform: rotate(360deg) scale(1);
      }
    }

    .dice-result.success {
      background: rgba(34, 197, 94, 0.2);
      border: 2px solid rgba(34, 197, 94, 0.5);
    }

    .dice-result.failure {
      background: rgba(239, 68, 68, 0.2);
      border: 2px solid rgba(239, 68, 68, 0.5);
    }

    .dice-result-text {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .dice-result.success .dice-result-text {
      color: #86efac;
    }

    .dice-result.failure .dice-result-text {
      color: #fca5a5;
    }

    .dice-result-description {
      color: var(--text-secondary);
      font-size: 0.95rem;
    }
  </style>
  <!-- Firebase SDK for cross-device communication -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js';
    import { getDatabase, ref, set, onValue, remove, update, push, onDisconnect } from 'https://www.gstatic.com/firebasejs/12.6.0/firebase-database.js';

    // Firebase configuration - these credentials are safe to expose in client-side code.
    // Security is managed through Firebase Realtime Database security rules.
    // See: https://firebase.google.com/docs/projects/api-keys
    const firebaseConfig = {
      apiKey: "AIzaSyCfZEDGBi99t3u9GlS78ifRmDM4-eJSdYg",
      authDomain: "melodrama-game.firebaseapp.com",
      projectId: "melodrama-game",
      storageBucket: "melodrama-game.firebasestorage.app",
      messagingSenderId: "656912364218",
      appId: "1:656912364218:web:7a9b44d4f3e9e89c550883",
      measurementId: "G-0S4D9SFEFH",
      databaseURL: "https://melodrama-game-default-rtdb.firebaseio.com"
    };

    // Initialize Firebase
    let firebaseApp = null;
    let database = null;
    let firebaseInitialized = false;

    try {
      firebaseApp = initializeApp(firebaseConfig);
      database = getDatabase(firebaseApp);
      firebaseInitialized = true;
      console.log('Firebase initialized successfully');
    } catch (error) {
      console.error('Failed to initialize Firebase:', error);
    }

    // Expose Firebase functions to global scope for use in main script
    window.firebaseDB = {
      initialized: firebaseInitialized,
      database: database,
      ref: ref,
      set: set,
      onValue: onValue,
      remove: remove,
      update: update,
      push: push,
      onDisconnect: onDisconnect
    };
  </script>
</head>
<body>
  <!-- Win notification overlay -->
  <div class="win-overlay" id="win-overlay">
    <div class="win-content">
      <div class="win-emoji" id="win-emoji">üé≠</div>
      <div class="win-title" id="win-title">Victory!</div>
      <div class="win-subtitle" id="win-subtitle">The game has ended</div>
    </div>
  </div>

  <div class="connection-status disconnected" id="connection-status">
    <span class="indicator"></span>
    <span class="status-text">Not Connected</span>
  </div>

  <header>
    <h1>üé≠ Melodrama Werewolf</h1>
    <div class="subtitle">Player View</div>
  </header>

  <main>
    <!-- Login Section -->
    <section class="login-section" id="login-section">
      <h2>Join the Game</h2>
      <div class="login-form">
        <label for="game-code">Game Code</label>
        <input 
          type="text" 
          id="game-code" 
          class="game-code-input" 
          placeholder="XXXX" 
          maxlength="4" 
          autocomplete="off"
          autocapitalize="characters"
        />
        
        <label for="player-name">Your Name</label>
        <input 
          type="text" 
          id="player-name" 
          class="player-name-input" 
          placeholder="Enter your name"
          maxlength="30"
          autocomplete="off"
        />
        
        <button class="join-btn" id="join-btn" disabled>Join Game</button>
        
        <div class="error-message" id="error-message">
          Invalid game code. Please check with your narrator.
        </div>
      </div>
      
      <!-- Game Tips Section (shown while waiting to join) -->
      <div class="game-tips-section" id="login-tips">
        <h3>üí° Game Tips</h3>
        <div class="tip-card" id="login-tip-card">
          <div class="tip-title" id="login-tip-title">Loading tip...</div>
          <div class="tip-text" id="login-tip-text">Get ready to play!</div>
          <span class="tip-category strategy" id="login-tip-category">Tip</span>
        </div>
        <div class="tip-navigation" id="login-tip-nav"></div>
      </div>
    </section>

    <!-- Game Section (shown after joining) -->
    <section class="game-section" id="game-section">
      <!-- Phase Indicator -->
      <div class="phase-indicator night" id="phase-indicator">
        <div class="phase-label" id="phase-label">Waiting for game...</div>
      </div>

      <!-- Voting Section (shown when voting is active in laptop mode) -->
      <div class="voting-section" id="voting-section">
        <h3>üó≥Ô∏è Cast Your Vote</h3>
        <div class="voting-instruction" id="voting-instruction">Select the player you want to eliminate</div>
        <div class="vote-options" id="vote-options">
          <!-- Vote options will be populated dynamically -->
        </div>
        <button class="submit-vote-btn" id="submit-vote-btn" disabled>Submit Vote</button>
        <div class="vote-submitted hidden" id="vote-submitted">
          ‚úÖ Your vote has been submitted!
        </div>
      </div>

      <!-- Dice Roll Section (shown for Sidekick-type characters) -->
      <div class="dice-roll-section" id="dice-roll-section">
        <h3>üé≤ Sidekick Power</h3>
        <div class="dice-info" id="dice-info">Roll the dice to use your special ability!</div>
        <button class="roll-dice-btn" id="roll-dice-btn">üé≤ Roll Dice</button>
        <div class="dice-result" id="dice-result">
          <div class="dice-face" id="dice-face">‚öÄ</div>
          <div class="dice-result-text" id="dice-result-text">Result</div>
          <div class="dice-result-description" id="dice-result-description">Description</div>
        </div>
      </div>

      <!-- Character Card -->
      <div class="character-card good" id="character-card">
        <div class="player-name-display" id="player-name-display">Your Name</div>
        <h2 class="character-name" id="character-name">Loading...</h2>
        <div class="character-type" id="character-type">Character Type</div>
        <div class="character-team good" id="character-team">Team</div>
        
        <div class="character-ability">
          <h4>Your Ability</h4>
          <p id="character-ability-text">Loading character information...</p>
        </div>
      </div>

      <!-- Night/Day Instructions -->
      <div class="instructions-section" id="instructions-section">
        <h3>üìã Your Instructions</h3>
        <ul class="instructions-list" id="instructions-list">
          <li>Waiting for character assignment...</li>
        </ul>
      </div>

      <!-- Notes Section -->
      <div class="notes-section">
        <h3>
          üìù Your Private Notes
          <span>Only you can see these</span>
        </h3>
        <textarea 
          class="notes-textarea" 
          id="notes-textarea" 
          placeholder="Keep track of suspicions, observations, and clues here...

‚Ä¢ Who seems suspicious?
‚Ä¢ What did you learn tonight?
‚Ä¢ Who might be on your team?"
        ></textarea>
      </div>

      <!-- Leave Game Button -->
      <button class="leave-btn" id="leave-btn">Leave Game</button>
    </section>
  </main>

  <script>
    // BroadcastChannel for same-device fallback communication
    const CHANNEL_NAME = 'melodrama-player-channel';
    let channel = null;
    let retryTimeout = null;
    
    // Firebase listeners for cleanup
    let firebasePlayerUnsubscribe = null;
    let firebaseGameStateUnsubscribe = null;
    let firebaseConnectionUnsubscribe = null;

    // Player state
    const playerState = {
      gameCode: null,
      playerName: null,
      playerId: null,  // Unique Firebase player ID
      gamePlayerId: null, // ID from the game's player list
      character: null,
      phase: 'setup',
      night: 0,
      connected: false,
      notes: ''
    };

    // DOM Elements
    const loginSection = document.getElementById('login-section');
    const gameSection = document.getElementById('game-section');
    const gameCodeInput = document.getElementById('game-code');
    const playerNameInput = document.getElementById('player-name');
    const joinBtn = document.getElementById('join-btn');
    const errorMessage = document.getElementById('error-message');
    const connectionStatus = document.getElementById('connection-status');
    const statusText = connectionStatus.querySelector('.status-text');
    
    // Game section elements
    const phaseIndicator = document.getElementById('phase-indicator');
    const phaseLabel = document.getElementById('phase-label');
    const characterCard = document.getElementById('character-card');
    const playerNameDisplay = document.getElementById('player-name-display');
    const characterName = document.getElementById('character-name');
    const characterType = document.getElementById('character-type');
    const characterTeam = document.getElementById('character-team');
    const characterAbilityText = document.getElementById('character-ability-text');
    const instructionsList = document.getElementById('instructions-list');
    const notesTextarea = document.getElementById('notes-textarea');
    const leaveBtn = document.getElementById('leave-btn');
    
    // Win overlay elements
    const winOverlay = document.getElementById('win-overlay');
    const winTitle = document.getElementById('win-title');
    const winSubtitle = document.getElementById('win-subtitle');
    const winEmoji = document.getElementById('win-emoji');

    // Initialize
    function init() {
      // Load saved state from localStorage
      loadSavedState();
      
      // Set up event listeners
      gameCodeInput.addEventListener('input', handleCodeInput);
      playerNameInput.addEventListener('input', validateForm);
      joinBtn.addEventListener('click', handleJoin);
      leaveBtn.addEventListener('click', handleLeave);
      notesTextarea.addEventListener('input', saveNotes);
      
      // Set up BroadcastChannel for same-device fallback
      initBroadcastChannel();
      
      // Check Firebase availability
      if (window.firebaseDB && window.firebaseDB.initialized) {
        console.log('Firebase available for cross-device communication');
      } else {
        console.warn('Firebase not available - using BroadcastChannel only (same-device)');
      }
      
      // If we have a saved game code and character, try to reconnect
      if (playerState.gameCode && playerState.character && playerState.playerId) {
        showGameSection();
        // Try to reconnect via Firebase
        setupFirebaseListeners();
      }
    }

    function loadSavedState() {
      try {
        const saved = localStorage.getItem('melodrama_player_state');
        if (saved) {
          const parsed = JSON.parse(saved);
          Object.assign(playerState, parsed);
          
          // Restore notes
          if (playerState.notes) {
            notesTextarea.value = playerState.notes;
          }
          
          // Restore game code and name in inputs
          if (playerState.gameCode) {
            gameCodeInput.value = playerState.gameCode;
          }
          if (playerState.playerName) {
            playerNameInput.value = playerState.playerName;
          }
        }
      } catch (error) {
        console.warn('Failed to load saved state:', error);
      }
    }

    function saveState() {
      try {
        localStorage.setItem('melodrama_player_state', JSON.stringify(playerState));
      } catch (error) {
        console.warn('Failed to save state:', error);
      }
    }

    function saveNotes() {
      playerState.notes = notesTextarea.value;
      saveState();
    }

    function handleCodeInput(event) {
      // Convert to uppercase and filter non-alphanumeric
      let value = event.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
      event.target.value = value;
      validateForm();
    }

    function validateForm() {
      const code = gameCodeInput.value.trim();
      const name = playerNameInput.value.trim();
      joinBtn.disabled = code.length !== 4 || name.length === 0;
    }

    function initBroadcastChannel() {
      if ('BroadcastChannel' in window) {
        try {
          channel = new BroadcastChannel(CHANNEL_NAME);
          
          channel.onmessage = (event) => {
            handleBroadcastMessage(event.data);
          };

          channel.onmessageerror = (error) => {
            console.error('BroadcastChannel message error:', error);
          };

          console.log('BroadcastChannel initialized (same-device fallback)');
        } catch (error) {
          console.error('Failed to initialize BroadcastChannel:', error);
        }
      } else {
        console.warn('BroadcastChannel not supported');
      }
    }

    // Generate unique player ID for Firebase
    function generatePlayerId() {
      if (window.firebaseDB && window.firebaseDB.initialized) {
        const db = window.firebaseDB;
        const newRef = db.push(db.ref(db.database, 'temp'));
        return newRef.key;
      }
      // Fallback: generate a random ID
      return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function handleJoin() {
      const code = gameCodeInput.value.trim().toUpperCase();
      const name = playerNameInput.value.trim();
      
      if (code.length !== 4 || name.length === 0) {
        return;
      }
      
      playerState.gameCode = code;
      playerState.playerName = name;
      
      // Show waiting state
      errorMessage.classList.remove('visible');
      joinBtn.disabled = true;
      joinBtn.textContent = 'Joining...';
      
      // Try Firebase first (cross-device), then fall back to BroadcastChannel
      if (window.firebaseDB && window.firebaseDB.initialized) {
        joinViaFirebase(code, name);
      } else {
        // Fallback to BroadcastChannel
        joinViaBroadcastChannel(code, name);
      }
    }

    function joinViaFirebase(code, name) {
      const db = window.firebaseDB;
      
      // First, check if the game exists
      const gameRef = db.ref(db.database, `games/${code}`);
      
      db.onValue(gameRef, (snapshot) => {
        const gameData = snapshot.val();
        
        if (!gameData) {
          // Game doesn't exist - try BroadcastChannel as fallback
          console.log('Game not found in Firebase, trying BroadcastChannel...');
          joinViaBroadcastChannel(code, name);
          return;
        }
        
        // Game exists! Generate a unique player ID and join
        const playerId = generatePlayerId();
        playerState.playerId = playerId;
        saveState();
        
        // Write player info to Firebase
        const playerRef = db.ref(db.database, `games/${code}/players/${playerId}`);
        
        db.set(playerRef, {
          name: name,
          joinedAt: Date.now()
        }).then(() => {
          console.log('Joined game via Firebase');
          
          // Set up disconnect cleanup
          db.onDisconnect(playerRef).remove();
          
          // Set up listeners for character assignment and game state
          setupFirebaseListeners();
          
        }).catch((error) => {
          console.error('Failed to join via Firebase:', error);
          showError('Failed to join game. Please try again.');
          joinBtn.disabled = false;
          joinBtn.textContent = 'Join Game';
        });
        
      }, { onlyOnce: true });
    }

    function joinViaBroadcastChannel(code, name) {
      saveState();
      
      // Send join request via BroadcastChannel
      if (channel) {
        channel.postMessage({
          type: 'player-join',
          gameCode: code,
          playerName: name
        });
      }
      
      // Set timeout for response
      retryTimeout = setTimeout(() => {
        showError('No game found with this code. Make sure the narrator has started a game.');
        joinBtn.disabled = false;
        joinBtn.textContent = 'Join Game';
      }, JOIN_TIMEOUT_MS);
    }

    function setupFirebaseListeners() {
      if (!window.firebaseDB || !window.firebaseDB.initialized || !playerState.gameCode || !playerState.playerId) {
        return;
      }
      
      const db = window.firebaseDB;
      
      // Clean up any existing listeners
      cleanupFirebaseListeners();
      
      // Listen for character assignment on this player's node
      const playerRef = db.ref(db.database, `games/${playerState.gameCode}/players/${playerState.playerId}`);
      firebasePlayerUnsubscribe = db.onValue(playerRef, (snapshot) => {
        const playerData = snapshot.val();
        
        if (!playerData) {
          // Player was removed (game reset)
          handleGameReset();
          return;
        }
        
        if (playerData.status === 'rejected') {
          // Join was rejected
          clearTimeout(retryTimeout);
          showError(playerData.reason || 'Unable to join game.');
          joinBtn.disabled = false;
          joinBtn.textContent = 'Join Game';
          cleanupFirebaseListeners();
          return;
        }
        
        if (playerData.status === 'assigned' && playerData.character) {
          // Character was assigned!
          clearTimeout(retryTimeout);
          playerState.gamePlayerId = playerData.gamePlayerId;
          playerState.character = playerData.character;
          playerState.connected = true;
          saveState();
          
          showGameSection();
          updateCharacterDisplay();
          updateConnectionStatus(true);
        }
      });
      
      // Listen for game state changes
      const gameStateRef = db.ref(db.database, `games/${playerState.gameCode}/gameState`);
      firebaseGameStateUnsubscribe = db.onValue(gameStateRef, (snapshot) => {
        const gameState = snapshot.val();
        
        if (!gameState) {
          // Game was deleted
          handleGameReset();
          return;
        }
        
        if (gameState.reset) {
          // Game was reset
          handleGameReset();
          return;
        }
        
        // Update phase
        if (gameState.phase) {
          updatePhase(gameState.phase, gameState.night || 0);
        }
        
        // Check for win
        if (gameState.winTeam) {
          showWinNotification(gameState.winTeam, gameState.night || 0);
        }
        
        updateConnectionStatus(true);
      });
      
      // Listen for connection state
      const connectedRef = db.ref(db.database, '.info/connected');
      firebaseConnectionUnsubscribe = db.onValue(connectedRef, (snapshot) => {
        const connected = snapshot.val();
        updateConnectionStatus(connected === true && playerState.character !== null);
      });
    }

    function cleanupFirebaseListeners() {
      if (firebasePlayerUnsubscribe) {
        firebasePlayerUnsubscribe();
        firebasePlayerUnsubscribe = null;
      }
      if (firebaseGameStateUnsubscribe) {
        firebaseGameStateUnsubscribe();
        firebaseGameStateUnsubscribe = null;
      }
      if (firebaseConnectionUnsubscribe) {
        firebaseConnectionUnsubscribe();
        firebaseConnectionUnsubscribe = null;
      }
    }

    // Handle BroadcastChannel messages (same-device fallback)
    function handleBroadcastMessage(data) {
      console.log('Received BroadcastChannel message:', data);
      
      // Check if this message is for our game code
      if (data.gameCode && data.gameCode !== playerState.gameCode) {
        return;
      }
      
      switch (data.type) {
        case 'player-assigned':
          if (data.playerName === playerState.playerName) {
            clearTimeout(retryTimeout);
            handlePlayerAssigned(data);
          }
          break;
          
        case 'join-rejected':
          if (data.playerName === playerState.playerName) {
            clearTimeout(retryTimeout);
            showError(data.reason || 'Unable to join game.');
            joinBtn.disabled = false;
            joinBtn.textContent = 'Join Game';
          }
          break;
          
        case 'game-state':
          updateGameState(data);
          break;
          
        case 'phase-change':
          updatePhase(data.phase, data.night);
          break;
          
        case 'WIN':
          showWinNotification(data.team, data.night);
          break;
          
        case 'game-reset':
          handleGameReset();
          break;
      }
    }

    function handlePlayerAssigned(data) {
      playerState.playerId = data.playerId || generatePlayerId();
      playerState.gamePlayerId = data.playerId;
      playerState.character = data.character;
      playerState.connected = true;
      saveState();
      
      showGameSection();
      updateCharacterDisplay();
      updateConnectionStatus(true);
      startConnectionCheck();
    }

    function showGameSection() {
      loginSection.style.display = 'none';
      gameSection.classList.add('active');
      
      if (playerState.character) {
        updateCharacterDisplay();
      }
    }

    function updateCharacterDisplay() {
      const char = playerState.character;
      if (!char) return;
      
      // Update player name
      playerNameDisplay.textContent = playerState.playerName;
      
      // Update character info
      characterName.textContent = char.name;
      characterType.textContent = `${char.typeLabel || char.type}-Type`;
      
      // Update team badge
      characterTeam.textContent = char.team === 'good' ? 'üëº Good Team' : 'üòà Evil Team';
      characterTeam.className = `character-team ${char.team}`;
      
      // Update card styling
      characterCard.className = `character-card ${char.team}`;
      
      // Update ability text
      characterAbilityText.textContent = char.power || char.short || 'No ability description available.';
      
      // Update instructions based on character
      updateInstructions(char);
    }

    function updateInstructions(char) {
      const instructions = [];
      
      // Add night instructions
      if (char.nightB && Array.isArray(char.nightB)) {
        char.nightB.forEach(instruction => {
          instructions.push(instruction);
        });
      }
      
      // Add day instructions
      if (char.dayB && Array.isArray(char.dayB)) {
        char.dayB.forEach(instruction => {
          instructions.push(instruction);
        });
      }
      
      // If no instructions, add default
      if (instructions.length === 0) {
        instructions.push('Listen to the narrator for your cues.');
        instructions.push('Stay in character and be dramatic!');
        if (char.team === 'evil') {
          instructions.push('Work with your team to eliminate the good players.');
        } else {
          instructions.push('Work to identify and eliminate the evil players.');
        }
      }
      
      // Update the list
      instructionsList.innerHTML = '';
      instructions.forEach(instruction => {
        const li = document.createElement('li');
        li.textContent = instruction;
        instructionsList.appendChild(li);
      });
    }

    function updatePhase(phase, night) {
      playerState.phase = phase;
      playerState.night = night;
      saveState();
      
      phaseIndicator.className = `phase-indicator ${phase}`;
      
      if (phase === 'night') {
        phaseLabel.textContent = `üåô Night ${night}`;
      } else if (phase === 'day') {
        phaseLabel.textContent = `‚òÄÔ∏è Day ${night}`;
      } else {
        phaseLabel.textContent = 'Waiting for game...';
      }
    }

    function updateGameState(data) {
      if (data.phase) {
        updatePhase(data.phase, data.night || 0);
      }
      updateConnectionStatus(true);
    }

    function showWinNotification(team, nightCount) {
      if (team === 'good') {
        winTitle.textContent = 'Good Team Wins!';
        winTitle.className = 'win-title good';
        winEmoji.textContent = 'üé≠ üèÜ üé≠';
        winSubtitle.textContent = `Victory after ${nightCount} nights!`;
      } else if (team === 'evil') {
        winTitle.textContent = 'Evil Team Wins!';
        winTitle.className = 'win-title evil';
        winEmoji.textContent = 'üòà üíÄ üòà';
        winSubtitle.textContent = `Darkness prevails after ${nightCount} nights!`;
      }
      winOverlay.classList.add('active');
    }

    function handleGameReset() {
      // Stop connection check
      stopConnectionCheck();
      
      // Clean up Firebase listeners
      cleanupFirebaseListeners();
      
      // Clear character assignment but keep notes
      playerState.character = null;
      playerState.playerId = null;
      playerState.gamePlayerId = null;
      playerState.phase = 'setup';
      playerState.night = 0;
      saveState();
      
      // Hide win overlay
      winOverlay.classList.remove('active');
      
      // Go back to login
      gameSection.classList.remove('active');
      loginSection.style.display = 'flex';
      joinBtn.disabled = false;
      joinBtn.textContent = 'Join Game';
    }

    function handleLeave() {
      if (confirm('Are you sure you want to leave the game?')) {
        // Remove from Firebase if connected
        if (window.firebaseDB && window.firebaseDB.initialized && playerState.gameCode && playerState.playerId) {
          const db = window.firebaseDB;
          const playerRef = db.ref(db.database, `games/${playerState.gameCode}/players/${playerState.playerId}`);
          db.remove(playerRef).catch((error) => {
            console.warn('Failed to remove player from Firebase:', error);
          });
        }
        
        // Notify via BroadcastChannel (for same-device)
        if (channel) {
          channel.postMessage({
            type: 'player-leave',
            gameCode: playerState.gameCode,
            playerName: playerState.playerName,
            playerId: playerState.gamePlayerId
          });
        }
        
        handleGameReset();
      }
    }

    function requestStateUpdate() {
      // Via BroadcastChannel
      if (channel && playerState.gameCode) {
        channel.postMessage({
          type: 'player-request-state',
          gameCode: playerState.gameCode,
          playerName: playerState.playerName
        });
      }
    }

    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.classList.add('visible');
    }

    // Constants
    const JOIN_TIMEOUT_MS = 5000;
    const CONNECTION_CHECK_INTERVAL_MS = 10000;

    // Interval handle for cleanup
    let connectionCheckInterval = null;

    function updateConnectionStatus(connected) {
      playerState.connected = connected;
      
      if (connected) {
        connectionStatus.classList.remove('disconnected');
        connectionStatus.classList.add('connected');
        statusText.textContent = 'Connected';
      } else {
        connectionStatus.classList.remove('connected');
        connectionStatus.classList.add('disconnected');
        statusText.textContent = 'Not Connected';
      }
    }

    // Start periodic connection check (for BroadcastChannel fallback)
    function startConnectionCheck() {
      if (connectionCheckInterval) return; // Already running
      connectionCheckInterval = setInterval(() => {
        if (playerState.gameCode && playerState.character) {
          requestStateUpdate();
        }
      }, CONNECTION_CHECK_INTERVAL_MS);
    }

    // Stop periodic connection check
    function stopConnectionCheck() {
      if (connectionCheckInterval) {
        clearInterval(connectionCheckInterval);
        connectionCheckInterval = null;
      }
    }

    // ===== GAME TIPS SYSTEM =====
    const GAME_TIPS = [
      {
        title: "Stay in Character",
        text: "The more dramatic your performance, the more fun everyone has! Don't be afraid to overact.",
        category: "acting"
      },
      {
        title: "Trust Your Instincts",
        text: "If someone seems too helpful or too quiet, there might be a reason. Pay attention to behavior changes.",
        category: "strategy"
      },
      {
        title: "Take Notes",
        text: "Write down who accused whom, who defended whom, and any suspicious behavior. Notes help you spot patterns.",
        category: "strategy"
      },
      {
        title: "The Power of Silence",
        text: "Sometimes saying nothing is the best strategy. Let others reveal themselves through their accusations.",
        category: "strategy"
      },
      {
        title: "Dramatic Deaths",
        text: "When you're eliminated, give a memorable death scene! Point at someone, gasp dramatically, or deliver a final monologue.",
        category: "acting"
      },
      {
        title: "Night Phase Rules",
        text: "Keep your eyes CLOSED during night unless the narrator calls your role. Peeking ruins the mystery!",
        category: "rules"
      },
      {
        title: "Day Phase Discussion",
        text: "During the day, discuss openly but remember - evil players will lie to survive. Question everything!",
        category: "rules"
      },
      {
        title: "Claim Strategically",
        text: "You can claim to be any role, but be careful - if the real player is alive, they might call you out!",
        category: "strategy"
      },
      {
        title: "Evil Team Coordination",
        text: "Evil players know each other. They might subtly defend or redirect suspicion from teammates.",
        category: "strategy"
      },
      {
        title: "Watch the Reactions",
        text: "When someone is eliminated, watch how others react. Genuine surprise vs. fake surprise can be revealing.",
        category: "strategy"
      },
      {
        title: "Have Fun!",
        text: "Win or lose, the goal is entertainment! Embrace the drama, enjoy the twists, and celebrate great performances.",
        category: "fun"
      },
      {
        title: "The Art of Misdirection",
        text: "Point suspicion elsewhere subtly. Too aggressive makes you a target; too quiet makes you suspicious.",
        category: "strategy"
      },
      {
        title: "Character Voice",
        text: "Try giving your character a unique voice, accent, or speech pattern. It makes the game more immersive!",
        category: "acting"
      },
      {
        title: "Vote Carefully",
        text: "Your vote matters! Consider the evidence carefully, but also trust your gut feeling about who's lying.",
        category: "rules"
      },
      {
        title: "The Final Showdown",
        text: "When it's down to the last few players, every word and gesture matters. This is where champions are made!",
        category: "fun"
      }
    ];

    let currentTipIndex = 0;
    let tipRotationInterval = null;

    function initGameTips() {
      renderTip(0);
      renderTipNavigation();
      startTipRotation();
    }

    function renderTip(index) {
      const tip = GAME_TIPS[index];
      const titleEl = document.getElementById('login-tip-title');
      const textEl = document.getElementById('login-tip-text');
      const categoryEl = document.getElementById('login-tip-category');
      const cardEl = document.getElementById('login-tip-card');
      
      if (!titleEl || !tip) return;
      
      // Trigger animation
      cardEl.style.animation = 'none';
      cardEl.offsetHeight; // Force reflow
      cardEl.style.animation = 'tipFade 0.5s ease-out';
      
      titleEl.textContent = tip.title;
      textEl.textContent = tip.text;
      categoryEl.textContent = tip.category.charAt(0).toUpperCase() + tip.category.slice(1);
      categoryEl.className = `tip-category ${tip.category}`;
      
      currentTipIndex = index;
      updateTipNavigation();
    }

    function renderTipNavigation() {
      const navEl = document.getElementById('login-tip-nav');
      if (!navEl) return;
      
      navEl.innerHTML = '';
      GAME_TIPS.forEach((_, index) => {
        const dot = document.createElement('div');
        dot.className = `tip-dot ${index === currentTipIndex ? 'active' : ''}`;
        dot.onclick = () => {
          renderTip(index);
          restartTipRotation();
        };
        navEl.appendChild(dot);
      });
    }

    function updateTipNavigation() {
      const dots = document.querySelectorAll('#login-tip-nav .tip-dot');
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', index === currentTipIndex);
      });
    }

    function startTipRotation() {
      tipRotationInterval = setInterval(() => {
        const nextIndex = (currentTipIndex + 1) % GAME_TIPS.length;
        renderTip(nextIndex);
      }, 8000); // Rotate every 8 seconds
    }

    function restartTipRotation() {
      if (tipRotationInterval) {
        clearInterval(tipRotationInterval);
      }
      startTipRotation();
    }

    function stopTipRotation() {
      if (tipRotationInterval) {
        clearInterval(tipRotationInterval);
        tipRotationInterval = null;
      }
    }

    // ===== VOTING SYSTEM =====
    const votingState = {
      active: false,
      selectedPlayer: null,
      submitted: false,
      players: []
    };

    // Voting DOM elements (initialized in initVoting)
    let votingSection = null;
    let voteOptions = null;
    let submitVoteBtn = null;
    let voteSubmitted = null;

    function initVoting() {
      votingSection = document.getElementById('voting-section');
      voteOptions = document.getElementById('vote-options');
      submitVoteBtn = document.getElementById('submit-vote-btn');
      voteSubmitted = document.getElementById('vote-submitted');
      
      if (submitVoteBtn) {
        submitVoteBtn.addEventListener('click', handleVoteSubmit);
      }
    }

    function showVoting(players) {
      if (!votingSection || !voteOptions) return;
      
      votingState.active = true;
      votingState.players = players;
      votingState.selectedPlayer = null;
      votingState.submitted = false;
      
      // Render vote options
      voteOptions.innerHTML = '';
      players.forEach(player => {
        if (player.name === playerState.playerName) return; // Can't vote for yourself
        
        const option = document.createElement('div');
        option.className = 'vote-option';
        option.innerHTML = `
          <span class="vote-option-name">${escapeHtml(player.name)}</span>
          <span class="vote-option-check"></span>
        `;
        option.onclick = () => selectVoteOption(player.id, option);
        voteOptions.appendChild(option);
      });
      
      votingSection.classList.add('active');
      submitVoteBtn.disabled = true;
      submitVoteBtn.classList.remove('hidden');
      voteSubmitted.classList.add('hidden');
    }

    function selectVoteOption(playerId, optionEl) {
      if (votingState.submitted) return;
      
      // Clear previous selection
      document.querySelectorAll('.vote-option').forEach(el => {
        el.classList.remove('selected');
      });
      
      // Select new option
      optionEl.classList.add('selected');
      optionEl.querySelector('.vote-option-check').textContent = '‚úì';
      votingState.selectedPlayer = playerId;
      submitVoteBtn.disabled = false;
    }

    function handleVoteSubmit() {
      if (!votingState.selectedPlayer || votingState.submitted) return;
      
      votingState.submitted = true;
      submitVoteBtn.disabled = true;
      
      // Send vote to Firebase
      if (window.firebaseDB && window.firebaseDB.initialized && playerState.gameCode && playerState.playerId) {
        const db = window.firebaseDB;
        const voteRef = db.ref(db.database, `games/${playerState.gameCode}/votes/${playerState.playerId}`);
        db.set(voteRef, {
          votedFor: votingState.selectedPlayer,
          voterName: playerState.playerName,
          timestamp: Date.now()
        }).then(() => {
          console.log('Vote submitted successfully');
        }).catch((error) => {
          console.error('Failed to submit vote:', error);
        });
      }
      
      // Send via BroadcastChannel as well
      if (channel) {
        channel.postMessage({
          type: 'player-vote',
          gameCode: playerState.gameCode,
          playerName: playerState.playerName,
          playerId: playerState.gamePlayerId,
          votedFor: votingState.selectedPlayer
        });
      }
      
      // Show confirmation
      submitVoteBtn.classList.add('hidden');
      voteSubmitted.classList.remove('hidden');
    }

    function hideVoting() {
      if (votingSection) {
        votingSection.classList.remove('active');
      }
      votingState.active = false;
    }

    // ===== DICE ROLL SYSTEM =====
    const diceState = {
      available: false,
      used: false,
      lastResult: null
    };

    const DICE_FACES = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];

    let diceRollSection = null;
    let rollDiceBtn = null;
    let diceResult = null;
    let diceFace = null;
    let diceResultText = null;
    let diceResultDescription = null;
    let diceInfo = null;

    function initDiceRoll() {
      diceRollSection = document.getElementById('dice-roll-section');
      rollDiceBtn = document.getElementById('roll-dice-btn');
      diceResult = document.getElementById('dice-result');
      diceFace = document.getElementById('dice-face');
      diceResultText = document.getElementById('dice-result-text');
      diceResultDescription = document.getElementById('dice-result-description');
      diceInfo = document.getElementById('dice-info');
      
      if (rollDiceBtn) {
        rollDiceBtn.addEventListener('click', handleDiceRoll);
      }
    }

    function showDiceRoll(characterType, characterName) {
      if (!diceRollSection || characterType !== 'sidekick') return;
      
      diceState.available = true;
      diceState.used = false;
      
      // Set info text based on character
      if (diceInfo) {
        diceInfo.textContent = `As ${characterName}, roll 4-6 to succeed, 1-3 to fail!`;
      }
      
      diceRollSection.classList.add('active');
      rollDiceBtn.disabled = false;
      diceResult.classList.remove('active', 'success', 'failure');
    }

    function hideDiceRoll() {
      if (diceRollSection) {
        diceRollSection.classList.remove('active');
      }
      diceState.available = false;
    }

    function handleDiceRoll() {
      if (!diceState.available || diceState.used) return;
      
      diceState.used = true;
      rollDiceBtn.disabled = true;
      
      // Animate dice roll
      let rollCount = 0;
      const rollAnimation = setInterval(() => {
        diceFace.textContent = DICE_FACES[Math.floor(Math.random() * 6)];
        rollCount++;
        
        if (rollCount >= 10) {
          clearInterval(rollAnimation);
          
          // Final result
          const result = Math.floor(Math.random() * 6) + 1;
          diceFace.textContent = DICE_FACES[result - 1];
          diceState.lastResult = result;
          
          // Determine success/failure
          const success = result >= 4;
          
          diceResult.classList.add('active');
          diceResult.classList.add(success ? 'success' : 'failure');
          
          if (success) {
            diceResultText.textContent = `üéâ Success! You rolled a ${result}!`;
            diceResultDescription.textContent = 'Your power activates! Announce your action to the narrator.';
          } else {
            diceResultText.textContent = `üí• Failed! You rolled a ${result}!`;
            diceResultDescription.textContent = 'Your power misfires! Tell the narrator what happened.';
          }
          
          // Send result to Firebase
          if (window.firebaseDB && window.firebaseDB.initialized && playerState.gameCode && playerState.playerId) {
            const db = window.firebaseDB;
            const diceRef = db.ref(db.database, `games/${playerState.gameCode}/diceRolls/${playerState.playerId}`);
            db.set(diceRef, {
              playerName: playerState.playerName,
              result: result,
              success: success,
              timestamp: Date.now()
            });
          }
          
          // Send via BroadcastChannel
          if (channel) {
            channel.postMessage({
              type: 'player-dice-roll',
              gameCode: playerState.gameCode,
              playerName: playerState.playerName,
              playerId: playerState.gamePlayerId,
              result: result,
              success: success
            });
          }
        }
      }, 100);
    }

    // Utility function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Update handleBroadcastMessage to handle voting and dice roll messages
    const originalHandleBroadcastMessage = handleBroadcastMessage;
    handleBroadcastMessage = function(data) {
      // Handle voting messages
      if (data.type === 'voting-start' && data.gameCode === playerState.gameCode) {
        showVoting(data.players);
        return;
      }
      
      if (data.type === 'voting-end' && data.gameCode === playerState.gameCode) {
        hideVoting();
        return;
      }
      
      if (data.type === 'dice-roll-available' && data.gameCode === playerState.gameCode) {
        if (playerState.character && playerState.character.type === 'sidekick') {
          showDiceRoll('sidekick', playerState.character.name);
        }
        return;
      }
      
      // Call original handler
      if (typeof originalHandleBroadcastMessage === 'function') {
        originalHandleBroadcastMessage(data);
      }
    };

    // Modify init to include new features
    const originalInit = init;
    init = function() {
      // Call original init
      originalInit();
      
      // Initialize new features
      initGameTips();
      initVoting();
      initDiceRoll();
    };

    // Modify showGameSection to show dice roll for sidekicks
    const originalShowGameSection = showGameSection;
    showGameSection = function() {
      originalShowGameSection();
      
      // Stop tip rotation when game starts
      stopTipRotation();
      
      // Show dice roll for sidekicks
      if (playerState.character && playerState.character.type === 'sidekick') {
        showDiceRoll('sidekick', playerState.character.name);
      }
    };

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', init);

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      stopConnectionCheck();
      cleanupFirebaseListeners();
      if (channel) {
        channel.close();
      }
    });
  </script>
</body>
</html>
